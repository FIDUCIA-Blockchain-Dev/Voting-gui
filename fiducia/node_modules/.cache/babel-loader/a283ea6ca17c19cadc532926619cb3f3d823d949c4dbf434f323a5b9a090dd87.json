{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nimport { AbiError } from 'web3-errors';\nimport { ParamType } from '@ethersproject/abi';\nimport { isNullish, leftPad, rightPad, toHex } from 'web3-utils';\nimport ethersAbiCoder from './ethers_abi_coder.js';\nexport const isAbiFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && ['function', 'event', 'constructor', 'error'].includes(item.type);\nexport const isAbiErrorFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'error';\nexport const isAbiEventFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'event';\nexport const isAbiFunctionFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'function';\nexport const isAbiConstructorFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'constructor';\n/**\r\n * Check if type is simplified struct format\r\n */\nexport const isSimplifiedStructFormat = type => typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n */\nexport const mapStructNameAndType = structName => structName.includes('[]') ? {\n  type: 'tuple[]',\n  name: structName.slice(0, -2)\n} : {\n  type: 'tuple',\n  name: structName\n};\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n */\nexport const mapStructToCoderFormat = struct => {\n  const components = [];\n  for (const key of Object.keys(struct)) {\n    const item = struct[key];\n    if (typeof item === 'object') {\n      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), {\n        components: mapStructToCoderFormat(item)\n      }));\n    } else {\n      components.push({\n        name: key,\n        type: struct[key]\n      });\n    }\n  }\n  return components;\n};\n/**\r\n * Map types if simplified format is used\r\n */\nexport const mapTypes = types => {\n  const mappedTypes = [];\n  for (const type of types) {\n    let modifiedType = type;\n    // Clone object\n    if (typeof type === 'object') {\n      modifiedType = Object.assign({}, type);\n    }\n    // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n    if (typeof type === 'object' && type.type === 'function') {\n      modifiedType = Object.assign(Object.assign({}, type), {\n        type: 'bytes24'\n      });\n    }\n    if (isSimplifiedStructFormat(modifiedType)) {\n      const structName = Object.keys(modifiedType)[0];\n      mappedTypes.push(Object.assign(Object.assign({}, mapStructNameAndType(structName)), {\n        components: mapStructToCoderFormat(modifiedType[structName])\n      }));\n    } else {\n      mappedTypes.push(modifiedType);\n    }\n  }\n  return mappedTypes;\n};\n/**\r\n * returns true if input is a hexstring and is odd-lengthed\r\n */\nexport const isOddHexstring = param => typeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n/**\r\n * format odd-length bytes to even-length\r\n */\nexport const formatOddHexstrings = param => isOddHexstring(param) ? `0x0${param.substring(2)}` : param;\n/**\r\n * Handle some formatting of params for backwards compatibility with Ethers V4\r\n */\nexport const formatParam = (type, _param) => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  var _a;\n  // clone if _param is an object\n  const param = typeof _param === 'object' && !Array.isArray(_param) ? Object.assign({}, _param) : _param;\n  const paramTypeBytes = /^bytes([0-9]*)$/;\n  const paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n  const paramTypeNumber = /^(u?int)([0-9]*)$/;\n  const paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\n  // Format BN to string\n  if (param instanceof BigInt) {\n    return param.toString(10);\n  }\n  if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    const paramClone = [...param];\n    return paramClone.map(p => formatParam(type.replace('[]', ''), p));\n  }\n  // Format correct width for u?int[0-9]*\n  let match = paramTypeNumber.exec(type);\n  if (match) {\n    const size = parseInt((_a = match[2]) !== null && _a !== void 0 ? _a : '256', 10);\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      return leftPad(param, size);\n    }\n  }\n  // Format correct length for bytes[0-9]+\n  match = paramTypeBytes.exec(type);\n  if (match) {\n    const hexParam = param instanceof Uint8Array ? toHex(param) : param;\n    // format to correct length\n    const size = parseInt(match[1], 10);\n    if (size) {\n      let maxSize = size * 2;\n      if (param.startsWith('0x')) {\n        maxSize += 2;\n      }\n      // pad to correct length\n      const paddedParam = hexParam.length < maxSize ? rightPad(param, size * 2) : hexParam;\n      return formatOddHexstrings(paddedParam);\n    }\n    return formatOddHexstrings(hexParam);\n  }\n  return param;\n};\n// eslint-disable-next-line consistent-return\nexport const modifyParams = (coder, param) => {\n  if (coder.name === 'array') {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return param.map(p =>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), [p]));\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any\n  coder.coders.forEach((c, i) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (c.name === 'tuple') {\n      modifyParams(c, [param[i]]);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, no-param-reassign\n      param[i] = formatParam(c.name, param[i]);\n    }\n  });\n  return [];\n};\n/**\r\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\r\n */\nexport const flattenTypes = (includeTuple, puts) => {\n  const types = [];\n  puts.forEach(param => {\n    if (typeof param.components === 'object') {\n      if (!param.type.startsWith('tuple')) {\n        throw new AbiError(`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`);\n      }\n      const arrayBracket = param.type.indexOf('[');\n      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n      const result = flattenTypes(includeTuple, param.components);\n      if (Array.isArray(result) && includeTuple) {\n        types.push(`tuple(${result.join(',')})${suffix}`);\n      } else if (!includeTuple) {\n        types.push(`(${result.join(',')})${suffix}`);\n      } else {\n        types.push(`(${result.join()})`);\n      }\n    } else {\n      types.push(param.type);\n    }\n  });\n  return types;\n};\n/**\r\n * Should be used to create full function/event name from json abi\r\n * returns a string\r\n */\nexport const jsonInterfaceMethodToString = json => {\n  var _a, _b, _c, _d;\n  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\n    if ((_a = json.name) === null || _a === void 0 ? void 0 : _a.includes('(')) {\n      return json.name;\n    }\n    return `${(_b = json.name) !== null && _b !== void 0 ? _b : ''}(${flattenTypes(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(',')})`;\n  }\n  // Constructor fragment\n  return `(${flattenTypes(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(',')})`;\n};","map":{"version":3,"names":["AbiError","ParamType","isNullish","leftPad","rightPad","toHex","ethersAbiCoder","isAbiFragment","item","type","includes","isAbiErrorFragment","isAbiEventFragment","isAbiFunctionFragment","isAbiConstructorFragment","isSimplifiedStructFormat","components","name","mapStructNameAndType","structName","slice","mapStructToCoderFormat","struct","key","Object","keys","push","assign","mapTypes","types","mappedTypes","modifiedType","isOddHexstring","param","test","length","formatOddHexstrings","substring","formatParam","_param","Array","isArray","paramTypeBytes","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","BigInt","toString","exec","paramClone","map","p","replace","match","size","parseInt","_a","hexParam","Uint8Array","maxSize","startsWith","paddedParam","modifyParams","coder","_getCoder","from","coders","forEach","c","i","flattenTypes","includeTuple","puts","arrayBracket","indexOf","suffix","result","join","jsonInterfaceMethodToString","json","_b","_c","inputs","_d"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-eth-abi\\src\\utils.ts"],"sourcesContent":["ï»¿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { AbiError } from 'web3-errors';\r\nimport { AbiCoder, ParamType } from '@ethersproject/abi';\r\nimport { isNullish, leftPad, rightPad, toHex } from 'web3-utils';\r\nimport {\r\n\tAbiInput,\r\n\tAbiCoderStruct,\r\n\tAbiFragment,\r\n\tAbiParameter,\r\n\tAbiStruct,\r\n\tAbiEventFragment,\r\n\tAbiFunctionFragment,\r\n\tAbiConstructorFragment,\r\n} from 'web3-types';\r\nimport ethersAbiCoder from './ethers_abi_coder.js';\r\n\r\nexport const isAbiFragment = (item: unknown): item is AbiFragment =>\r\n\t!isNullish(item) &&\r\n\ttypeof item === 'object' &&\r\n\t!isNullish((item as { type: string }).type) &&\r\n\t['function', 'event', 'constructor', 'error'].includes((item as { type: string }).type);\r\n\r\nexport const isAbiErrorFragment = (item: unknown): item is AbiEventFragment =>\r\n\t!isNullish(item) &&\r\n\ttypeof item === 'object' &&\r\n\t!isNullish((item as { type: string }).type) &&\r\n\t(item as { type: string }).type === 'error';\r\n\r\nexport const isAbiEventFragment = (item: unknown): item is AbiEventFragment =>\r\n\t!isNullish(item) &&\r\n\ttypeof item === 'object' &&\r\n\t!isNullish((item as { type: string }).type) &&\r\n\t(item as { type: string }).type === 'event';\r\n\r\nexport const isAbiFunctionFragment = (item: unknown): item is AbiFunctionFragment =>\r\n\t!isNullish(item) &&\r\n\ttypeof item === 'object' &&\r\n\t!isNullish((item as { type: string }).type) &&\r\n\t(item as { type: string }).type === 'function';\r\n\r\nexport const isAbiConstructorFragment = (item: unknown): item is AbiConstructorFragment =>\r\n\t!isNullish(item) &&\r\n\ttypeof item === 'object' &&\r\n\t!isNullish((item as { type: string }).type) &&\r\n\t(item as { type: string }).type === 'constructor';\r\n\r\n/**\r\n * Check if type is simplified struct format\r\n */\r\nexport const isSimplifiedStructFormat = (\r\n\ttype: string | Partial<AbiParameter> | Partial<AbiInput>,\r\n): type is Omit<AbiParameter, 'components' | 'name'> =>\r\n\ttypeof type === 'object' &&\r\n\ttypeof (type as { components: unknown }).components === 'undefined' &&\r\n\ttypeof (type as { name: unknown }).name === 'undefined';\r\n\r\n/**\r\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\r\n */\r\nexport const mapStructNameAndType = (structName: string): AbiStruct =>\r\n\tstructName.includes('[]')\r\n\t\t? { type: 'tuple[]', name: structName.slice(0, -2) }\r\n\t\t: { type: 'tuple', name: structName };\r\n\r\n/**\r\n * Maps the simplified format in to the expected format of the ABICoder\r\n */\r\nexport const mapStructToCoderFormat = (struct: AbiStruct): Array<AbiCoderStruct> => {\r\n\tconst components: Array<AbiCoderStruct> = [];\r\n\r\n\tfor (const key of Object.keys(struct)) {\r\n\t\tconst item = struct[key];\r\n\r\n\t\tif (typeof item === 'object') {\r\n\t\t\tcomponents.push({\r\n\t\t\t\t...mapStructNameAndType(key),\r\n\t\t\t\tcomponents: mapStructToCoderFormat(item as unknown as AbiStruct),\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tcomponents.push({\r\n\t\t\t\tname: key,\r\n\t\t\t\ttype: struct[key] as string,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\treturn components;\r\n};\r\n\r\n/**\r\n * Map types if simplified format is used\r\n */\r\nexport const mapTypes = (\r\n\ttypes: AbiInput[],\r\n): Array<string | AbiParameter | Record<string, unknown>> => {\r\n\tconst mappedTypes: Array<string | AbiParameter | Record<string, unknown>> = [];\r\n\r\n\tfor (const type of types) {\r\n\t\tlet modifiedType = type;\r\n\r\n\t\t// Clone object\r\n\t\tif (typeof type === 'object') {\r\n\t\t\tmodifiedType = { ...type };\r\n\t\t}\r\n\r\n\t\t// Remap `function` type params to bytes24 since Ethers does not\r\n\t\t// recognize former type. Solidity docs say `Function` is a bytes24\r\n\t\t// encoding the contract address followed by the function selector hash.\r\n\t\tif (typeof type === 'object' && type.type === 'function') {\r\n\t\t\tmodifiedType = { ...type, type: 'bytes24' };\r\n\t\t}\r\n\r\n\t\tif (isSimplifiedStructFormat(modifiedType)) {\r\n\t\t\tconst structName = Object.keys(modifiedType)[0] as unknown as keyof typeof modifiedType;\r\n\r\n\t\t\tmappedTypes.push({\r\n\t\t\t\t...mapStructNameAndType(structName),\r\n\t\t\t\tcomponents: mapStructToCoderFormat(\r\n\t\t\t\t\tmodifiedType[structName] as unknown as AbiStruct,\r\n\t\t\t\t) as unknown as AbiParameter[],\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tmappedTypes.push(modifiedType);\r\n\t\t}\r\n\t}\r\n\r\n\treturn mappedTypes;\r\n};\r\n\r\n/**\r\n * returns true if input is a hexstring and is odd-lengthed\r\n */\r\nexport const isOddHexstring = (param: unknown): boolean =>\r\n\ttypeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\r\n\r\n/**\r\n * format odd-length bytes to even-length\r\n */\r\nexport const formatOddHexstrings = (param: string): string =>\r\n\tisOddHexstring(param) ? `0x0${param.substring(2)}` : param;\r\n\r\n/**\r\n * Handle some formatting of params for backwards compatibility with Ethers V4\r\n */\r\nexport const formatParam = (type: string, _param: unknown): unknown => {\r\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n\r\n\t// clone if _param is an object\r\n\tconst param = typeof _param === 'object' && !Array.isArray(_param) ? { ..._param } : _param;\r\n\tconst paramTypeBytes = /^bytes([0-9]*)$/;\r\n\tconst paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\r\n\tconst paramTypeNumber = /^(u?int)([0-9]*)$/;\r\n\tconst paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\r\n\r\n\t// Format BN to string\r\n\tif (param instanceof BigInt) {\r\n\t\treturn param.toString(10);\r\n\t}\r\n\r\n\tif (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n\t\tconst paramClone = [...(param as Array<unknown>)];\r\n\t\treturn paramClone.map(p => formatParam(type.replace('[]', ''), p));\r\n\t}\r\n\r\n\t// Format correct width for u?int[0-9]*\r\n\tlet match = paramTypeNumber.exec(type);\r\n\tif (match) {\r\n\t\tconst size = parseInt(match[2] ?? '256', 10);\r\n\t\tif (size / 8 < (param as { length: number }).length) {\r\n\t\t\t// pad to correct bit width\r\n\t\t\treturn leftPad(param as string, size);\r\n\t\t}\r\n\t}\r\n\r\n\t// Format correct length for bytes[0-9]+\r\n\tmatch = paramTypeBytes.exec(type);\r\n\tif (match) {\r\n\t\tconst hexParam = param instanceof Uint8Array ? toHex(param) : param;\r\n\r\n\t\t// format to correct length\r\n\t\tconst size = parseInt(match[1], 10);\r\n\t\tif (size) {\r\n\t\t\tlet maxSize = size * 2;\r\n\r\n\t\t\tif ((param as string).startsWith('0x')) {\r\n\t\t\t\tmaxSize += 2;\r\n\t\t\t}\r\n\t\t\t// pad to correct length\r\n\t\t\tconst paddedParam =\r\n\t\t\t\t(hexParam as string).length < maxSize\r\n\t\t\t\t\t? rightPad(param as string, size * 2)\r\n\t\t\t\t\t: hexParam;\r\n\t\t\treturn formatOddHexstrings(paddedParam as string);\r\n\t\t}\r\n\r\n\t\treturn formatOddHexstrings(hexParam as string);\r\n\t}\r\n\treturn param;\r\n};\r\n\r\n// eslint-disable-next-line consistent-return\r\nexport const modifyParams = (\r\n\tcoder: ReturnType<AbiCoder['_getCoder']>,\r\n\tparam: unknown[],\r\n\t// eslint-disable-next-line consistent-return\r\n): unknown => {\r\n\tif (coder.name === 'array') {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n\t\treturn param.map(p =>\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n\t\t\tmodifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), [\r\n\t\t\t\tp,\r\n\t\t\t]),\r\n\t\t);\r\n\t}\r\n\r\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any\r\n\t(coder as any).coders.forEach((c: ReturnType<AbiCoder['_getCoder']>, i: number) => {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n\t\tif (c.name === 'tuple') {\r\n\t\t\tmodifyParams(c, [param[i]]);\r\n\t\t} else {\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, no-param-reassign\r\n\t\t\tparam[i] = formatParam(c.name, param[i]);\r\n\t\t}\r\n\t});\r\n\treturn [];\r\n};\r\n\r\n/**\r\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\r\n */\r\n\r\nexport const flattenTypes = (\r\n\tincludeTuple: boolean,\r\n\tputs: ReadonlyArray<AbiParameter>,\r\n): string[] => {\r\n\tconst types: string[] = [];\r\n\r\n\tputs.forEach(param => {\r\n\t\tif (typeof param.components === 'object') {\r\n\t\t\tif (!param.type.startsWith('tuple')) {\r\n\t\t\t\tthrow new AbiError(\r\n\t\t\t\t\t`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tconst arrayBracket = param.type.indexOf('[');\r\n\t\t\tconst suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\r\n\t\t\tconst result = flattenTypes(includeTuple, param.components);\r\n\r\n\t\t\tif (Array.isArray(result) && includeTuple) {\r\n\t\t\t\ttypes.push(`tuple(${result.join(',')})${suffix}`);\r\n\t\t\t} else if (!includeTuple) {\r\n\t\t\t\ttypes.push(`(${result.join(',')})${suffix}`);\r\n\t\t\t} else {\r\n\t\t\t\ttypes.push(`(${result.join()})`);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypes.push(param.type);\r\n\t\t}\r\n\t});\r\n\r\n\treturn types;\r\n};\r\n\r\n/**\r\n * Should be used to create full function/event name from json abi\r\n * returns a string\r\n */\r\nexport const jsonInterfaceMethodToString = (json: AbiFragment): string => {\r\n\tif (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\r\n\t\tif (json.name?.includes('(')) {\r\n\t\t\treturn json.name;\r\n\t\t}\r\n\r\n\t\treturn `${json.name ?? ''}(${flattenTypes(false, json.inputs ?? []).join(',')})`;\r\n\t}\r\n\r\n\t// Constructor fragment\r\n\treturn `(${flattenTypes(false, json.inputs ?? []).join(',')})`;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ContractExecutionError, InvalidResponseError, ProviderError, ResponseError, rpcErrorsMap, RpcError } from 'web3-errors';\nimport HttpProvider from 'web3-providers-http';\nimport WSProvider from 'web3-providers-ws';\nimport { isNullish, isPromise, jsonRpc, isResponseRpcError } from 'web3-utils';\nimport { isEIP1193Provider, isLegacyRequestProvider, isLegacySendAsyncProvider, isLegacySendProvider, isWeb3Provider } from './utils.js';\nimport { Web3EventEmitter } from './web3_event_emitter.js';\nexport var Web3RequestManagerEvent;\n(function (Web3RequestManagerEvent) {\n  Web3RequestManagerEvent[\"PROVIDER_CHANGED\"] = \"PROVIDER_CHANGED\";\n  Web3RequestManagerEvent[\"BEFORE_PROVIDER_CHANGE\"] = \"BEFORE_PROVIDER_CHANGE\";\n})(Web3RequestManagerEvent || (Web3RequestManagerEvent = {}));\nconst availableProviders = {\n  HttpProvider: HttpProvider,\n  WebsocketProvider: WSProvider\n};\nexport class Web3RequestManager extends Web3EventEmitter {\n  constructor(provider, useRpcCallSpecification) {\n    super();\n    if (!isNullish(provider)) {\n      this.setProvider(provider);\n    }\n    this.useRpcCallSpecification = useRpcCallSpecification;\n  }\n  /**\r\n   * Will return all available providers\r\n   */\n  static get providers() {\n    return availableProviders;\n  }\n  /**\r\n   * Will return the current provider.\r\n   *\r\n   * @returns Returns the current provider\r\n   */\n  get provider() {\n    return this._provider;\n  }\n  /**\r\n   * Will return all available providers\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get providers() {\n    return availableProviders;\n  }\n  /**\r\n   * Use to set provider. Provider can be a provider instance or a string.\r\n   *\r\n   * @param provider - The provider to set\r\n   */\n  setProvider(provider) {\n    let newProvider;\n    // autodetect provider\n    if (provider && typeof provider === 'string' && this.providers) {\n      // HTTP\n      if (/^http(s)?:\\/\\//i.test(provider)) {\n        newProvider = new this.providers.HttpProvider(provider);\n        // WS\n      } else if (/^ws(s)?:\\/\\//i.test(provider)) {\n        newProvider = new this.providers.WebsocketProvider(provider);\n      } else {\n        throw new ProviderError(`Can't autodetect provider for \"${provider}\"`);\n      }\n    } else if (isNullish(provider)) {\n      // In case want to unset the provider\n      newProvider = undefined;\n    } else {\n      newProvider = provider;\n    }\n    this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\n    this._provider = newProvider;\n    this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\n    return true;\n  }\n  /**\r\n   *\r\n   * Will execute a request\r\n   *\r\n   * @param request - {@link Web3APIRequest} The request to send\r\n   *\r\n   * @returns The response of the request {@link ResponseType}. If there is error\r\n   * in the response, will throw an error\r\n   */\n  send(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this._sendRequest(request);\n      if (jsonRpc.isResponseWithResult(response)) {\n        return response.result;\n      }\n      throw new ResponseError(response);\n    });\n  }\n  /**\r\n   * Same as send, but, will execute a batch of requests\r\n   *\r\n   * @param request {@link JsonRpcBatchRequest} The batch request to send\r\n   */\n  sendBatch(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this._sendRequest(request);\n      return response;\n    });\n  }\n  _sendRequest(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        provider\n      } = this;\n      if (isNullish(provider)) {\n        throw new ProviderError('Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.');\n      }\n      const payload = jsonRpc.isBatchRequest(request) ? jsonRpc.toBatchPayload(request) : jsonRpc.toPayload(request);\n      if (isWeb3Provider(provider)) {\n        let response;\n        try {\n          response = yield provider.request(payload);\n        } catch (error) {\n          // Check if the provider throw an error instead of reject with error\n          response = error;\n        }\n        return this._processJsonRpcResponse(payload, response, {\n          legacy: false,\n          error: false\n        });\n      }\n      if (isEIP1193Provider(provider)) {\n        return provider.request(payload).then(res => this._processJsonRpcResponse(payload, res, {\n          legacy: true,\n          error: false\n        })).catch(error => this._processJsonRpcResponse(payload, error, {\n          legacy: true,\n          error: true\n        }));\n      }\n      // TODO: This could be deprecated and removed.\n      if (isLegacyRequestProvider(provider)) {\n        return new Promise((resolve, reject) => {\n          const rejectWithError = err => reject(this._processJsonRpcResponse(payload, err, {\n            legacy: true,\n            error: true\n          }));\n          const resolveWithResponse = response => resolve(this._processJsonRpcResponse(payload, response, {\n            legacy: true,\n            error: false\n          }));\n          const result = provider.request(payload,\n          // a callback that is expected to be called after getting the response:\n          (err, response) => {\n            if (err) {\n              return rejectWithError(err);\n            }\n            return resolveWithResponse(response);\n          });\n          // Some providers, that follow a previous drafted version of EIP1193, has a `request` function\n          //\tthat is not defined as `async`, but it returns a promise.\n          // Such providers would not be picked with if(isEIP1193Provider(provider)) above\n          //\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\n          // Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\n          // So check if the returned result is a Promise, and resolve with it accordingly.\n          // Note: in this case we expect the callback provided above to never be called.\n          if (isPromise(result)) {\n            const responsePromise = result;\n            responsePromise.then(resolveWithResponse).catch(rejectWithError);\n          }\n        });\n      }\n      // TODO: This could be deprecated and removed.\n      if (isLegacySendProvider(provider)) {\n        return new Promise((resolve, reject) => {\n          provider.send(payload, (err, response) => {\n            if (err) {\n              return reject(this._processJsonRpcResponse(payload, err, {\n                legacy: true,\n                error: true\n              }));\n            }\n            if (isNullish(response)) {\n              throw new ResponseError('', 'Got a \"nullish\" response from provider.');\n            }\n            return resolve(this._processJsonRpcResponse(payload, response, {\n              legacy: true,\n              error: false\n            }));\n          });\n        });\n      }\n      // TODO: This could be deprecated and removed.\n      if (isLegacySendAsyncProvider(provider)) {\n        return provider.sendAsync(payload).then(response => this._processJsonRpcResponse(payload, response, {\n          legacy: true,\n          error: false\n        })).catch(error => this._processJsonRpcResponse(payload, error, {\n          legacy: true,\n          error: true\n        }));\n      }\n      throw new ProviderError('Provider does not have a request or send method to use.');\n    });\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _processJsonRpcResponse(payload, response, _ref) {\n    let {\n      legacy,\n      error\n    } = _ref;\n    if (isNullish(response)) {\n      return this._buildResponse(payload,\n      // Some providers uses \"null\" as valid empty response\n      // eslint-disable-next-line no-null/no-null\n      null, error);\n    }\n    // This is the majority of the cases so check these first\n    // A valid JSON-RPC response with error object\n    if (jsonRpc.isResponseWithError(response)) {\n      // check if its an rpc error\n      if (this.useRpcCallSpecification && isResponseRpcError(response)) {\n        const rpcErrorResponse = response;\n        // check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\n        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;\n          throw new Err(rpcErrorResponse);\n        } else {\n          throw new RpcError(rpcErrorResponse);\n        }\n      } else if (!Web3RequestManager._isReverted(response)) {\n        throw new InvalidResponseError(response, payload);\n      }\n    }\n    // This is the majority of the cases so check these first\n    // A valid JSON-RPC response with result object\n    if (jsonRpc.isResponseWithResult(response)) {\n      return response;\n    }\n    if (response instanceof Error) {\n      Web3RequestManager._isReverted(response);\n      throw response;\n    }\n    if (!legacy && jsonRpc.isBatchRequest(payload) && jsonRpc.isBatchResponse(response)) {\n      return response;\n    }\n    if (legacy && !error && jsonRpc.isBatchRequest(payload)) {\n      return response;\n    }\n    if (legacy && error && jsonRpc.isBatchRequest(payload)) {\n      // In case of error batch response we don't want to throw Invalid response\n      throw response;\n    }\n    if (legacy && !jsonRpc.isResponseWithError(response) && !jsonRpc.isResponseWithResult(response)) {\n      return this._buildResponse(payload, response, error);\n    }\n    if (jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\n      throw new ResponseError(response, 'Got normal response for a batch request.');\n    }\n    if (!jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\n      throw new ResponseError(response, 'Got batch response for a normal request.');\n    }\n    if ((jsonRpc.isResponseWithError(response) || jsonRpc.isResponseWithResult(response)) && !jsonRpc.isBatchRequest(payload)) {\n      if (response.id && payload.id !== response.id) {\n        throw new InvalidResponseError(response);\n      }\n    }\n    throw new ResponseError(response, 'Invalid response');\n  }\n  static _isReverted(response) {\n    let error;\n    if (jsonRpc.isResponseWithError(response)) {\n      error = response.error;\n    } else if (response instanceof Error) {\n      error = response;\n    }\n    // This message means that there was an error while executing the code of the smart contract\n    // However, more processing will happen at a higher level to decode the error data,\n    //\taccording to the Error ABI, if it was available as of EIP-838.\n    if (error === null || error === void 0 ? void 0 : error.message.includes('revert')) throw new ContractExecutionError(error);\n    return false;\n  }\n  // Need to use same types as _processJsonRpcResponse so have to declare as instance method\n  // eslint-disable-next-line class-methods-use-this\n  _buildResponse(payload, response, error) {\n    const res = {\n      jsonrpc: '2.0',\n      // eslint-disable-next-line no-nested-ternary\n      id: jsonRpc.isBatchRequest(payload) ? payload[0].id : 'id' in payload ? payload.id :\n      // Have to use the null here explicitly\n      // eslint-disable-next-line no-null/no-null\n      null\n    };\n    if (error) {\n      return Object.assign(Object.assign({}, res), {\n        error: response\n      });\n    }\n    return Object.assign(Object.assign({}, res), {\n      result: response\n    });\n  }\n}","map":{"version":3,"names":["ContractExecutionError","InvalidResponseError","ProviderError","ResponseError","rpcErrorsMap","RpcError","HttpProvider","WSProvider","isNullish","isPromise","jsonRpc","isResponseRpcError","isEIP1193Provider","isLegacyRequestProvider","isLegacySendAsyncProvider","isLegacySendProvider","isWeb3Provider","Web3EventEmitter","Web3RequestManagerEvent","availableProviders","WebsocketProvider","Web3RequestManager","constructor","provider","useRpcCallSpecification","setProvider","providers","_provider","newProvider","test","undefined","emit","BEFORE_PROVIDER_CHANGE","PROVIDER_CHANGED","send","request","response","_sendRequest","isResponseWithResult","result","sendBatch","payload","isBatchRequest","toBatchPayload","toPayload","error","_processJsonRpcResponse","legacy","then","res","catch","Promise","resolve","reject","rejectWithError","err","resolveWithResponse","responsePromise","sendAsync","_ref","_buildResponse","isResponseWithError","rpcErrorResponse","get","code","Err","_isReverted","Error","isBatchResponse","Array","isArray","id","message","includes","jsonrpc","Object","assign"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-core\\src\\web3_request_manager.ts"],"sourcesContent":["﻿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport {\r\n\tContractExecutionError,\r\n\tInvalidResponseError,\r\n\tProviderError,\r\n\tResponseError,\r\n\trpcErrorsMap,\r\n\tRpcError,\r\n} from 'web3-errors';\r\nimport HttpProvider from 'web3-providers-http';\r\nimport WSProvider from 'web3-providers-ws';\r\nimport {\r\n\tEthExecutionAPI,\r\n\tJsonRpcBatchRequest,\r\n\tJsonRpcBatchResponse,\r\n\tJsonRpcPayload,\r\n\tJsonRpcResponse,\r\n\tJsonRpcError,\r\n\tJsonRpcResponseWithResult,\r\n\tJsonRpcResponseWithError,\r\n\tSupportedProviders,\r\n\tWeb3APIMethod,\r\n\tWeb3APIPayload,\r\n\tWeb3APIRequest,\r\n\tWeb3APIReturnType,\r\n\tWeb3APISpec,\r\n\tWeb3BaseProvider,\r\n\tWeb3BaseProviderConstructor,\r\n} from 'web3-types';\r\nimport { isNullish, isPromise, jsonRpc, isResponseRpcError } from 'web3-utils';\r\nimport {\r\n\tisEIP1193Provider,\r\n\tisLegacyRequestProvider,\r\n\tisLegacySendAsyncProvider,\r\n\tisLegacySendProvider,\r\n\tisWeb3Provider,\r\n} from './utils.js';\r\nimport { Web3EventEmitter } from './web3_event_emitter.js';\r\n\r\nexport enum Web3RequestManagerEvent {\r\n\tPROVIDER_CHANGED = 'PROVIDER_CHANGED',\r\n\tBEFORE_PROVIDER_CHANGE = 'BEFORE_PROVIDER_CHANGE',\r\n}\r\n\r\nconst availableProviders: {\r\n\tHttpProvider: Web3BaseProviderConstructor;\r\n\tWebsocketProvider: Web3BaseProviderConstructor;\r\n} = {\r\n\tHttpProvider: HttpProvider as Web3BaseProviderConstructor,\r\n\tWebsocketProvider: WSProvider as Web3BaseProviderConstructor,\r\n};\r\n\r\nexport class Web3RequestManager<\r\n\tAPI extends Web3APISpec = EthExecutionAPI,\r\n> extends Web3EventEmitter<{\r\n\t[key in Web3RequestManagerEvent]: SupportedProviders<API> | undefined;\r\n}> {\r\n\tprivate _provider?: SupportedProviders<API>;\r\n\tprivate readonly useRpcCallSpecification?: boolean;\r\n\tpublic constructor(\r\n\t\tprovider?: SupportedProviders<API> | string,\r\n\t\tuseRpcCallSpecification?: boolean,\r\n\t) {\r\n\t\tsuper();\r\n\r\n\t\tif (!isNullish(provider)) {\r\n\t\t\tthis.setProvider(provider);\r\n\t\t}\r\n\t\tthis.useRpcCallSpecification = useRpcCallSpecification;\r\n\t}\r\n\r\n\t/**\r\n\t * Will return all available providers\r\n\t */\r\n\tpublic static get providers() {\r\n\t\treturn availableProviders;\r\n\t}\r\n\r\n\t/**\r\n\t * Will return the current provider.\r\n\t *\r\n\t * @returns Returns the current provider\r\n\t */\r\n\tpublic get provider() {\r\n\t\treturn this._provider;\r\n\t}\r\n\r\n\t/**\r\n\t * Will return all available providers\r\n\t */\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tpublic get providers() {\r\n\t\treturn availableProviders;\r\n\t}\r\n\r\n\t/**\r\n\t * Use to set provider. Provider can be a provider instance or a string.\r\n\t *\r\n\t * @param provider - The provider to set\r\n\t */\r\n\tpublic setProvider(provider?: SupportedProviders<API> | string): boolean {\r\n\t\tlet newProvider: SupportedProviders<API> | undefined;\r\n\r\n\t\t// autodetect provider\r\n\t\tif (provider && typeof provider === 'string' && this.providers) {\r\n\t\t\t// HTTP\r\n\t\t\tif (/^http(s)?:\\/\\//i.test(provider)) {\r\n\t\t\t\tnewProvider = new this.providers.HttpProvider<API>(provider);\r\n\r\n\t\t\t\t// WS\r\n\t\t\t} else if (/^ws(s)?:\\/\\//i.test(provider)) {\r\n\t\t\t\tnewProvider = new this.providers.WebsocketProvider<API>(provider);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new ProviderError(`Can't autodetect provider for \"${provider}\"`);\r\n\t\t\t}\r\n\t\t} else if (isNullish(provider)) {\r\n\t\t\t// In case want to unset the provider\r\n\t\t\tnewProvider = undefined;\r\n\t\t} else {\r\n\t\t\tnewProvider = provider as SupportedProviders<API>;\r\n\t\t}\r\n\r\n\t\tthis.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\r\n\t\tthis._provider = newProvider;\r\n\t\tthis.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * Will execute a request\r\n\t *\r\n\t * @param request - {@link Web3APIRequest} The request to send\r\n\t *\r\n\t * @returns The response of the request {@link ResponseType}. If there is error\r\n\t * in the response, will throw an error\r\n\t */\r\n\tpublic async send<\r\n\t\tMethod extends Web3APIMethod<API>,\r\n\t\tResponseType = Web3APIReturnType<API, Method>,\r\n\t>(request: Web3APIRequest<API, Method>): Promise<ResponseType> {\r\n\t\tconst response = await this._sendRequest<Method, ResponseType>(request);\r\n\r\n\t\tif (jsonRpc.isResponseWithResult(response)) {\r\n\t\t\treturn response.result;\r\n\t\t}\r\n\r\n\t\tthrow new ResponseError(response);\r\n\t}\r\n\r\n\t/**\r\n\t * Same as send, but, will execute a batch of requests\r\n\t *\r\n\t * @param request {@link JsonRpcBatchRequest} The batch request to send\r\n\t */\r\n\tpublic async sendBatch(request: JsonRpcBatchRequest): Promise<JsonRpcBatchResponse<unknown>> {\r\n\t\tconst response = await this._sendRequest<never, never>(request);\r\n\r\n\t\treturn response as JsonRpcBatchResponse<unknown>;\r\n\t}\r\n\r\n\tprivate async _sendRequest<\r\n\t\tMethod extends Web3APIMethod<API>,\r\n\t\tResponseType = Web3APIReturnType<API, Method>,\r\n\t>(\r\n\t\trequest: Web3APIRequest<API, Method> | JsonRpcBatchRequest,\r\n\t): Promise<JsonRpcResponse<ResponseType>> {\r\n\t\tconst { provider } = this;\r\n\r\n\t\tif (isNullish(provider)) {\r\n\t\t\tthrow new ProviderError(\r\n\t\t\t\t'Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.',\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst payload = jsonRpc.isBatchRequest(request)\r\n\t\t\t? jsonRpc.toBatchPayload(request)\r\n\t\t\t: jsonRpc.toPayload(request);\r\n\r\n\t\tif (isWeb3Provider(provider)) {\r\n\t\t\tlet response;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tresponse = await provider.request<Method, ResponseType>(\r\n\t\t\t\t\tpayload as Web3APIPayload<API, Method>,\r\n\t\t\t\t);\r\n\t\t\t} catch (error) {\r\n\t\t\t\t// Check if the provider throw an error instead of reject with error\r\n\t\t\t\tresponse = error as JsonRpcResponse<ResponseType>;\r\n\t\t\t}\r\n\t\t\treturn this._processJsonRpcResponse(payload, response, { legacy: false, error: false });\r\n\t\t}\r\n\r\n\t\tif (isEIP1193Provider(provider)) {\r\n\t\t\treturn (provider as Web3BaseProvider<API>)\r\n\t\t\t\t.request<Method, ResponseType>(payload as Web3APIPayload<API, Method>)\r\n\t\t\t\t.then(\r\n\t\t\t\t\tres =>\r\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, res, {\r\n\t\t\t\t\t\t\tlegacy: true,\r\n\t\t\t\t\t\t\terror: false,\r\n\t\t\t\t\t\t}) as JsonRpcResponseWithResult<ResponseType>,\r\n\t\t\t\t)\r\n\t\t\t\t.catch(error =>\r\n\t\t\t\t\tthis._processJsonRpcResponse(\r\n\t\t\t\t\t\tpayload,\r\n\t\t\t\t\t\terror as JsonRpcResponse<ResponseType, unknown>,\r\n\t\t\t\t\t\t{ legacy: true, error: true },\r\n\t\t\t\t\t),\r\n\t\t\t\t);\r\n\t\t}\r\n\r\n\t\t// TODO: This could be deprecated and removed.\r\n\t\tif (isLegacyRequestProvider(provider)) {\r\n\t\t\treturn new Promise<JsonRpcResponse<ResponseType>>((resolve, reject) => {\r\n\t\t\t\tconst rejectWithError = (err: unknown) =>\r\n\t\t\t\t\treject(\r\n\t\t\t\t\t\tthis._processJsonRpcResponse(\r\n\t\t\t\t\t\t\tpayload,\r\n\t\t\t\t\t\t\terr as JsonRpcResponse<ResponseType>,\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlegacy: true,\r\n\t\t\t\t\t\t\t\terror: true,\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t);\r\n\t\t\t\tconst resolveWithResponse = (response: JsonRpcResponse<ResponseType>) =>\r\n\t\t\t\t\tresolve(\r\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, response, {\r\n\t\t\t\t\t\t\tlegacy: true,\r\n\t\t\t\t\t\t\terror: false,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t);\r\n\t\t\t\tconst result = provider.request<ResponseType>(\r\n\t\t\t\t\tpayload,\r\n\t\t\t\t\t// a callback that is expected to be called after getting the response:\r\n\t\t\t\t\t(err, response) => {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\treturn rejectWithError(err);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn resolveWithResponse(response);\r\n\t\t\t\t\t},\r\n\t\t\t\t);\r\n\t\t\t\t// Some providers, that follow a previous drafted version of EIP1193, has a `request` function\r\n\t\t\t\t//\tthat is not defined as `async`, but it returns a promise.\r\n\t\t\t\t// Such providers would not be picked with if(isEIP1193Provider(provider)) above\r\n\t\t\t\t//\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\r\n\t\t\t\t// Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\r\n\t\t\t\t// So check if the returned result is a Promise, and resolve with it accordingly.\r\n\t\t\t\t// Note: in this case we expect the callback provided above to never be called.\r\n\t\t\t\tif (isPromise(result)) {\r\n\t\t\t\t\tconst responsePromise = result as unknown as Promise<\r\n\t\t\t\t\t\tJsonRpcResponse<ResponseType>\r\n\t\t\t\t\t>;\r\n\t\t\t\t\tresponsePromise.then(resolveWithResponse).catch(rejectWithError);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// TODO: This could be deprecated and removed.\r\n\t\tif (isLegacySendProvider(provider)) {\r\n\t\t\treturn new Promise<JsonRpcResponse<ResponseType>>((resolve, reject): void => {\r\n\t\t\t\tprovider.send<ResponseType>(payload, (err, response) => {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\treturn reject(\r\n\t\t\t\t\t\t\tthis._processJsonRpcResponse(\r\n\t\t\t\t\t\t\t\tpayload,\r\n\t\t\t\t\t\t\t\terr as unknown as JsonRpcResponse<ResponseType>,\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tlegacy: true,\r\n\t\t\t\t\t\t\t\t\terror: true,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isNullish(response)) {\r\n\t\t\t\t\t\tthrow new ResponseError(\r\n\t\t\t\t\t\t\t'' as never,\r\n\t\t\t\t\t\t\t'Got a \"nullish\" response from provider.',\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn resolve(\r\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, response, {\r\n\t\t\t\t\t\t\tlegacy: true,\r\n\t\t\t\t\t\t\terror: false,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// TODO: This could be deprecated and removed.\r\n\t\tif (isLegacySendAsyncProvider(provider)) {\r\n\t\t\treturn provider\r\n\t\t\t\t.sendAsync<ResponseType>(payload)\r\n\t\t\t\t.then(response =>\r\n\t\t\t\t\tthis._processJsonRpcResponse(payload, response, { legacy: true, error: false }),\r\n\t\t\t\t)\r\n\t\t\t\t.catch(error =>\r\n\t\t\t\t\tthis._processJsonRpcResponse(payload, error as JsonRpcResponse<ResponseType>, {\r\n\t\t\t\t\t\tlegacy: true,\r\n\t\t\t\t\t\terror: true,\r\n\t\t\t\t\t}),\r\n\t\t\t\t);\r\n\t\t}\r\n\r\n\t\tthrow new ProviderError('Provider does not have a request or send method to use.');\r\n\t}\r\n\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tprivate _processJsonRpcResponse<ResultType, ErrorType, RequestType>(\r\n\t\tpayload: JsonRpcPayload<RequestType>,\r\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\r\n\t\t{ legacy, error }: { legacy: boolean; error: boolean },\r\n\t): JsonRpcResponse<ResultType> | never {\r\n\t\tif (isNullish(response)) {\r\n\t\t\treturn this._buildResponse(\r\n\t\t\t\tpayload,\r\n\t\t\t\t// Some providers uses \"null\" as valid empty response\r\n\t\t\t\t// eslint-disable-next-line no-null/no-null\r\n\t\t\t\tnull as unknown as JsonRpcResponse<ResultType, ErrorType>,\r\n\t\t\t\terror,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// This is the majority of the cases so check these first\r\n\t\t// A valid JSON-RPC response with error object\r\n\t\tif (jsonRpc.isResponseWithError<ErrorType>(response)) {\r\n\t\t\t// check if its an rpc error\r\n\t\t\tif (\r\n\t\t\t\tthis.useRpcCallSpecification &&\r\n\t\t\t\tisResponseRpcError(response as JsonRpcResponseWithError)\r\n\t\t\t) {\r\n\t\t\t\tconst rpcErrorResponse = response as JsonRpcResponseWithError;\r\n\t\t\t\t// check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\r\n\t\t\t\tif (rpcErrorsMap.get(rpcErrorResponse.error.code)) {\r\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n\t\t\t\t\tconst Err = rpcErrorsMap.get(rpcErrorResponse.error.code)!.error;\r\n\t\t\t\t\tthrow new Err(rpcErrorResponse);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new RpcError(rpcErrorResponse);\r\n\t\t\t\t}\r\n\t\t\t} else if (!Web3RequestManager._isReverted(response)) {\r\n\t\t\t\tthrow new InvalidResponseError<ErrorType, RequestType>(response, payload);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// This is the majority of the cases so check these first\r\n\t\t// A valid JSON-RPC response with result object\r\n\t\tif (jsonRpc.isResponseWithResult<ResultType>(response)) {\r\n\t\t\treturn response;\r\n\t\t}\r\n\r\n\t\tif ((response as unknown) instanceof Error) {\r\n\t\t\tWeb3RequestManager._isReverted(response);\r\n\t\t\tthrow response;\r\n\t\t}\r\n\r\n\t\tif (!legacy && jsonRpc.isBatchRequest(payload) && jsonRpc.isBatchResponse(response)) {\r\n\t\t\treturn response as JsonRpcBatchResponse<ResultType>;\r\n\t\t}\r\n\r\n\t\tif (legacy && !error && jsonRpc.isBatchRequest(payload)) {\r\n\t\t\treturn response as JsonRpcBatchResponse<ResultType>;\r\n\t\t}\r\n\r\n\t\tif (legacy && error && jsonRpc.isBatchRequest(payload)) {\r\n\t\t\t// In case of error batch response we don't want to throw Invalid response\r\n\t\t\tthrow response;\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tlegacy &&\r\n\t\t\t!jsonRpc.isResponseWithError(response) &&\r\n\t\t\t!jsonRpc.isResponseWithResult(response)\r\n\t\t) {\r\n\t\t\treturn this._buildResponse(payload, response, error);\r\n\t\t}\r\n\r\n\t\tif (jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\r\n\t\t\tthrow new ResponseError(response, 'Got normal response for a batch request.');\r\n\t\t}\r\n\r\n\t\tif (!jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\r\n\t\t\tthrow new ResponseError(response, 'Got batch response for a normal request.');\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\t(jsonRpc.isResponseWithError(response) || jsonRpc.isResponseWithResult(response)) &&\r\n\t\t\t!jsonRpc.isBatchRequest(payload)\r\n\t\t) {\r\n\t\t\tif (response.id && payload.id !== response.id) {\r\n\t\t\t\tthrow new InvalidResponseError<ErrorType>(response);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow new ResponseError(response, 'Invalid response');\r\n\t}\r\n\r\n\tprivate static _isReverted<ResultType, ErrorType>(\r\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\r\n\t): boolean {\r\n\t\tlet error: JsonRpcError | undefined;\r\n\r\n\t\tif (jsonRpc.isResponseWithError<ErrorType>(response)) {\r\n\t\t\terror = (response as JsonRpcResponseWithError).error;\r\n\t\t} else if ((response as unknown) instanceof Error) {\r\n\t\t\terror = response as unknown as JsonRpcError;\r\n\t\t}\r\n\r\n\t\t// This message means that there was an error while executing the code of the smart contract\r\n\t\t// However, more processing will happen at a higher level to decode the error data,\r\n\t\t//\taccording to the Error ABI, if it was available as of EIP-838.\r\n\t\tif (error?.message.includes('revert')) throw new ContractExecutionError(error);\r\n\r\n\t\treturn false;\r\n\t}\r\n\t// Need to use same types as _processJsonRpcResponse so have to declare as instance method\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tprivate _buildResponse<ResultType, ErrorType, RequestType>(\r\n\t\tpayload: JsonRpcPayload<RequestType>,\r\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\r\n\t\terror: boolean,\r\n\t): JsonRpcResponse<ResultType> {\r\n\t\tconst res = {\r\n\t\t\tjsonrpc: '2.0',\r\n\t\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\t\tid: jsonRpc.isBatchRequest(payload)\r\n\t\t\t\t? payload[0].id\r\n\t\t\t\t: 'id' in payload\r\n\t\t\t\t? payload.id\r\n\t\t\t\t: // Have to use the null here explicitly\r\n\t\t\t\t  // eslint-disable-next-line no-null/no-null\r\n\t\t\t\t  null,\r\n\t\t};\r\n\r\n\t\tif (error) {\r\n\t\t\treturn {\r\n\t\t\t\t...res,\r\n\t\t\t\terror: response as unknown,\r\n\t\t\t} as JsonRpcResponse<ResultType>;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\t...res,\r\n\t\t\tresult: response as unknown,\r\n\t\t} as JsonRpcResponse<ResultType>;\r\n\t}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
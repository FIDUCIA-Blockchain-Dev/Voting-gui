{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { rejectIfConditionAtInterval } from 'web3-utils';\nimport { TransactionBlockTimeoutError } from 'web3-errors';\nimport { NUMBER_DATA_FORMAT } from '../constants.js';\n// eslint-disable-next-line import/no-cycle\nimport { getBlockNumber } from '../rpc_method_wrappers.js';\nfunction resolveByPolling(web3Context, starterBlockNumber, transactionHash) {\n  const pollingInterval = web3Context.transactionPollingInterval;\n  const [intervalId, promiseToError] = rejectIfConditionAtInterval(() => __awaiter(this, void 0, void 0, function* () {\n    let lastBlockNumber;\n    try {\n      lastBlockNumber = yield getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n    } catch (error) {\n      console.warn('An error happen while trying to get the block number', error);\n      return undefined;\n    }\n    const numberOfBlocks = lastBlockNumber - starterBlockNumber;\n    if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n      return new TransactionBlockTimeoutError({\n        starterBlockNumber,\n        numberOfBlocks,\n        transactionHash\n      });\n    }\n    return undefined;\n  }), pollingInterval);\n  const clean = () => {\n    clearInterval(intervalId);\n  };\n  return [promiseToError, {\n    clean\n  }];\n}\nfunction resolveBySubscription(web3Context, starterBlockNumber, transactionHash) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    // The following variable will stay true except if the data arrived,\n    //\tor if watching started after an error had occurred.\n    let needToWatchLater = true;\n    let subscription;\n    let resourceCleaner;\n    // internal helper function\n    function revertToPolling(reject, previousError) {\n      if (previousError) {\n        console.warn('error happened at subscription. So revert to polling...', previousError);\n      }\n      resourceCleaner.clean();\n      needToWatchLater = false;\n      const [promiseToError, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n      resourceCleaner.clean = newResourceCleaner.clean;\n      promiseToError.catch(error => reject(error));\n    }\n    try {\n      subscription = yield (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.subscribe('newHeads');\n      resourceCleaner = {\n        clean: () => {\n          var _a;\n          // Remove the subscription, if it was not removed somewhere\n          // \telse by calling, for example, subscriptionManager.clear()\n          if (subscription.id) {\n            (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.removeSubscription(subscription).then(() => {\n              // Subscription ended successfully\n            }).catch(() => {\n              // An error happened while ending subscription. But no need to take any action.\n            });\n          }\n        }\n      };\n    } catch (error) {\n      return resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n    }\n    const promiseToError = new Promise((_, reject) => {\n      try {\n        subscription.on('data', lastBlockHeader => {\n          needToWatchLater = false;\n          if (!(lastBlockHeader === null || lastBlockHeader === void 0 ? void 0 : lastBlockHeader.number)) {\n            return;\n          }\n          const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));\n          if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n            // Transaction Block Timeout is known to be reached by subscribing to new heads\n            reject(new TransactionBlockTimeoutError({\n              starterBlockNumber,\n              numberOfBlocks,\n              transactionHash\n            }));\n          }\n        });\n        subscription.on('error', error => {\n          revertToPolling(reject, error);\n        });\n      } catch (error) {\n        revertToPolling(reject, error);\n      }\n      // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n      setTimeout(() => {\n        if (needToWatchLater) {\n          revertToPolling(reject);\n        }\n      }, web3Context.blockHeaderTimeout * 1000);\n    });\n    return [promiseToError, resourceCleaner];\n  });\n}\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\r\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout.\r\n*/\nexport function rejectIfBlockTimeout(web3Context, transactionHash) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      provider\n    } = web3Context.requestManager;\n    let callingRes;\n    const starterBlockNumber = yield getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n    // TODO: once https://github.com/web3/web3.js/issues/5521 is implemented, remove checking for `enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout`\n    if (((_b = (_a = provider).supportsSubscriptions) === null || _b === void 0 ? void 0 : _b.call(_a)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {\n      callingRes = yield resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\n    } else {\n      callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n    }\n    return callingRes;\n  });\n}","map":{"version":3,"names":["rejectIfConditionAtInterval","TransactionBlockTimeoutError","NUMBER_DATA_FORMAT","getBlockNumber","resolveByPolling","web3Context","starterBlockNumber","transactionHash","pollingInterval","transactionPollingInterval","intervalId","promiseToError","__awaiter","lastBlockNumber","error","console","warn","undefined","numberOfBlocks","transactionBlockTimeout","clean","clearInterval","resolveBySubscription","needToWatchLater","subscription","resourceCleaner","revertToPolling","reject","previousError","newResourceCleaner","catch","_a","subscriptionManager","subscribe","id","removeSubscription","then","Promise","_","on","lastBlockHeader","number","Number","BigInt","setTimeout","blockHeaderTimeout","rejectIfBlockTimeout","provider","requestManager","callingRes","_b","supportsSubscriptions","call","enableExperimentalFeatures","useSubscriptionWhenCheckingBlockTimeout"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-eth\\src\\utils\\reject_if_block_timeout.ts"],"sourcesContent":["/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\nimport { EthExecutionAPI, Bytes, Web3BaseProvider, BlockHeaderOutput } from 'web3-types';\r\nimport { Web3Context } from 'web3-core';\r\nimport { rejectIfConditionAtInterval } from 'web3-utils';\r\n\r\nimport { TransactionBlockTimeoutError } from 'web3-errors';\r\nimport { NUMBER_DATA_FORMAT } from '../constants.js';\r\n// eslint-disable-next-line import/no-cycle\r\nimport { getBlockNumber } from '../rpc_method_wrappers.js';\r\nimport { NewHeadsSubscription } from '../web3_subscriptions.js';\r\n\r\nexport interface ResourceCleaner {\r\n\tclean: () => void;\r\n}\r\n\r\nfunction resolveByPolling(\r\n\tweb3Context: Web3Context<EthExecutionAPI>,\r\n\tstarterBlockNumber: number,\r\n\ttransactionHash?: Bytes,\r\n): [Promise<never>, ResourceCleaner] {\r\n\tconst pollingInterval = web3Context.transactionPollingInterval;\r\n\tconst [intervalId, promiseToError]: [NodeJS.Timer, Promise<never>] =\r\n\t\trejectIfConditionAtInterval(async () => {\r\n\t\t\tlet lastBlockNumber;\r\n\t\t\ttry {\r\n\t\t\t\tlastBlockNumber = await getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.warn('An error happen while trying to get the block number', error);\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t\tconst numberOfBlocks = lastBlockNumber - starterBlockNumber;\r\n\t\t\tif (numberOfBlocks >= web3Context.transactionBlockTimeout) {\r\n\t\t\t\treturn new TransactionBlockTimeoutError({\r\n\t\t\t\t\tstarterBlockNumber,\r\n\t\t\t\t\tnumberOfBlocks,\r\n\t\t\t\t\ttransactionHash,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn undefined;\r\n\t\t}, pollingInterval);\r\n\r\n\tconst clean = () => {\r\n\t\tclearInterval(intervalId);\r\n\t};\r\n\r\n\treturn [promiseToError, { clean }];\r\n}\r\n\r\nasync function resolveBySubscription(\r\n\tweb3Context: Web3Context<EthExecutionAPI>,\r\n\tstarterBlockNumber: number,\r\n\ttransactionHash?: Bytes,\r\n): Promise<[Promise<never>, ResourceCleaner]> {\r\n\t// The following variable will stay true except if the data arrived,\r\n\t//\tor if watching started after an error had occurred.\r\n\tlet needToWatchLater = true;\r\n\r\n\tlet subscription: NewHeadsSubscription;\r\n\tlet resourceCleaner: ResourceCleaner;\r\n\t// internal helper function\r\n\tfunction revertToPolling(\r\n\t\treject: (value: Error | PromiseLike<Error>) => void,\r\n\t\tpreviousError?: Error,\r\n\t) {\r\n\t\tif (previousError) {\r\n\t\t\tconsole.warn('error happened at subscription. So revert to polling...', previousError);\r\n\t\t}\r\n\t\tresourceCleaner.clean();\r\n\r\n\t\tneedToWatchLater = false;\r\n\t\tconst [promiseToError, newResourceCleaner] = resolveByPolling(\r\n\t\t\tweb3Context,\r\n\t\t\tstarterBlockNumber,\r\n\t\t\ttransactionHash,\r\n\t\t);\r\n\t\tresourceCleaner.clean = newResourceCleaner.clean;\r\n\t\tpromiseToError.catch(error => reject(error as Error));\r\n\t}\r\n\ttry {\r\n\t\tsubscription = (await web3Context.subscriptionManager?.subscribe(\r\n\t\t\t'newHeads',\r\n\t\t)) as unknown as NewHeadsSubscription;\r\n\t\tresourceCleaner = {\r\n\t\t\tclean: () => {\r\n\t\t\t\t// Remove the subscription, if it was not removed somewhere\r\n\t\t\t\t// \telse by calling, for example, subscriptionManager.clear()\r\n\t\t\t\tif (subscription.id) {\r\n\t\t\t\t\tweb3Context.subscriptionManager\r\n\t\t\t\t\t\t?.removeSubscription(subscription)\r\n\t\t\t\t\t\t.then(() => {\r\n\t\t\t\t\t\t\t// Subscription ended successfully\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.catch(() => {\r\n\t\t\t\t\t\t\t// An error happened while ending subscription. But no need to take any action.\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t};\r\n\t} catch (error) {\r\n\t\treturn resolveByPolling(web3Context, starterBlockNumber, transactionHash);\r\n\t}\r\n\tconst promiseToError: Promise<never> = new Promise((_, reject) => {\r\n\t\ttry {\r\n\t\t\tsubscription.on('data', (lastBlockHeader: BlockHeaderOutput) => {\r\n\t\t\t\tneedToWatchLater = false;\r\n\t\t\t\tif (!lastBlockHeader?.number) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst numberOfBlocks = Number(\r\n\t\t\t\t\tBigInt(lastBlockHeader.number) - BigInt(starterBlockNumber),\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif (numberOfBlocks >= web3Context.transactionBlockTimeout) {\r\n\t\t\t\t\t// Transaction Block Timeout is known to be reached by subscribing to new heads\r\n\t\t\t\t\treject(\r\n\t\t\t\t\t\tnew TransactionBlockTimeoutError({\r\n\t\t\t\t\t\t\tstarterBlockNumber,\r\n\t\t\t\t\t\t\tnumberOfBlocks,\r\n\t\t\t\t\t\t\ttransactionHash,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tsubscription.on('error', error => {\r\n\t\t\t\trevertToPolling(reject, error);\r\n\t\t\t});\r\n\t\t} catch (error) {\r\n\t\t\trevertToPolling(reject, error as Error);\r\n\t\t}\r\n\r\n\t\t// Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\r\n\t\tsetTimeout(() => {\r\n\t\t\tif (needToWatchLater) {\r\n\t\t\t\trevertToPolling(reject);\r\n\t\t\t}\r\n\t\t}, web3Context.blockHeaderTimeout * 1000);\r\n\t});\r\n\r\n\treturn [promiseToError, resourceCleaner];\r\n}\r\n\r\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\r\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout. \r\n*/\r\nexport async function rejectIfBlockTimeout(\r\n\tweb3Context: Web3Context<EthExecutionAPI>,\r\n\ttransactionHash?: Bytes,\r\n): Promise<[Promise<never>, ResourceCleaner]> {\r\n\tconst { provider } = web3Context.requestManager;\r\n\tlet callingRes: [Promise<never>, ResourceCleaner];\r\n\tconst starterBlockNumber = await getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\r\n\t// TODO: once https://github.com/web3/web3.js/issues/5521 is implemented, remove checking for `enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout`\r\n\tif (\r\n\t\t(provider as Web3BaseProvider).supportsSubscriptions?.() &&\r\n\t\tweb3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout\r\n\t) {\r\n\t\tcallingRes = await resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\r\n\t} else {\r\n\t\tcallingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\r\n\t}\r\n\treturn callingRes;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
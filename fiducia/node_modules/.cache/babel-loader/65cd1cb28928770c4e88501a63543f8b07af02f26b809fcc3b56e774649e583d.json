{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Web3Context } from 'web3-core';\nimport * as rpcWrappers from './rpc_method_wrappers.js';\nexport class Personal extends Web3Context {\n  /**\r\n   *Returns a list of accounts the node controls by using the provider and calling the RPC method personal_listAccounts. Using `web3.eth.accounts.create()` will not add accounts into this list. For that use `web3.eth.personal.newAccount()`.\r\n   * @returns - An array of addresses controlled by the node.\r\n   * @example\r\n   * ```ts\r\n   *  const accounts = await personal.getAccounts();\r\n   * console.log(accounts);\r\n   * >\r\n   * [\r\n   * \t'0x79D7BbaC53C9aF700d0B250e9AE789E503Fcd6AE',\r\n   * \t'0xe2597eB05CF9a87eB1309e86750C903EC38E527e',\r\n   * \t'0x7eD0e85B8E1E925600B4373e6d108F34AB38a401',\r\n   * \t'0xE4bEEf667408b99053dC147Ed19592aDa0d77F59',\r\n   * \t'0x7AB80aeB6bb488B7f6c41c58e83Ef248eB39c882',\r\n   * \t'0x12B1D9d74d73b1C3A245B19C1C5501c653aF1af9',\r\n   * \t'0x1a6075A263Ee140e00Dbf8E374Fc5A443d097894',\r\n   * \t'0x4FEC0A51024B13030D26E70904B066C6d41157A5',\r\n   * \t'0x03095dc4857BB26f3a4550c5651Df8b7f6b6B1Ef',\r\n   * \t'0xac0B9b6e8A17991cb172B2ABAF45Fb5eb769E540'\r\n   * ]\r\n   * ```\r\n   */\n  getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.getAccounts(this.requestManager);\n    });\n  }\n  /**\r\n   * Creates a new account and returns its address.\r\n   * **_NOTE:_**  This function sends a sensitive information like password. Never call this function over a unsecured Websocket or HTTP provider, as your password will be sent in plain text!\r\n   * @param password - The password to encrypt the account with.\r\n   * @returns - The address of the new account.\r\n   * @example\r\n   * ```ts\r\n   * const addr = await web3.eth.personal.newAccount('password');\r\n   * console.log(addr);\r\n   * > '0x1234567891011121314151617181920212223456'\r\n   * ```\r\n   */\n  newAccount(password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.newAccount(this.requestManager, password);\n    });\n  }\n  /**\r\n   * Unlocks an account for a given duration.\r\n   * @param address - The address of the account to unlock.\r\n   * @param password - The password of the account to unlock.\r\n   * @param unlockDuration - The duration in seconds to unlock the account for.\r\n   * @example\r\n   * ```ts\r\n   * await personal.unlockAccount(\r\n   * \t\"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\",\r\n   * \t\"123456\",\r\n   * \t600\r\n   * );\r\n   * ```\r\n   */\n  unlockAccount(address, password, unlockDuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.unlockAccount(this.requestManager, address, password, unlockDuration);\n    });\n  }\n  /**\r\n   * Locks the given account\r\n   * @param address - The address of the account to lock.\r\n   * @returns - `true` if the account was locked, otherwise `false`.\r\n   * @example\r\n   * ```ts\r\n   * await personal.lockAccount(\r\n   * \t\"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\"\r\n   * );\r\n   */\n  lockAccount(address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.lockAccount(this.requestManager, address);\n    });\n  }\n  /**\r\n   * Imports the given private key into the key store, encrypting it with the passphrase.\r\n   * @param keyData - An unencrypted private key (hex string).\r\n   * @param passphrase  - The password of the account\r\n   * @returns - The address of the new account.\r\n   * @example\r\n   * ```ts\r\n   * const accountAddress = await personal.importRawKey(\r\n   * \t\"abe40cb08850da918ee951b237fa87946499b2d8643e4aa12b0610b050c731f6\",\r\n   * \t\"123456\"\r\n   * );\r\n   *\r\n   * console.log(unlockTx);\r\n   * > 0x8727a8b34ec833154b72b62cac05d69f86eb6556\r\n   * ```\r\n   */\n  importRawKey(keyData, passphrase) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.importRawKey(this.requestManager, keyData, passphrase);\n    });\n  }\n  /**\r\n   * This method sends a transaction over the management API.\r\n   * **_NOTE:_** Sending your account password over an unsecured HTTP RPC connection is highly unsecure.\r\n   * @param tx - The transaction options\r\n   * @param passphrase - The passphrase of the current account\r\n   * @returns - The transaction hash\r\n   * @example\r\n   * ```ts\r\n   * const txHash = personal\r\n   * .sendTransaction({\r\n   *  \tfrom: \"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\",\r\n   * \tgasPrice: \"20000000000\",\r\n   * \tgas: \"21000\",\r\n   * \tto: \"0x3535353535353535353535353535353535353535\",\r\n   * \tvalue: \"1000000\",\r\n   * \tdata: \"\",\r\n   * \tnonce: 0,\r\n   * },\r\n   * \"123456\");\r\n   *\r\n   * console.log(txHash);\r\n   * > 0x9445325c3c5638c9fe425b003b8c32f03e9f99d409555a650a6838ba712bb51b\r\n   * ```\r\n   */\n  sendTransaction(tx, passphrase) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.sendTransaction(this.requestManager, tx, passphrase);\n    });\n  }\n  /**\r\n   * Signs a transaction. This account needs to be unlocked.\r\n   * **_NOTE:_** Sending your account password over an unsecured HTTP RPC connection is highly unsecure.\r\n   * @param tx - The transaction data to sign. See {@link sendTransaction}  for more information.\r\n   * @param passphrase - The password of the `from` account, to sign the transaction with.\r\n   * @returns - The RLP encoded transaction. The `raw` property can be used to send the transaction using {@link sendSignedTransaction}.\r\n   * @example\r\n   * ```ts\r\n   * const tx = personal\r\n   * .signTransaction({\r\n   * \tfrom: \"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\",\r\n   * \tgasPrice: \"20000000000\",\r\n   * \tgas: \"21000\",\r\n   * \tto: \"0x3535353535353535353535353535353535353535\",\r\n   * \tvalue: \"1000000000000000000\",\r\n   * \tdata: \"\",\r\n   * \tnonce: 0,\r\n   * },\r\n   * \"123456\");\r\n   *\r\n   * console.log(tx);\r\n   *\r\n   * > {\r\n   * \traw: '0xf86e808504a817c800825208943535353535353535353535353535353535353535880de0b6b3a764000080820a95a0c951c03238fe930e6e69ab9d6af9f29248a514048e44884f0e60c4de40de3526a038b71399bf0c8925749ab79e91ce6cd2fc068c84c18ff6a197b48c4cbef01e00',\r\n   * \ttx: {\r\n   * \ttype: '0x0',\r\n   * \tnonce: '0x0',\r\n   * \tgasPrice: '0x4a817c800',\r\n   * \tmaxPriorityFeePerGas: null,\r\n   * \tmaxFeePerGas: null,\r\n   * \tgas: '0x5208',\r\n   * \tvalue: '0xde0b6b3a7640000',\r\n   * \tinput: '0x',\r\n   * \tv: '0xa95',\r\n   * \tr: '0xc951c03238fe930e6e69ab9d6af9f29248a514048e44884f0e60c4de40de3526',\r\n   * \ts: '0x38b71399bf0c8925749ab79e91ce6cd2fc068c84c18ff6a197b48c4cbef01e00',\r\n   * \tto: '0x3535353535353535353535353535353535353535',\r\n   * \thash: '0x65e3df790ab2a32068b13cff970b26445b8995229ae4abbed61bd996f09fce69'\r\n   * \t}\r\n   * }\r\n   * ```\r\n   */\n  signTransaction(tx, passphrase) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.signTransaction(this.requestManager, tx, passphrase);\n    });\n  }\n  /**\r\n   * Calculates an Ethereum specific signature with:\r\n   * sign(keccak256(\"\\x19Ethereum Signed Message:\\n\" + dataToSign.length + dataToSign)))\r\n   * Adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.\r\n   *\r\n   * If you have the original message and the signed message, you can discover the signing account address using web3.eth.personal.ecRecover\r\n   * **_NOTE:_** Sending your account password over an unsecured HTTP RPC connection is highly unsecure.\r\n   * @param data - The data to sign.\r\n   * @param address - The address to sign with.\r\n   * @param passphrase - The passphrase to decrypt the account with.\r\n   * @returns - The signature.\r\n   * @example\r\n   * ```ts\r\n   * const sig = await personal .sign(\"Hello world\", \"0x0D4Aa485ECbC499c70860fEb7e5AaeAf5fd8172E\", \"123456\")\r\n   * console.log(sig)\r\n   * > 0x5d21d01b3198ac34d0585a9d76c4d1c8123e5e06746c8962318a1c08ffb207596e6fce4a6f377b7c0fc98c5f646cd73438c80e8a1a95cbec55a84c2889dca0301b\r\n   * ```\r\n   */\n  sign(data, address, passphrase) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.sign(this.requestManager, data, address, passphrase);\n    });\n  }\n  /**\r\n   * Recovers the account that signed the data.\r\n   * @param signedData - Data that was signed. If String it will be converted using {@link utf8ToHex}\r\n   * @param signature - The signature\r\n   * @returns - The address of the account that signed the data.\r\n   * @example\r\n   * ```ts\r\n   *  const address = await personal.ecRecover(\r\n   * \t\"Hello world\",\r\n   * \t\"0x5d21d01b3198ac34d0585a9d76c4d1c8123e5e06746c8962318a1c08ffb207596e6fce4a6f377b7c0fc98c5f646cd73438c80e8a1a95cbec55a84c2889dca0301b\"\r\n   * );\r\n   * console.log(address);\r\n   * > 0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\r\n   * ```\r\n   */\n  ecRecover(signedData, signature) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return rpcWrappers.ecRecover(this.requestManager, signedData, signature);\n    });\n  }\n}","map":{"version":3,"names":["Web3Context","rpcWrappers","Personal","getAccounts","requestManager","newAccount","password","unlockAccount","address","unlockDuration","lockAccount","importRawKey","keyData","passphrase","sendTransaction","tx","signTransaction","sign","data","ecRecover","signedData","signature"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-eth-personal\\src\\personal.ts"],"sourcesContent":["﻿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { Web3Context } from 'web3-core';\r\nimport { Address, EthPersonalAPI, HexString, Transaction } from 'web3-types';\r\n\r\nimport * as rpcWrappers from './rpc_method_wrappers.js';\r\n\r\nexport class Personal extends Web3Context<EthPersonalAPI> {\r\n\t/**\r\n\t *Returns a list of accounts the node controls by using the provider and calling the RPC method personal_listAccounts. Using `web3.eth.accounts.create()` will not add accounts into this list. For that use `web3.eth.personal.newAccount()`.\r\n\t * @returns - An array of addresses controlled by the node.\r\n\t * @example\r\n\t * ```ts\r\n\t *  const accounts = await personal.getAccounts();\r\n\t * console.log(accounts);\r\n\t * >\r\n\t * [\r\n\t * \t'0x79D7BbaC53C9aF700d0B250e9AE789E503Fcd6AE',\r\n\t * \t'0xe2597eB05CF9a87eB1309e86750C903EC38E527e',\r\n\t * \t'0x7eD0e85B8E1E925600B4373e6d108F34AB38a401',\r\n\t * \t'0xE4bEEf667408b99053dC147Ed19592aDa0d77F59',\r\n\t * \t'0x7AB80aeB6bb488B7f6c41c58e83Ef248eB39c882',\r\n\t * \t'0x12B1D9d74d73b1C3A245B19C1C5501c653aF1af9',\r\n\t * \t'0x1a6075A263Ee140e00Dbf8E374Fc5A443d097894',\r\n\t * \t'0x4FEC0A51024B13030D26E70904B066C6d41157A5',\r\n\t * \t'0x03095dc4857BB26f3a4550c5651Df8b7f6b6B1Ef',\r\n\t * \t'0xac0B9b6e8A17991cb172B2ABAF45Fb5eb769E540'\r\n\t * ]\r\n\t * ```\r\n\t */\r\n\tpublic async getAccounts() {\r\n\t\treturn rpcWrappers.getAccounts(this.requestManager);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new account and returns its address.\r\n\t * **_NOTE:_**  This function sends a sensitive information like password. Never call this function over a unsecured Websocket or HTTP provider, as your password will be sent in plain text!\r\n\t * @param password - The password to encrypt the account with.\r\n\t * @returns - The address of the new account.\r\n\t * @example\r\n\t * ```ts\r\n\t * const addr = await web3.eth.personal.newAccount('password');\r\n\t * console.log(addr);\r\n\t * > '0x1234567891011121314151617181920212223456'\r\n\t * ```\r\n\t */\r\n\tpublic async newAccount(password: string) {\r\n\t\treturn rpcWrappers.newAccount(this.requestManager, password);\r\n\t}\r\n\r\n\t/**\r\n\t * Unlocks an account for a given duration.\r\n\t * @param address - The address of the account to unlock.\r\n\t * @param password - The password of the account to unlock.\r\n\t * @param unlockDuration - The duration in seconds to unlock the account for.\r\n\t * @example\r\n\t * ```ts\r\n\t * await personal.unlockAccount(\r\n\t * \t\"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\",\r\n\t * \t\"123456\",\r\n\t * \t600\r\n\t * );\r\n\t * ```\r\n\t */\r\n\tpublic async unlockAccount(address: Address, password: string, unlockDuration: number) {\r\n\t\treturn rpcWrappers.unlockAccount(this.requestManager, address, password, unlockDuration);\r\n\t}\r\n\t/**\r\n\t * Locks the given account\r\n\t * @param address - The address of the account to lock.\r\n\t * @returns - `true` if the account was locked, otherwise `false`.\r\n\t * @example\r\n\t * ```ts\r\n\t * await personal.lockAccount(\r\n\t * \t\"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\"\r\n\t * );\r\n\t */\r\n\tpublic async lockAccount(address: Address) {\r\n\t\treturn rpcWrappers.lockAccount(this.requestManager, address);\r\n\t}\r\n\t/**\r\n\t * Imports the given private key into the key store, encrypting it with the passphrase.\r\n\t * @param keyData - An unencrypted private key (hex string).\r\n\t * @param passphrase  - The password of the account\r\n\t * @returns - The address of the new account.\r\n\t * @example\r\n\t * ```ts\r\n\t * const accountAddress = await personal.importRawKey(\r\n\t * \t\"abe40cb08850da918ee951b237fa87946499b2d8643e4aa12b0610b050c731f6\",\r\n\t * \t\"123456\"\r\n\t * );\r\n\t *\r\n\t * console.log(unlockTx);\r\n\t * > 0x8727a8b34ec833154b72b62cac05d69f86eb6556\r\n\t * ```\r\n\t */\r\n\tpublic async importRawKey(keyData: HexString, passphrase: string) {\r\n\t\treturn rpcWrappers.importRawKey(this.requestManager, keyData, passphrase);\r\n\t}\r\n\r\n\t/**\r\n\t * This method sends a transaction over the management API.\r\n\t * **_NOTE:_** Sending your account password over an unsecured HTTP RPC connection is highly unsecure.\r\n\t * @param tx - The transaction options\r\n\t * @param passphrase - The passphrase of the current account\r\n\t * @returns - The transaction hash\r\n\t * @example\r\n\t * ```ts\r\n\t * const txHash = personal\r\n\t * .sendTransaction({\r\n\t *  \tfrom: \"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\",\r\n\t * \tgasPrice: \"20000000000\",\r\n\t * \tgas: \"21000\",\r\n\t * \tto: \"0x3535353535353535353535353535353535353535\",\r\n\t * \tvalue: \"1000000\",\r\n\t * \tdata: \"\",\r\n\t * \tnonce: 0,\r\n\t * },\r\n\t * \"123456\");\r\n\t *\r\n\t * console.log(txHash);\r\n\t * > 0x9445325c3c5638c9fe425b003b8c32f03e9f99d409555a650a6838ba712bb51b\r\n\t * ```\r\n\t */\r\n\tpublic async sendTransaction(tx: Transaction, passphrase: string) {\r\n\t\treturn rpcWrappers.sendTransaction(this.requestManager, tx, passphrase);\r\n\t}\r\n\t/**\r\n\t * Signs a transaction. This account needs to be unlocked.\r\n\t * **_NOTE:_** Sending your account password over an unsecured HTTP RPC connection is highly unsecure.\r\n\t * @param tx - The transaction data to sign. See {@link sendTransaction}  for more information.\r\n\t * @param passphrase - The password of the `from` account, to sign the transaction with.\r\n\t * @returns - The RLP encoded transaction. The `raw` property can be used to send the transaction using {@link sendSignedTransaction}.\r\n\t * @example\r\n\t * ```ts\r\n\t * const tx = personal\r\n\t * .signTransaction({\r\n\t * \tfrom: \"0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\",\r\n\t * \tgasPrice: \"20000000000\",\r\n\t * \tgas: \"21000\",\r\n\t * \tto: \"0x3535353535353535353535353535353535353535\",\r\n\t * \tvalue: \"1000000000000000000\",\r\n\t * \tdata: \"\",\r\n\t * \tnonce: 0,\r\n\t * },\r\n\t * \"123456\");\r\n\t *\r\n\t * console.log(tx);\r\n\t *\r\n\t * > {\r\n\t * \traw: '0xf86e808504a817c800825208943535353535353535353535353535353535353535880de0b6b3a764000080820a95a0c951c03238fe930e6e69ab9d6af9f29248a514048e44884f0e60c4de40de3526a038b71399bf0c8925749ab79e91ce6cd2fc068c84c18ff6a197b48c4cbef01e00',\r\n\t * \ttx: {\r\n\t * \ttype: '0x0',\r\n\t * \tnonce: '0x0',\r\n\t * \tgasPrice: '0x4a817c800',\r\n\t * \tmaxPriorityFeePerGas: null,\r\n\t * \tmaxFeePerGas: null,\r\n\t * \tgas: '0x5208',\r\n\t * \tvalue: '0xde0b6b3a7640000',\r\n\t * \tinput: '0x',\r\n\t * \tv: '0xa95',\r\n\t * \tr: '0xc951c03238fe930e6e69ab9d6af9f29248a514048e44884f0e60c4de40de3526',\r\n\t * \ts: '0x38b71399bf0c8925749ab79e91ce6cd2fc068c84c18ff6a197b48c4cbef01e00',\r\n\t * \tto: '0x3535353535353535353535353535353535353535',\r\n\t * \thash: '0x65e3df790ab2a32068b13cff970b26445b8995229ae4abbed61bd996f09fce69'\r\n\t * \t}\r\n\t * }\r\n\t * ```\r\n\t */\r\n\tpublic async signTransaction(tx: Transaction, passphrase: string) {\r\n\t\treturn rpcWrappers.signTransaction(this.requestManager, tx, passphrase);\r\n\t}\r\n\t/**\r\n\t * Calculates an Ethereum specific signature with:\r\n\t * sign(keccak256(\"\\x19Ethereum Signed Message:\\n\" + dataToSign.length + dataToSign)))\r\n\t * Adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.\r\n\t *\r\n\t * If you have the original message and the signed message, you can discover the signing account address using web3.eth.personal.ecRecover\r\n\t * **_NOTE:_** Sending your account password over an unsecured HTTP RPC connection is highly unsecure.\r\n\t * @param data - The data to sign.\r\n\t * @param address - The address to sign with.\r\n\t * @param passphrase - The passphrase to decrypt the account with.\r\n\t * @returns - The signature.\r\n\t * @example\r\n\t * ```ts\r\n\t * const sig = await personal .sign(\"Hello world\", \"0x0D4Aa485ECbC499c70860fEb7e5AaeAf5fd8172E\", \"123456\")\r\n\t * console.log(sig)\r\n\t * > 0x5d21d01b3198ac34d0585a9d76c4d1c8123e5e06746c8962318a1c08ffb207596e6fce4a6f377b7c0fc98c5f646cd73438c80e8a1a95cbec55a84c2889dca0301b\r\n\t * ```\r\n\t */\r\n\tpublic async sign(data: HexString, address: Address, passphrase: string) {\r\n\t\treturn rpcWrappers.sign(this.requestManager, data, address, passphrase);\r\n\t}\r\n\r\n\t/**\r\n\t * Recovers the account that signed the data.\r\n\t * @param signedData - Data that was signed. If String it will be converted using {@link utf8ToHex}\r\n\t * @param signature - The signature\r\n\t * @returns - The address of the account that signed the data.\r\n\t * @example\r\n\t * ```ts\r\n\t *  const address = await personal.ecRecover(\r\n\t * \t\"Hello world\",\r\n\t * \t\"0x5d21d01b3198ac34d0585a9d76c4d1c8123e5e06746c8962318a1c08ffb207596e6fce4a6f377b7c0fc98c5f646cd73438c80e8a1a95cbec55a84c2889dca0301b\"\r\n\t * );\r\n\t * console.log(address);\r\n\t * > 0x0d4aa485ecbc499c70860feb7e5aaeaf5fd8172e\r\n\t * ```\r\n\t */\r\n\tpublic async ecRecover(signedData: HexString, signature: string) {\r\n\t\treturn rpcWrappers.ecRecover(this.requestManager, signedData, signature);\r\n\t}\r\n}\r\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,SAASA,WAAW,QAAQ,WAAW;AAGvC,OAAO,KAAKC,WAAW,MAAM,0BAA0B;AAEvD,OAAM,MAAOC,QAAS,SAAQF,WAA2B;EACxD;;;;;;;;;;;;;;;;;;;;;;EAsBaG,WAAWA,CAAA;;MACvB,OAAOF,WAAW,CAACE,WAAW,CAAC,IAAI,CAACC,cAAc,CAAC;IACpD,CAAC;;EAED;;;;;;;;;;;;EAYaC,UAAUA,CAACC,QAAgB;;MACvC,OAAOL,WAAW,CAACI,UAAU,CAAC,IAAI,CAACD,cAAc,EAAEE,QAAQ,CAAC;IAC7D,CAAC;;EAED;;;;;;;;;;;;;;EAcaC,aAAaA,CAACC,OAAgB,EAAEF,QAAgB,EAAEG,cAAsB;;MACpF,OAAOR,WAAW,CAACM,aAAa,CAAC,IAAI,CAACH,cAAc,EAAEI,OAAO,EAAEF,QAAQ,EAAEG,cAAc,CAAC;IACzF,CAAC;;EACD;;;;;;;;;;EAUaC,WAAWA,CAACF,OAAgB;;MACxC,OAAOP,WAAW,CAACS,WAAW,CAAC,IAAI,CAACN,cAAc,EAAEI,OAAO,CAAC;IAC7D,CAAC;;EACD;;;;;;;;;;;;;;;;EAgBaG,YAAYA,CAACC,OAAkB,EAAEC,UAAkB;;MAC/D,OAAOZ,WAAW,CAACU,YAAY,CAAC,IAAI,CAACP,cAAc,EAAEQ,OAAO,EAAEC,UAAU,CAAC;IAC1E,CAAC;;EAED;;;;;;;;;;;;;;;;;;;;;;;;EAwBaC,eAAeA,CAACC,EAAe,EAAEF,UAAkB;;MAC/D,OAAOZ,WAAW,CAACa,eAAe,CAAC,IAAI,CAACV,cAAc,EAAEW,EAAE,EAAEF,UAAU,CAAC;IACxE,CAAC;;EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0CaG,eAAeA,CAACD,EAAe,EAAEF,UAAkB;;MAC/D,OAAOZ,WAAW,CAACe,eAAe,CAAC,IAAI,CAACZ,cAAc,EAAEW,EAAE,EAAEF,UAAU,CAAC;IACxE,CAAC;;EACD;;;;;;;;;;;;;;;;;;EAkBaI,IAAIA,CAACC,IAAe,EAAEV,OAAgB,EAAEK,UAAkB;;MACtE,OAAOZ,WAAW,CAACgB,IAAI,CAAC,IAAI,CAACb,cAAc,EAAEc,IAAI,EAAEV,OAAO,EAAEK,UAAU,CAAC;IACxE,CAAC;;EAED;;;;;;;;;;;;;;;EAeaM,SAASA,CAACC,UAAqB,EAAEC,SAAiB;;MAC9D,OAAOpB,WAAW,CAACkB,SAAS,CAAC,IAAI,CAACf,cAAc,EAAEgB,UAAU,EAAEC,SAAS,CAAC;IACzE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}
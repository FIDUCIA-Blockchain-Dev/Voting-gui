{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { decrypt as createDecipheriv, encrypt as createCipheriv } from 'ethereum-cryptography/aes.js';\nimport { pbkdf2Sync } from 'ethereum-cryptography/pbkdf2.js';\nimport { scryptSync } from 'ethereum-cryptography/scrypt.js';\nimport { InvalidKdfError, InvalidPasswordError, InvalidPrivateKeyError, InvalidSignatureError, IVLengthError, KeyDerivationError, KeyStoreVersionError, PBKDF2IterationsError, PrivateKeyLengthError, TransactionSigningError, UndefinedRawTransactionError } from 'web3-errors';\nimport { bytesToUint8Array, bytesToHex, fromUtf8, hexToBytes, numberToHex, randomBytes, sha3Raw, toChecksumAddress, uint8ArrayConcat, utf8ToHex, uuidV4 } from 'web3-utils';\nimport { isHexStrict, isNullish, isString, validator } from 'web3-validator';\nimport { secp256k1 } from './tx/constants.js';\nimport { keyStoreSchema } from './schemas.js';\nimport { TransactionFactory } from './tx/transactionFactory.js';\n/**\r\n * Get the private key Uint8Array after the validation\r\n */\nexport const parseAndValidatePrivateKey = (data, ignoreLength) => {\n  let privateKeyUint8Array;\n  // To avoid the case of 1 character less in a hex string which is prefixed with '0' by using 'bytesToUint8Array'\n  if (!ignoreLength && typeof data === 'string' && isHexStrict(data) && data.length !== 66) {\n    throw new PrivateKeyLengthError();\n  }\n  try {\n    privateKeyUint8Array = data instanceof Uint8Array ? data : bytesToUint8Array(data);\n  } catch (_a) {\n    throw new InvalidPrivateKeyError();\n  }\n  if (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {\n    throw new PrivateKeyLengthError();\n  }\n  return privateKeyUint8Array;\n};\n/**\r\n *\r\n * Hashes the given message. The data will be UTF-8 HEX decoded and enveloped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message and hashed using keccak256.\r\n *\r\n * @param message - A message to hash, if its HEX it will be UTF8 decoded.\r\n * @returns The hashed message\r\n *\r\n * ```ts\r\n * hashMessage(\"Hello world\")\r\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\r\n * hashMessage(utf8ToHex(\"Hello world\")) // Will be hex decoded in hashMessage\r\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\r\n * ```\r\n */\nexport const hashMessage = message => {\n  const messageHex = isHexStrict(message) ? message : utf8ToHex(message);\n  const messageBytes = hexToBytes(messageHex);\n  const preamble = hexToBytes(fromUtf8(`\\x19Ethereum Signed Message:\\n${messageBytes.byteLength}`));\n  const ethMessage = uint8ArrayConcat(preamble, messageBytes);\n  return sha3Raw(ethMessage); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n};\n/**\r\n * Signs arbitrary data with a given private key.\r\n * **_NOTE:_** The value passed as the data parameter will be UTF-8 HEX decoded and wrapped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message\r\n *\r\n * @param data - The data to sign\r\n * @param privateKey - The 32 byte private key to sign with\r\n * @returns The signature Object containing the message, messageHash, signature r, s, v\r\n *\r\n * ```ts\r\n * web3.eth.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\r\n * > {\r\n * message: 'Some data',\r\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\r\n * v: '0x1c',\r\n * r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\r\n * s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\r\n * signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\r\n * }\r\n * ```\r\n */\nexport const sign = (data, privateKey) => {\n  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n  const hash = hashMessage(data);\n  const signature = secp256k1.sign(hash.substring(2), privateKeyUint8Array);\n  const signatureBytes = signature.toCompactRawBytes();\n  const r = signature.r.toString(16);\n  const s = signature.s.toString(16);\n  const v = signature.recovery + 27;\n  return {\n    message: data,\n    messageHash: hash,\n    v: numberToHex(v),\n    r: `0x${r}`,\n    s: `0x${s}`,\n    signature: `${bytesToHex(signatureBytes)}${v.toString(16)}`\n  };\n};\n/**\r\n * Signs an Ethereum transaction with a given private key.\r\n *\r\n * @param transaction - The transaction, must be a legacy, EIP2930 or EIP 1559 transaction type\r\n * @param privateKey -  The private key to import. This is 32 bytes of random data.\r\n * @returns A signTransactionResult object that contains message hash, r, s, v, transaction hash and raw transaction.\r\n *\r\n * This function is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\r\n * This function will rely on user to provide the full transaction to be signed. If you want to sign a partial transaction object\r\n * Use {@link Web3.eth.accounts.sign} instead.\r\n *\r\n * Signing a legacy transaction\r\n * ```ts\r\n * signTransaction({\r\n *\tto: '0x118C2E5F57FD62C2B5b46a5ae9216F4FF4011a07',\r\n *\tvalue: '0x186A0',\r\n *\tgasLimit: '0x520812',\r\n *\tgasPrice: '0x09184e72a000',\r\n *\tdata: '',\r\n *\tchainId: 1,\r\n *\tnonce: 0,\r\n * }, '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318'))\r\n * }\r\n * > {\r\n * messageHash: '0x28b7b75f7ba48d588a902c1ff4d5d13cc0ca9ac0aaa39562368146923fb853bf',\r\n * v: '0x25',\r\n * r: '0x601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5',\r\n * s: '0x690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\r\n * rawTransaction: '0xf869808609184e72a0008352081294118c2e5f57fd62c2b5b46a5ae9216f4ff4011a07830186a08025a00601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5a0690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\r\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n * ```\r\n * Signing an eip 1559 transaction\r\n * ```ts\r\n * signTransaction({\r\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\r\n *\tmaxPriorityFeePerGas: '0x3B9ACA00',\r\n *\tmaxFeePerGas: '0xB2D05E00',\r\n *\tgasLimit: '0x6A4012',\r\n *\tvalue: '0x186A0',\r\n *\tdata: '',\r\n *\tchainId: 1,\r\n *\tnonce: 0,\r\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\r\n * > {\r\n *  messageHash: '0x5744f24d5f0aff6c70487c8e85adf07d8564e50b08558788f00479611d7bae5f',\r\n * v: '0x25',\r\n * r: '0x78a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347',\r\n * s: '0x9cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\r\n * rawTransaction: '0xf8638080836a401294f0109fc8df283027b6285cc889f5aa624eac1f55830186a08025a078a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347a009cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\r\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n * }\r\n * ```\r\n * Signing an eip 2930 transaction\r\n * ```ts\r\n * signTransaction({\r\n *\tchainId: 1,\r\n *\tnonce: 0,\r\n *\tgasPrice: '0x09184e72a000',\r\n *\tgasLimit: '0x2710321',\r\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\r\n *\tvalue: '0x186A0',\r\n *\tdata: '',\r\n *\taccessList: [\r\n *\t\t{\r\n *\t\t\taddress: '0x0000000000000000000000000000000000000101',\r\n *\t\t\tstorageKeys: [\r\n *\t\t\t\t'0x0000000000000000000000000000000000000000000000000000000000000000',\r\n *\t\t\t\t'0x00000000000000000000000000000000000000000000000000000000000060a7',\r\n *\t\t\t],\r\n *\t\t},\r\n *\t],\r\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\r\n * > {\r\n * messageHash: '0xc55ea24bdb4c379550a7c9a6818ac39ca33e75bc78ddb862bd82c31cc1c7a073',\r\n * v: '0x26',\r\n * r: '0x27344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098e',\r\n * s: '0x519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\r\n * rawTransaction: '0xf86a808609184e72a000840271032194f0109fc8df283027b6285cc889f5aa624eac1f55830186a08026a027344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098ea0519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\r\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n * }\r\n * ```\r\n */\nexport const signTransaction = (transaction, privateKey) => __awaiter(void 0, void 0, void 0, function* () {\n  const signedTx = transaction.sign(hexToBytes(privateKey));\n  if (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s)) throw new TransactionSigningError('Signer Error');\n  const validationErrors = signedTx.validate(true);\n  if (validationErrors.length > 0) {\n    let errorString = 'Signer Error ';\n    for (const validationError of validationErrors) {\n      errorString += `${errorString} ${validationError}.`;\n    }\n    throw new TransactionSigningError(errorString);\n  }\n  const rawTx = bytesToHex(signedTx.serialize());\n  const txHash = sha3Raw(rawTx); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n  return {\n    messageHash: bytesToHex(signedTx.getMessageToSign(true)),\n    v: `0x${signedTx.v.toString(16)}`,\n    r: `0x${signedTx.r.toString(16).padStart(64, '0')}`,\n    s: `0x${signedTx.s.toString(16).padStart(64, '0')}`,\n    rawTransaction: rawTx,\n    transactionHash: bytesToHex(txHash)\n  };\n});\n/**\r\n * Recovers the Ethereum address which was used to sign the given RLP encoded transaction.\r\n *\r\n * @param rawTransaction - The hex string having RLP encoded transaction\r\n * @returns The Ethereum address used to sign this transaction\r\n * ```ts\r\n * recoverTransaction('0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68');\r\n * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\r\n * ```\r\n */\nexport const recoverTransaction = rawTransaction => {\n  if (isNullish(rawTransaction)) throw new UndefinedRawTransactionError();\n  const tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));\n  return toChecksumAddress(tx.getSenderAddress().toString());\n};\n/**\r\n * Recovers the Ethereum address which was used to sign the given data\r\n *\r\n * @param data - Either a signed message, hash, or the {@link signatureObject}\r\n * @param signature - The raw RLP encoded signature\r\n * @param signatureOrV - signatureOrV\r\n * @param prefixedOrR - prefixedOrR\r\n * @param s - s\r\n * @param prefixed - (default: false) If the last parameter is true, the given message will NOT automatically be prefixed with \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message, and assumed to be already prefixed.\r\n * @returns The Ethereum address used to sign this data\r\n * ```ts\r\n * sign('Some data', '0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728');\r\n * > {\r\n * message: 'Some data',\r\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\r\n * v: '0x1b',\r\n * r: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f9',\r\n * s: '0x53e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb150',\r\n * signature: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b'\r\n * }\r\n * recover('0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b');\r\n * > '0xEB014f8c8B418Db6b45774c326A0E64C78914dC0'\r\n * ```\r\n */\nexport const recover = (data, signatureOrV, prefixedOrR, s, prefixed) => {\n  if (typeof data === 'object') {\n    const signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;\n    return recover(data.messageHash, signatureStr, prefixedOrR);\n  }\n  if (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !isNullish(s)) {\n    const signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;\n    return recover(data, signatureStr, prefixed);\n  }\n  if (isNullish(signatureOrV)) throw new InvalidSignatureError('signature string undefined');\n  const V_INDEX = 130; // r = first 32 bytes, s = second 32 bytes, v = last byte of signature\n  const hashedMessage = prefixedOrR ? data : hashMessage(data);\n  const v = signatureOrV.substring(V_INDEX); // 0x + r + s + v\n  const ecPublicKey = secp256k1.Signature.fromCompact(signatureOrV.slice(2, V_INDEX)).addRecoveryBit(parseInt(v, 16) - 27).recoverPublicKey(hashedMessage.replace('0x', '')).toRawBytes(false);\n  const publicHash = sha3Raw(ecPublicKey.subarray(1));\n  const address = toChecksumAddress(`0x${publicHash.slice(-40)}`);\n  return address;\n};\n/**\r\n * Get the ethereum Address from a private key\r\n *\r\n * @param privateKey - String or Uint8Array of 32 bytes\r\n * @param ignoreLength - if true, will not error check length\r\n * @returns The Ethereum address\r\n * @example\r\n * ```ts\r\n * privateKeyToAddress(\"0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728\")\r\n * > \"0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\"\r\n * ```\r\n */\nexport const privateKeyToAddress = privateKey => {\n  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n  // Get public key from private key in compressed format\n  const publicKey = secp256k1.getPublicKey(privateKeyUint8Array, false);\n  // Uncompressed ECDSA public key contains the prefix `0x04` which is not used in the Ethereum public key\n  const publicKeyHash = sha3Raw(publicKey.slice(1));\n  // The hash is returned as 256 bits (32 bytes) or 64 hex characters\n  // To get the address, take the last 20 bytes of the public hash\n  const address = publicKeyHash.slice(-40);\n  return toChecksumAddress(`0x${address}`);\n};\n/**\r\n * encrypt a private key with a password, returns a V3 JSON Keystore\r\n *\r\n * Read more: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\r\n *\r\n * @param privateKey - The private key to encrypt, 32 bytes.\r\n * @param password - The password used for encryption.\r\n * @param options - Options to configure to encrypt the keystore either scrypt or pbkdf2\r\n * @returns Returns a V3 JSON Keystore\r\n *\r\n *\r\n * Encrypt using scrypt options\r\n * ```ts\r\n * encrypt('0x67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\r\n * '123',\r\n * {\r\n *   n: 8192,\r\n *\t iv: web3.utils.hexToBytes('0xbfb43120ae00e9de110f8325143a2709'),\r\n *\t salt: web3.utils.hexToBytes('0x210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'),\r\n *\t),\r\n * }).then(console.log)\r\n * > {\r\n * version: 3,\r\n * id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\r\n * address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\r\n * crypto: {\r\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\r\n *   cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\r\n *   cipher: 'aes-128-ctr',\r\n *   kdf: 'scrypt',\r\n *   kdfparams: {\r\n *     n: 8192,\r\n *     r: 8,\r\n *     p: 1,\r\n *     dklen: 32,\r\n *     salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\r\n *   },\r\n *   mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\r\n * }\r\n *}\r\n *```\r\n * Encrypting using pbkdf2 options\r\n * ```ts\r\n * encrypt('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n *'123',\r\n *{\r\n *\tiv: 'bfb43120ae00e9de110f8325143a2709',\r\n *\tsalt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\r\n *\tc: 262144,\r\n *\tkdf: 'pbkdf2',\r\n *}).then(console.log)\r\n * >\r\n * {\r\n *   version: 3,\r\n *   id: '77381417-0973-4e4b-b590-8eb3ace0fe2d',\r\n *   address: 'b8ce9ab6943e0eced004cde8e3bbed6568b2fa01',\r\n *   crypto: {\r\n *     ciphertext: '76512156a34105fa6473ad040c666ae7b917d14c06543accc0d2dc28e6073b12',\r\n *     cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\r\n *     cipher: 'aes-128-ctr',\r\n *     kdf: 'pbkdf2',\r\n *     kdfparams: {\r\n *       dklen: 32,\r\n *       salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\r\n *       c: 262144,\r\n *       prf: 'hmac-sha256'\r\n *     },\r\n *   mac: '46eb4884e82dc43b5aa415faba53cc653b7038e9d61cc32fd643cf8c396189b7'\r\n *   }\r\n * }\r\n *```\r\n */\nexport const encrypt = (privateKey, password, options) => __awaiter(void 0, void 0, void 0, function* () {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n  // if given salt or iv is a string, convert it to a Uint8Array\n  let salt;\n  if (options === null || options === void 0 ? void 0 : options.salt) {\n    salt = typeof options.salt === 'string' ? hexToBytes(options.salt) : options.salt;\n  } else {\n    salt = randomBytes(32);\n  }\n  if (!(isString(password) || password instanceof Uint8Array)) {\n    throw new InvalidPasswordError();\n  }\n  const uint8ArrayPassword = typeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n  let initializationVector;\n  if (options === null || options === void 0 ? void 0 : options.iv) {\n    initializationVector = typeof options.iv === 'string' ? hexToBytes(options.iv) : options.iv;\n    if (initializationVector.length !== 16) {\n      throw new IVLengthError();\n    }\n  } else {\n    initializationVector = randomBytes(16);\n  }\n  const kdf = (_a = options === null || options === void 0 ? void 0 : options.kdf) !== null && _a !== void 0 ? _a : 'scrypt';\n  let derivedKey;\n  let kdfparams;\n  // derive key from key derivation function\n  if (kdf === 'pbkdf2') {\n    kdfparams = {\n      dklen: (_b = options === null || options === void 0 ? void 0 : options.dklen) !== null && _b !== void 0 ? _b : 32,\n      salt: bytesToHex(salt).replace('0x', ''),\n      c: (_c = options === null || options === void 0 ? void 0 : options.c) !== null && _c !== void 0 ? _c : 262144,\n      prf: 'hmac-sha256'\n    };\n    if (kdfparams.c < 1000) {\n      // error when c < 1000, pbkdf2 is less secure with less iterations\n      throw new PBKDF2IterationsError();\n    }\n    derivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else if (kdf === 'scrypt') {\n    kdfparams = {\n      n: (_d = options === null || options === void 0 ? void 0 : options.n) !== null && _d !== void 0 ? _d : 8192,\n      r: (_e = options === null || options === void 0 ? void 0 : options.r) !== null && _e !== void 0 ? _e : 8,\n      p: (_f = options === null || options === void 0 ? void 0 : options.p) !== null && _f !== void 0 ? _f : 1,\n      dklen: (_g = options === null || options === void 0 ? void 0 : options.dklen) !== null && _g !== void 0 ? _g : 32,\n      salt: bytesToHex(salt).replace('0x', '')\n    };\n    derivedKey = scryptSync(uint8ArrayPassword, salt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);\n  } else {\n    throw new InvalidKdfError();\n  }\n  const cipher = yield createCipheriv(privateKeyUint8Array, derivedKey.slice(0, 16), initializationVector, 'aes-128-ctr');\n  const ciphertext = bytesToHex(cipher).slice(2);\n  const mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace('0x', '');\n  return {\n    version: 3,\n    id: uuidV4(),\n    address: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace('0x', ''),\n    crypto: {\n      ciphertext,\n      cipherparams: {\n        iv: bytesToHex(initializationVector).replace('0x', '')\n      },\n      cipher: 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac\n    }\n  };\n});\n/**\r\n * Get an Account object from the privateKey\r\n *\r\n * @param privateKey - String or Uint8Array of 32 bytes\r\n * @param ignoreLength - if true, will not error check length\r\n * @returns A Web3Account object\r\n *\r\n * The `Web3Account.signTransaction` is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\r\n * Use {@link Web3.eth.accounts.signTransaction} instead.\r\n *\r\n * ```ts\r\n * privateKeyToAccount(\"0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709\");\r\n * >    {\r\n * \t\t\taddress: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\r\n * \t\t\tprivateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n * \t\t\tsign,\r\n * \t\t\tsignTransaction,\r\n * \t\t\tencrypt,\r\n * \t}\r\n * ```\r\n */\nexport const privateKeyToAccount = (privateKey, ignoreLength) => {\n  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);\n  return {\n    address: privateKeyToAddress(privateKeyUint8Array),\n    privateKey: bytesToHex(privateKeyUint8Array),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    signTransaction: _tx => {\n      throw new TransactionSigningError('Do not have network access to sign the transaction');\n    },\n    sign: data => sign(typeof data === 'string' ? data : JSON.stringify(data), privateKeyUint8Array),\n    encrypt: (password, options) => __awaiter(void 0, void 0, void 0, function* () {\n      return encrypt(privateKeyUint8Array, password, options);\n    })\n  };\n};\n/**\r\n *\r\n * Generates and returns a Web3Account object that includes the private and public key\r\n * For creation of private key, it uses an audited package ethereum-cryptography/secp256k1\r\n * that is cryptographically secure random number with certain characteristics.\r\n * Read more: https://www.npmjs.com/package/ethereum-cryptography#secp256k1-curve\r\n *\r\n * @returns A Web3Account object\r\n * ```ts\r\n * web3.eth.accounts.create();\r\n * {\r\n * address: '0xbD504f977021b5E5DdccD8741A368b147B3B38bB',\r\n * privateKey: '0x964ced1c69ad27a311c432fdc0d8211e987595f7eb34ab405a5f16bdc9563ec5',\r\n * signTransaction: [Function: signTransaction],\r\n * sign: [Function: sign],\r\n * encrypt: [AsyncFunction: encrypt]\r\n * }\r\n * ```\r\n */\nexport const create = () => {\n  const privateKey = secp256k1.utils.randomPrivateKey();\n  return privateKeyToAccount(`${bytesToHex(privateKey)}`);\n};\n/**\r\n * Decrypts a v3 keystore JSON, and creates the account.\r\n *\r\n * @param keystore - the encrypted Keystore object or string to decrypt\r\n * @param password - The password that was used for encryption\r\n * @param nonStrict - if true and given a json string, the keystore will be parsed as lowercase.\r\n * @returns Returns the decrypted Web3Account object\r\n * Decrypting scrypt\r\n *\r\n * ```ts\r\n * decrypt({\r\n *   version: 3,\r\n *   id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\r\n *   address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\r\n *   crypto: {\r\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\r\n *      cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\r\n *      cipher: 'aes-128-ctr',\r\n *      kdf: 'scrypt',\r\n *      kdfparams: {\r\n *        n: 8192,\r\n *        r: 8,\r\n *        p: 1,\r\n *        dklen: 32,\r\n *        salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\r\n *      },\r\n *      mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\r\n *    }\r\n *   }, '123').then(console.log)\r\n * > {\r\n * address: '0xcdA9A91875fc35c8Ac1320E098e584495d66e47c',\r\n * privateKey: '67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\r\n * signTransaction: [Function: signTransaction],\r\n * sign: [Function: sign],\r\n * encrypt: [AsyncFunction: encrypt]\r\n * }\r\n * ```\r\n */\nexport const decrypt = (keystore, password, nonStrict) => __awaiter(void 0, void 0, void 0, function* () {\n  const json = typeof keystore === 'object' ? keystore : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);\n  validator.validateJSONSchema(keyStoreSchema, json);\n  if (json.version !== 3) throw new KeyStoreVersionError();\n  const uint8ArrayPassword = typeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n  validator.validate(['bytes'], [uint8ArrayPassword]);\n  let derivedKey;\n  if (json.crypto.kdf === 'scrypt') {\n    const kdfparams = json.crypto.kdfparams;\n    const uint8ArraySalt = typeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n    derivedKey = scryptSync(uint8ArrayPassword, uint8ArraySalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);\n  } else if (json.crypto.kdf === 'pbkdf2') {\n    const kdfparams = json.crypto.kdfparams;\n    const uint8ArraySalt = typeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n    derivedKey = pbkdf2Sync(uint8ArrayPassword, uint8ArraySalt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else {\n    throw new InvalidKdfError();\n  }\n  const ciphertext = hexToBytes(json.crypto.ciphertext);\n  const mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace('0x', '');\n  if (mac !== json.crypto.mac) {\n    throw new KeyDerivationError();\n  }\n  const seed = yield createDecipheriv(hexToBytes(json.crypto.ciphertext), derivedKey.slice(0, 16), hexToBytes(json.crypto.cipherparams.iv));\n  return privateKeyToAccount(seed);\n});","map":{"version":3,"names":["decrypt","createDecipheriv","encrypt","createCipheriv","pbkdf2Sync","scryptSync","InvalidKdfError","InvalidPasswordError","InvalidPrivateKeyError","InvalidSignatureError","IVLengthError","KeyDerivationError","KeyStoreVersionError","PBKDF2IterationsError","PrivateKeyLengthError","TransactionSigningError","UndefinedRawTransactionError","bytesToUint8Array","bytesToHex","fromUtf8","hexToBytes","numberToHex","randomBytes","sha3Raw","toChecksumAddress","uint8ArrayConcat","utf8ToHex","uuidV4","isHexStrict","isNullish","isString","validator","secp256k1","keyStoreSchema","TransactionFactory","parseAndValidatePrivateKey","data","ignoreLength","privateKeyUint8Array","length","Uint8Array","_a","byteLength","hashMessage","message","messageHex","messageBytes","preamble","ethMessage","sign","privateKey","hash","signature","substring","signatureBytes","toCompactRawBytes","r","toString","s","v","recovery","messageHash","signTransaction","transaction","__awaiter","signedTx","validationErrors","validate","errorString","validationError","rawTx","serialize","txHash","getMessageToSign","padStart","rawTransaction","transactionHash","recoverTransaction","tx","fromSerializedData","getSenderAddress","recover","signatureOrV","prefixedOrR","prefixed","signatureStr","slice","V_INDEX","hashedMessage","ecPublicKey","Signature","fromCompact","addRecoveryBit","parseInt","recoverPublicKey","replace","toRawBytes","publicHash","subarray","address","privateKeyToAddress","publicKey","getPublicKey","publicKeyHash","password","options","salt","uint8ArrayPassword","initializationVector","iv","kdf","derivedKey","kdfparams","dklen","_b","c","_c","prf","n","_d","_e","p","_f","_g","cipher","ciphertext","mac","version","id","toLowerCase","crypto","cipherparams","privateKeyToAccount","_tx","JSON","stringify","create","utils","randomPrivateKey","keystore","nonStrict","json","parse","validateJSONSchema","uint8ArraySalt","seed"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-eth-accounts\\src\\account.ts"],"sourcesContent":["ï»¿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport {\r\n\tdecrypt as createDecipheriv,\r\n\tencrypt as createCipheriv,\r\n} from 'ethereum-cryptography/aes.js';\r\nimport { pbkdf2Sync } from 'ethereum-cryptography/pbkdf2.js';\r\nimport { scryptSync } from 'ethereum-cryptography/scrypt.js';\r\nimport {\r\n\tInvalidKdfError,\r\n\tInvalidPasswordError,\r\n\tInvalidPrivateKeyError,\r\n\tInvalidSignatureError,\r\n\tIVLengthError,\r\n\tKeyDerivationError,\r\n\tKeyStoreVersionError,\r\n\tPBKDF2IterationsError,\r\n\tPrivateKeyLengthError,\r\n\tTransactionSigningError,\r\n\tUndefinedRawTransactionError,\r\n} from 'web3-errors';\r\nimport {\r\n\tAddress,\r\n\tBytes,\r\n\tCipherOptions,\r\n\tHexString,\r\n\tKeyStore,\r\n\tPBKDF2SHA256Params,\r\n\tScryptParams,\r\n\tTransaction,\r\n} from 'web3-types';\r\nimport {\r\n\tbytesToUint8Array,\r\n\tbytesToHex,\r\n\tfromUtf8,\r\n\thexToBytes,\r\n\tnumberToHex,\r\n\trandomBytes,\r\n\tsha3Raw,\r\n\ttoChecksumAddress,\r\n\tuint8ArrayConcat,\r\n\tutf8ToHex,\r\n\tuuidV4,\r\n} from 'web3-utils';\r\n\r\nimport { isHexStrict, isNullish, isString, validator } from 'web3-validator';\r\nimport { secp256k1 } from './tx/constants.js';\r\nimport { keyStoreSchema } from './schemas.js';\r\nimport { TransactionFactory } from './tx/transactionFactory.js';\r\nimport type {\r\n\tSignatureObject,\r\n\tSignTransactionResult,\r\n\tTypedTransaction,\r\n\tWeb3Account,\r\n\tSignResult,\r\n} from './types.js';\r\n\r\n/**\r\n * Get the private key Uint8Array after the validation\r\n */\r\nexport const parseAndValidatePrivateKey = (data: Bytes, ignoreLength?: boolean): Uint8Array => {\r\n\tlet privateKeyUint8Array: Uint8Array;\r\n\r\n\t// To avoid the case of 1 character less in a hex string which is prefixed with '0' by using 'bytesToUint8Array'\r\n\tif (!ignoreLength && typeof data === 'string' && isHexStrict(data) && data.length !== 66) {\r\n\t\tthrow new PrivateKeyLengthError();\r\n\t}\r\n\r\n\ttry {\r\n\t\tprivateKeyUint8Array = data instanceof Uint8Array ? data : bytesToUint8Array(data);\r\n\t} catch {\r\n\t\tthrow new InvalidPrivateKeyError();\r\n\t}\r\n\r\n\tif (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {\r\n\t\tthrow new PrivateKeyLengthError();\r\n\t}\r\n\r\n\treturn privateKeyUint8Array;\r\n};\r\n\r\n/**\r\n *\r\n * Hashes the given message. The data will be UTF-8 HEX decoded and enveloped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message and hashed using keccak256.\r\n *\r\n * @param message - A message to hash, if its HEX it will be UTF8 decoded.\r\n * @returns The hashed message\r\n *\r\n * ```ts\r\n * hashMessage(\"Hello world\")\r\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\r\n * hashMessage(utf8ToHex(\"Hello world\")) // Will be hex decoded in hashMessage\r\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\r\n * ```\r\n */\r\nexport const hashMessage = (message: string): string => {\r\n\tconst messageHex = isHexStrict(message) ? message : utf8ToHex(message);\r\n\r\n\tconst messageBytes = hexToBytes(messageHex);\r\n\r\n\tconst preamble = hexToBytes(\r\n\t\tfromUtf8(`\\x19Ethereum Signed Message:\\n${messageBytes.byteLength}`),\r\n\t);\r\n\r\n\tconst ethMessage = uint8ArrayConcat(preamble, messageBytes);\r\n\r\n\treturn sha3Raw(ethMessage); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\r\n};\r\n\r\n/**\r\n * Signs arbitrary data with a given private key.\r\n * **_NOTE:_** The value passed as the data parameter will be UTF-8 HEX decoded and wrapped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message\r\n *\r\n * @param data - The data to sign\r\n * @param privateKey - The 32 byte private key to sign with\r\n * @returns The signature Object containing the message, messageHash, signature r, s, v\r\n *\r\n * ```ts\r\n * web3.eth.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\r\n * > {\r\n * message: 'Some data',\r\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\r\n * v: '0x1c',\r\n * r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\r\n * s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\r\n * signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\r\n * }\r\n * ```\r\n */\r\nexport const sign = (data: string, privateKey: Bytes): SignResult => {\r\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\r\n\r\n\tconst hash = hashMessage(data);\r\n\r\n\tconst signature = secp256k1.sign(hash.substring(2), privateKeyUint8Array);\r\n\tconst signatureBytes = signature.toCompactRawBytes();\r\n\tconst r = signature.r.toString(16);\r\n\tconst s = signature.s.toString(16);\r\n\tconst v = signature.recovery! + 27;\r\n\r\n\treturn {\r\n\t\tmessage: data,\r\n\t\tmessageHash: hash,\r\n\t\tv: numberToHex(v),\r\n\t\tr: `0x${r}`,\r\n\t\ts: `0x${s}`,\r\n\t\tsignature: `${bytesToHex(signatureBytes)}${v.toString(16)}`,\r\n\t};\r\n};\r\n\r\n/**\r\n * Signs an Ethereum transaction with a given private key.\r\n *\r\n * @param transaction - The transaction, must be a legacy, EIP2930 or EIP 1559 transaction type\r\n * @param privateKey -  The private key to import. This is 32 bytes of random data.\r\n * @returns A signTransactionResult object that contains message hash, r, s, v, transaction hash and raw transaction.\r\n *\r\n * This function is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\r\n * This function will rely on user to provide the full transaction to be signed. If you want to sign a partial transaction object\r\n * Use {@link Web3.eth.accounts.sign} instead.\r\n *\r\n * Signing a legacy transaction\r\n * ```ts\r\n * signTransaction({\r\n *\tto: '0x118C2E5F57FD62C2B5b46a5ae9216F4FF4011a07',\r\n *\tvalue: '0x186A0',\r\n *\tgasLimit: '0x520812',\r\n *\tgasPrice: '0x09184e72a000',\r\n *\tdata: '',\r\n *\tchainId: 1,\r\n *\tnonce: 0,\r\n * }, '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318'))\r\n * }\r\n * > {\r\n * messageHash: '0x28b7b75f7ba48d588a902c1ff4d5d13cc0ca9ac0aaa39562368146923fb853bf',\r\n * v: '0x25',\r\n * r: '0x601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5',\r\n * s: '0x690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\r\n * rawTransaction: '0xf869808609184e72a0008352081294118c2e5f57fd62c2b5b46a5ae9216f4ff4011a07830186a08025a00601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5a0690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\r\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n * ```\r\n * Signing an eip 1559 transaction\r\n * ```ts\r\n * signTransaction({\r\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\r\n *\tmaxPriorityFeePerGas: '0x3B9ACA00',\r\n *\tmaxFeePerGas: '0xB2D05E00',\r\n *\tgasLimit: '0x6A4012',\r\n *\tvalue: '0x186A0',\r\n *\tdata: '',\r\n *\tchainId: 1,\r\n *\tnonce: 0,\r\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\r\n * > {\r\n *  messageHash: '0x5744f24d5f0aff6c70487c8e85adf07d8564e50b08558788f00479611d7bae5f',\r\n * v: '0x25',\r\n * r: '0x78a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347',\r\n * s: '0x9cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\r\n * rawTransaction: '0xf8638080836a401294f0109fc8df283027b6285cc889f5aa624eac1f55830186a08025a078a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347a009cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\r\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n * }\r\n * ```\r\n * Signing an eip 2930 transaction\r\n * ```ts\r\n * signTransaction({\r\n *\tchainId: 1,\r\n *\tnonce: 0,\r\n *\tgasPrice: '0x09184e72a000',\r\n *\tgasLimit: '0x2710321',\r\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\r\n *\tvalue: '0x186A0',\r\n *\tdata: '',\r\n *\taccessList: [\r\n *\t\t{\r\n *\t\t\taddress: '0x0000000000000000000000000000000000000101',\r\n *\t\t\tstorageKeys: [\r\n *\t\t\t\t'0x0000000000000000000000000000000000000000000000000000000000000000',\r\n *\t\t\t\t'0x00000000000000000000000000000000000000000000000000000000000060a7',\r\n *\t\t\t],\r\n *\t\t},\r\n *\t],\r\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\r\n * > {\r\n * messageHash: '0xc55ea24bdb4c379550a7c9a6818ac39ca33e75bc78ddb862bd82c31cc1c7a073',\r\n * v: '0x26',\r\n * r: '0x27344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098e',\r\n * s: '0x519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\r\n * rawTransaction: '0xf86a808609184e72a000840271032194f0109fc8df283027b6285cc889f5aa624eac1f55830186a08026a027344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098ea0519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\r\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n * }\r\n * ```\r\n */\r\nexport const signTransaction = async (\r\n\ttransaction: TypedTransaction,\r\n\tprivateKey: HexString,\r\n\t// To make it compatible with rest of the API, have to keep it async\r\n\t// eslint-disable-next-line @typescript-eslint/require-await\r\n): Promise<SignTransactionResult> => {\r\n\tconst signedTx = transaction.sign(hexToBytes(privateKey));\r\n\tif (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))\r\n\t\tthrow new TransactionSigningError('Signer Error');\r\n\r\n\tconst validationErrors = signedTx.validate(true);\r\n\r\n\tif (validationErrors.length > 0) {\r\n\t\tlet errorString = 'Signer Error ';\r\n\t\tfor (const validationError of validationErrors) {\r\n\t\t\terrorString += `${errorString} ${validationError}.`;\r\n\t\t}\r\n\t\tthrow new TransactionSigningError(errorString);\r\n\t}\r\n\r\n\tconst rawTx = bytesToHex(signedTx.serialize());\r\n\tconst txHash = sha3Raw(rawTx); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\r\n\r\n\treturn {\r\n\t\tmessageHash: bytesToHex(signedTx.getMessageToSign(true)),\r\n\t\tv: `0x${signedTx.v.toString(16)}`,\r\n\t\tr: `0x${signedTx.r.toString(16).padStart(64, '0')}`,\r\n\t\ts: `0x${signedTx.s.toString(16).padStart(64, '0')}`,\r\n\t\trawTransaction: rawTx,\r\n\t\ttransactionHash: bytesToHex(txHash),\r\n\t};\r\n};\r\n\r\n/**\r\n * Recovers the Ethereum address which was used to sign the given RLP encoded transaction.\r\n *\r\n * @param rawTransaction - The hex string having RLP encoded transaction\r\n * @returns The Ethereum address used to sign this transaction\r\n * ```ts\r\n * recoverTransaction('0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68');\r\n * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\r\n * ```\r\n */\r\nexport const recoverTransaction = (rawTransaction: HexString): Address => {\r\n\tif (isNullish(rawTransaction)) throw new UndefinedRawTransactionError();\r\n\r\n\tconst tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));\r\n\r\n\treturn toChecksumAddress(tx.getSenderAddress().toString());\r\n};\r\n\r\n/**\r\n * Recovers the Ethereum address which was used to sign the given data\r\n *\r\n * @param data - Either a signed message, hash, or the {@link signatureObject}\r\n * @param signature - The raw RLP encoded signature\r\n * @param signatureOrV - signatureOrV\r\n * @param prefixedOrR - prefixedOrR\r\n * @param s - s\r\n * @param prefixed - (default: false) If the last parameter is true, the given message will NOT automatically be prefixed with \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message, and assumed to be already prefixed.\r\n * @returns The Ethereum address used to sign this data\r\n * ```ts\r\n * sign('Some data', '0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728');\r\n * > {\r\n * message: 'Some data',\r\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\r\n * v: '0x1b',\r\n * r: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f9',\r\n * s: '0x53e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb150',\r\n * signature: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b'\r\n * }\r\n * recover('0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b');\r\n * > '0xEB014f8c8B418Db6b45774c326A0E64C78914dC0'\r\n * ```\r\n */\r\nexport const recover = (\r\n\tdata: string | SignatureObject,\r\n\tsignatureOrV?: string,\r\n\tprefixedOrR?: boolean | string,\r\n\ts?: string,\r\n\tprefixed?: boolean,\r\n): Address => {\r\n\tif (typeof data === 'object') {\r\n\t\tconst signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;\r\n\t\treturn recover(data.messageHash, signatureStr, prefixedOrR);\r\n\t}\r\n\tif (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !isNullish(s)) {\r\n\t\tconst signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;\r\n\t\treturn recover(data, signatureStr, prefixed);\r\n\t}\r\n\r\n\tif (isNullish(signatureOrV)) throw new InvalidSignatureError('signature string undefined');\r\n\r\n\tconst V_INDEX = 130; // r = first 32 bytes, s = second 32 bytes, v = last byte of signature\r\n\tconst hashedMessage = prefixedOrR ? data : hashMessage(data);\r\n\r\n\tconst v = signatureOrV.substring(V_INDEX); // 0x + r + s + v\r\n\r\n\tconst ecPublicKey = secp256k1.Signature.fromCompact(signatureOrV.slice(2, V_INDEX))\r\n\t\t.addRecoveryBit(parseInt(v, 16) - 27)\r\n\t\t.recoverPublicKey(hashedMessage.replace('0x', ''))\r\n\t\t.toRawBytes(false);\r\n\r\n\tconst publicHash = sha3Raw(ecPublicKey.subarray(1));\r\n\r\n\tconst address = toChecksumAddress(`0x${publicHash.slice(-40)}`);\r\n\r\n\treturn address;\r\n};\r\n\r\n/**\r\n * Get the ethereum Address from a private key\r\n *\r\n * @param privateKey - String or Uint8Array of 32 bytes\r\n * @param ignoreLength - if true, will not error check length\r\n * @returns The Ethereum address\r\n * @example\r\n * ```ts\r\n * privateKeyToAddress(\"0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728\")\r\n * > \"0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\"\r\n * ```\r\n */\r\nexport const privateKeyToAddress = (privateKey: Bytes): string => {\r\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\r\n\r\n\t// Get public key from private key in compressed format\r\n\tconst publicKey = secp256k1.getPublicKey(privateKeyUint8Array, false);\r\n\r\n\t// Uncompressed ECDSA public key contains the prefix `0x04` which is not used in the Ethereum public key\r\n\tconst publicKeyHash = sha3Raw(publicKey.slice(1));\r\n\r\n\t// The hash is returned as 256 bits (32 bytes) or 64 hex characters\r\n\t// To get the address, take the last 20 bytes of the public hash\r\n\tconst address = publicKeyHash.slice(-40);\r\n\r\n\treturn toChecksumAddress(`0x${address}`);\r\n};\r\n\r\n/**\r\n * encrypt a private key with a password, returns a V3 JSON Keystore\r\n *\r\n * Read more: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\r\n *\r\n * @param privateKey - The private key to encrypt, 32 bytes.\r\n * @param password - The password used for encryption.\r\n * @param options - Options to configure to encrypt the keystore either scrypt or pbkdf2\r\n * @returns Returns a V3 JSON Keystore\r\n *\r\n *\r\n * Encrypt using scrypt options\r\n * ```ts\r\n * encrypt('0x67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\r\n * '123',\r\n * {\r\n *   n: 8192,\r\n *\t iv: web3.utils.hexToBytes('0xbfb43120ae00e9de110f8325143a2709'),\r\n *\t salt: web3.utils.hexToBytes('0x210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'),\r\n *\t),\r\n * }).then(console.log)\r\n * > {\r\n * version: 3,\r\n * id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\r\n * address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\r\n * crypto: {\r\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\r\n *   cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\r\n *   cipher: 'aes-128-ctr',\r\n *   kdf: 'scrypt',\r\n *   kdfparams: {\r\n *     n: 8192,\r\n *     r: 8,\r\n *     p: 1,\r\n *     dklen: 32,\r\n *     salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\r\n *   },\r\n *   mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\r\n * }\r\n *}\r\n *```\r\n * Encrypting using pbkdf2 options\r\n * ```ts\r\n * encrypt('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n *'123',\r\n *{\r\n *\tiv: 'bfb43120ae00e9de110f8325143a2709',\r\n *\tsalt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\r\n *\tc: 262144,\r\n *\tkdf: 'pbkdf2',\r\n *}).then(console.log)\r\n * >\r\n * {\r\n *   version: 3,\r\n *   id: '77381417-0973-4e4b-b590-8eb3ace0fe2d',\r\n *   address: 'b8ce9ab6943e0eced004cde8e3bbed6568b2fa01',\r\n *   crypto: {\r\n *     ciphertext: '76512156a34105fa6473ad040c666ae7b917d14c06543accc0d2dc28e6073b12',\r\n *     cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\r\n *     cipher: 'aes-128-ctr',\r\n *     kdf: 'pbkdf2',\r\n *     kdfparams: {\r\n *       dklen: 32,\r\n *       salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\r\n *       c: 262144,\r\n *       prf: 'hmac-sha256'\r\n *     },\r\n *   mac: '46eb4884e82dc43b5aa415faba53cc653b7038e9d61cc32fd643cf8c396189b7'\r\n *   }\r\n * }\r\n *```\r\n */\r\nexport const encrypt = async (\r\n\tprivateKey: Bytes,\r\n\tpassword: string | Uint8Array,\r\n\toptions?: CipherOptions,\r\n): Promise<KeyStore> => {\r\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\r\n\r\n\t// if given salt or iv is a string, convert it to a Uint8Array\r\n\tlet salt;\r\n\tif (options?.salt) {\r\n\t\tsalt = typeof options.salt === 'string' ? hexToBytes(options.salt) : options.salt;\r\n\t} else {\r\n\t\tsalt = randomBytes(32);\r\n\t}\r\n\r\n\tif (!(isString(password) || password instanceof Uint8Array)) {\r\n\t\tthrow new InvalidPasswordError();\r\n\t}\r\n\r\n\tconst uint8ArrayPassword =\r\n\t\ttypeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\r\n\r\n\tlet initializationVector;\r\n\tif (options?.iv) {\r\n\t\tinitializationVector = typeof options.iv === 'string' ? hexToBytes(options.iv) : options.iv;\r\n\t\tif (initializationVector.length !== 16) {\r\n\t\t\tthrow new IVLengthError();\r\n\t\t}\r\n\t} else {\r\n\t\tinitializationVector = randomBytes(16);\r\n\t}\r\n\r\n\tconst kdf = options?.kdf ?? 'scrypt';\r\n\r\n\tlet derivedKey;\r\n\tlet kdfparams: ScryptParams | PBKDF2SHA256Params;\r\n\r\n\t// derive key from key derivation function\r\n\tif (kdf === 'pbkdf2') {\r\n\t\tkdfparams = {\r\n\t\t\tdklen: options?.dklen ?? 32,\r\n\t\t\tsalt: bytesToHex(salt).replace('0x', ''),\r\n\t\t\tc: options?.c ?? 262144,\r\n\t\t\tprf: 'hmac-sha256',\r\n\t\t};\r\n\r\n\t\tif (kdfparams.c < 1000) {\r\n\t\t\t// error when c < 1000, pbkdf2 is less secure with less iterations\r\n\t\t\tthrow new PBKDF2IterationsError();\r\n\t\t}\r\n\t\tderivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, 'sha256');\r\n\t} else if (kdf === 'scrypt') {\r\n\t\tkdfparams = {\r\n\t\t\tn: options?.n ?? 8192,\r\n\t\t\tr: options?.r ?? 8,\r\n\t\t\tp: options?.p ?? 1,\r\n\t\t\tdklen: options?.dklen ?? 32,\r\n\t\t\tsalt: bytesToHex(salt).replace('0x', ''),\r\n\t\t};\r\n\t\tderivedKey = scryptSync(\r\n\t\t\tuint8ArrayPassword,\r\n\t\t\tsalt,\r\n\t\t\tkdfparams.n,\r\n\t\t\tkdfparams.p,\r\n\t\t\tkdfparams.r,\r\n\t\t\tkdfparams.dklen,\r\n\t\t);\r\n\t} else {\r\n\t\tthrow new InvalidKdfError();\r\n\t}\r\n\r\n\tconst cipher = await createCipheriv(\r\n\t\tprivateKeyUint8Array,\r\n\t\tderivedKey.slice(0, 16),\r\n\t\tinitializationVector,\r\n\t\t'aes-128-ctr',\r\n\t);\r\n\r\n\tconst ciphertext = bytesToHex(cipher).slice(2);\r\n\r\n\tconst mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace('0x', '');\r\n\treturn {\r\n\t\tversion: 3,\r\n\t\tid: uuidV4(),\r\n\t\taddress: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace('0x', ''),\r\n\t\tcrypto: {\r\n\t\t\tciphertext,\r\n\t\t\tcipherparams: {\r\n\t\t\t\tiv: bytesToHex(initializationVector).replace('0x', ''),\r\n\t\t\t},\r\n\t\t\tcipher: 'aes-128-ctr',\r\n\t\t\tkdf,\r\n\t\t\tkdfparams,\r\n\t\t\tmac,\r\n\t\t},\r\n\t};\r\n};\r\n\r\n/**\r\n * Get an Account object from the privateKey\r\n *\r\n * @param privateKey - String or Uint8Array of 32 bytes\r\n * @param ignoreLength - if true, will not error check length\r\n * @returns A Web3Account object\r\n *\r\n * The `Web3Account.signTransaction` is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\r\n * Use {@link Web3.eth.accounts.signTransaction} instead.\r\n *\r\n * ```ts\r\n * privateKeyToAccount(\"0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709\");\r\n * >    {\r\n * \t\t\taddress: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\r\n * \t\t\tprivateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\r\n * \t\t\tsign,\r\n * \t\t\tsignTransaction,\r\n * \t\t\tencrypt,\r\n * \t}\r\n * ```\r\n */\r\nexport const privateKeyToAccount = (privateKey: Bytes, ignoreLength?: boolean): Web3Account => {\r\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);\r\n\r\n\treturn {\r\n\t\taddress: privateKeyToAddress(privateKeyUint8Array),\r\n\t\tprivateKey: bytesToHex(privateKeyUint8Array),\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\t\tsignTransaction: (_tx: Transaction) => {\r\n\t\t\tthrow new TransactionSigningError('Do not have network access to sign the transaction');\r\n\t\t},\r\n\t\tsign: (data: Record<string, unknown> | string) =>\r\n\t\t\tsign(typeof data === 'string' ? data : JSON.stringify(data), privateKeyUint8Array),\r\n\t\tencrypt: async (password: string, options?: Record<string, unknown>) =>\r\n\t\t\tencrypt(privateKeyUint8Array, password, options),\r\n\t};\r\n};\r\n\r\n/**\r\n *\r\n * Generates and returns a Web3Account object that includes the private and public key\r\n * For creation of private key, it uses an audited package ethereum-cryptography/secp256k1\r\n * that is cryptographically secure random number with certain characteristics.\r\n * Read more: https://www.npmjs.com/package/ethereum-cryptography#secp256k1-curve\r\n *\r\n * @returns A Web3Account object\r\n * ```ts\r\n * web3.eth.accounts.create();\r\n * {\r\n * address: '0xbD504f977021b5E5DdccD8741A368b147B3B38bB',\r\n * privateKey: '0x964ced1c69ad27a311c432fdc0d8211e987595f7eb34ab405a5f16bdc9563ec5',\r\n * signTransaction: [Function: signTransaction],\r\n * sign: [Function: sign],\r\n * encrypt: [AsyncFunction: encrypt]\r\n * }\r\n * ```\r\n */\r\nexport const create = (): Web3Account => {\r\n\tconst privateKey = secp256k1.utils.randomPrivateKey();\r\n\r\n\treturn privateKeyToAccount(`${bytesToHex(privateKey)}`);\r\n};\r\n\r\n/**\r\n * Decrypts a v3 keystore JSON, and creates the account.\r\n *\r\n * @param keystore - the encrypted Keystore object or string to decrypt\r\n * @param password - The password that was used for encryption\r\n * @param nonStrict - if true and given a json string, the keystore will be parsed as lowercase.\r\n * @returns Returns the decrypted Web3Account object\r\n * Decrypting scrypt\r\n *\r\n * ```ts\r\n * decrypt({\r\n *   version: 3,\r\n *   id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\r\n *   address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\r\n *   crypto: {\r\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\r\n *      cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\r\n *      cipher: 'aes-128-ctr',\r\n *      kdf: 'scrypt',\r\n *      kdfparams: {\r\n *        n: 8192,\r\n *        r: 8,\r\n *        p: 1,\r\n *        dklen: 32,\r\n *        salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\r\n *      },\r\n *      mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\r\n *    }\r\n *   }, '123').then(console.log)\r\n * > {\r\n * address: '0xcdA9A91875fc35c8Ac1320E098e584495d66e47c',\r\n * privateKey: '67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\r\n * signTransaction: [Function: signTransaction],\r\n * sign: [Function: sign],\r\n * encrypt: [AsyncFunction: encrypt]\r\n * }\r\n * ```\r\n */\r\nexport const decrypt = async (\r\n\tkeystore: KeyStore | string,\r\n\tpassword: string | Uint8Array,\r\n\tnonStrict?: boolean,\r\n): Promise<Web3Account> => {\r\n\tconst json =\r\n\t\ttypeof keystore === 'object'\r\n\t\t\t? keystore\r\n\t\t\t: (JSON.parse(nonStrict ? keystore.toLowerCase() : keystore) as KeyStore);\r\n\r\n\tvalidator.validateJSONSchema(keyStoreSchema, json);\r\n\r\n\tif (json.version !== 3) throw new KeyStoreVersionError();\r\n\r\n\tconst uint8ArrayPassword =\r\n\t\ttypeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\r\n\r\n\tvalidator.validate(['bytes'], [uint8ArrayPassword]);\r\n\r\n\tlet derivedKey;\r\n\tif (json.crypto.kdf === 'scrypt') {\r\n\t\tconst kdfparams = json.crypto.kdfparams as ScryptParams;\r\n\t\tconst uint8ArraySalt =\r\n\t\t\ttypeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\r\n\t\tderivedKey = scryptSync(\r\n\t\t\tuint8ArrayPassword,\r\n\t\t\tuint8ArraySalt,\r\n\t\t\tkdfparams.n,\r\n\t\t\tkdfparams.p,\r\n\t\t\tkdfparams.r,\r\n\t\t\tkdfparams.dklen,\r\n\t\t);\r\n\t} else if (json.crypto.kdf === 'pbkdf2') {\r\n\t\tconst kdfparams: PBKDF2SHA256Params = json.crypto.kdfparams as PBKDF2SHA256Params;\r\n\r\n\t\tconst uint8ArraySalt =\r\n\t\t\ttypeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\r\n\r\n\t\tderivedKey = pbkdf2Sync(\r\n\t\t\tuint8ArrayPassword,\r\n\t\t\tuint8ArraySalt,\r\n\t\t\tkdfparams.c,\r\n\t\t\tkdfparams.dklen,\r\n\t\t\t'sha256',\r\n\t\t);\r\n\t} else {\r\n\t\tthrow new InvalidKdfError();\r\n\t}\r\n\r\n\tconst ciphertext = hexToBytes(json.crypto.ciphertext);\r\n\tconst mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace('0x', '');\r\n\r\n\tif (mac !== json.crypto.mac) {\r\n\t\tthrow new KeyDerivationError();\r\n\t}\r\n\r\n\tconst seed = await createDecipheriv(\r\n\t\thexToBytes(json.crypto.ciphertext),\r\n\t\tderivedKey.slice(0, 16),\r\n\t\thexToBytes(json.crypto.cipherparams.iv),\r\n\t);\r\n\r\n\treturn privateKeyToAccount(seed);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Web3Context, Web3ConfigEvent } from 'web3-core';\nimport { ContractExecutionError, ContractTransactionDataAndInputError, SubscriptionError, Web3ContractError } from 'web3-errors';\nimport { createAccessList, call, estimateGas, getLogs, NewHeadsSubscription, sendTransaction } from 'web3-eth';\nimport { encodeEventSignature, encodeFunctionSignature, decodeContractErrorData, isAbiErrorFragment, isAbiEventFragment, isAbiFunctionFragment, jsonInterfaceMethodToString } from 'web3-eth-abi';\nimport { BlockTags, DEFAULT_RETURN_FORMAT } from 'web3-types';\nimport { format, isDataFormat, keccak256, toChecksumAddress } from 'web3-utils';\nimport { isNullish, validator, utils as validatorUtils, Web3ValidatorError } from 'web3-validator';\nimport { ALL_EVENTS_ABI } from './constants.js';\nimport { decodeEventABI, decodeMethodReturn, encodeEventABI, encodeMethodABI } from './encoding.js';\nimport { LogsSubscription } from './log_subscription.js';\nimport { getCreateAccessListParams, getEstimateGasParams, getEthTxCallParams, getSendTxParams, isContractInitOptions, isWeb3ContractContext } from './utils.js';\nconst contractSubscriptions = {\n  logs: LogsSubscription,\n  newHeads: NewHeadsSubscription,\n  newBlockHeaders: NewHeadsSubscription\n};\n/**\r\n * The class designed to interact with smart contracts on the Ethereum blockchain.\r\n */\nexport class Contract extends Web3Context {\n  constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {\n    var _a, _b, _c;\n    // eslint-disable-next-line no-nested-ternary\n    const options = isContractInitOptions(addressOrOptionsOrContext) ? addressOrOptionsOrContext : isContractInitOptions(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : undefined;\n    if (!isNullish(options) && !isNullish(options.data) && !isNullish(options.input)) throw new ContractTransactionDataAndInputError({\n      data: options.data,\n      input: options.input\n    });\n    let contractContext;\n    if (isWeb3ContractContext(addressOrOptionsOrContext)) {\n      contractContext = addressOrOptionsOrContext;\n    } else if (isWeb3ContractContext(optionsOrContextOrReturnFormat)) {\n      contractContext = optionsOrContextOrReturnFormat;\n    } else {\n      contractContext = contextOrReturnFormat;\n    }\n    let provider;\n    if (typeof addressOrOptionsOrContext === 'object' && 'provider' in addressOrOptionsOrContext) {\n      provider = addressOrOptionsOrContext.provider;\n    } else if (typeof optionsOrContextOrReturnFormat === 'object' && 'provider' in optionsOrContextOrReturnFormat) {\n      provider = optionsOrContextOrReturnFormat.provider;\n    } else if (typeof contextOrReturnFormat === 'object' && 'provider' in contextOrReturnFormat) {\n      provider = contextOrReturnFormat.provider;\n    } else {\n      provider = Contract.givenProvider;\n    }\n    super(Object.assign(Object.assign({}, contractContext), {\n      provider,\n      registeredSubscriptions: contractSubscriptions\n    }));\n    /**\r\n     * Set to true if you want contracts' defaults to sync with global defaults.\r\n     */\n    this.syncWithContext = false;\n    this._functions = {};\n    this._overloadedMethodAbis = new Map();\n    // eslint-disable-next-line no-nested-ternary\n    const returnDataFormat = isDataFormat(contextOrReturnFormat) ? contextOrReturnFormat : isDataFormat(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : returnFormat !== null && returnFormat !== void 0 ? returnFormat : DEFAULT_RETURN_FORMAT;\n    const address = typeof addressOrOptionsOrContext === 'string' ? addressOrOptionsOrContext : undefined;\n    this._parseAndSetJsonInterface(jsonInterface, returnDataFormat);\n    if (!isNullish(address)) {\n      this._parseAndSetAddress(address, returnDataFormat);\n    }\n    this.options = {\n      address,\n      jsonInterface: this._jsonInterface,\n      gas: (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.gasLimit,\n      gasPrice: options === null || options === void 0 ? void 0 : options.gasPrice,\n      from: options === null || options === void 0 ? void 0 : options.from,\n      input: (_b = options === null || options === void 0 ? void 0 : options.input) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.data\n    };\n    this.syncWithContext = (_c = options === null || options === void 0 ? void 0 : options.syncWithContext) !== null && _c !== void 0 ? _c : false;\n    if (contractContext instanceof Web3Context) {\n      this.subscribeToContextEvents(contractContext);\n    }\n    Object.defineProperty(this.options, 'address', {\n      set: value => this._parseAndSetAddress(value, returnDataFormat),\n      get: () => this._address\n    });\n    Object.defineProperty(this.options, 'jsonInterface', {\n      set: value => this._parseAndSetJsonInterface(value, returnDataFormat),\n      get: () => this._jsonInterface\n    });\n  }\n  /**\r\n   * Subscribe to an event.\r\n   *\r\n   * ```ts\r\n   * await myContract.events.MyEvent([options])\r\n   * ```\r\n   *\r\n   * There is a special event `allEvents` that can be used to subscribe all events.\r\n   *\r\n   * ```ts\r\n   * await myContract.events.allEvents([options])\r\n   * ```\r\n   *\r\n   * @returns - When individual event is accessed will returns {@link ContractBoundEvent} object\r\n   */\n  get events() {\n    return this._events;\n  }\n  /**\r\n   * Creates a transaction object for that method, which then can be `called`, `send`, `estimated`, `createAccessList` , or `ABI encoded`.\r\n   *\r\n   * The methods of this smart contract are available through:\r\n   *\r\n   * The name: `myContract.methods.myMethod(123)`\r\n   * The name with parameters: `myContract.methods['myMethod(uint256)'](123)`\r\n   * The signature `myContract.methods['0x58cf5f10'](123)`\r\n   *\r\n   * This allows calling functions with same name but different parameters from the JavaScript contract object.\r\n   *\r\n   * \\> The method signature does not provide a type safe interface, so we recommend to use method `name` instead.\r\n   *\r\n   * ```ts\r\n   * // calling a method\r\n   * const result = await myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n   *\r\n   * // or sending and using a promise\r\n   * const receipt = await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n   *\r\n   * // or sending and using the events\r\n   * const sendObject = myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n   * sendObject.on('transactionHash', function(hash){\r\n   *   ...\r\n   * });\r\n   * sendObject.on('receipt', function(receipt){\r\n   *   ...\r\n   * });\r\n   * sendObject.on('confirmation', function(confirmationNumber, receipt){\r\n   *   ...\r\n   * });\r\n   * sendObject.on('error', function(error, receipt) {\r\n   *   ...\r\n   * });\r\n   * ```\r\n   *\r\n   * @returns - Either returns {@link PayableMethodObject} or {@link NonPayableMethodObject} based on the definitions of the {@doclink glossary/json_interface | json interface} of that contract.\r\n   */\n  get methods() {\n    return this._methods;\n  }\n  /**\r\n   * Clones the current contract instance. This doesn't deploy contract on blockchain and only creates a local clone.\r\n   *\r\n   * @returns - The new contract instance.\r\n   *\r\n   * ```ts\r\n   * const contract1 = new eth.Contract(abi, address, {gasPrice: '12345678', from: fromAddress});\r\n   *\r\n   * const contract2 = contract1.clone();\r\n   * contract2.options.address = address2;\r\n   *\r\n   * (contract1.options.address !== contract2.options.address);\r\n   * > true\r\n   * ```\r\n   */\n  clone() {\n    let newContract;\n    if (this.options.address) {\n      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], this.options.address, {\n        gas: this.options.gas,\n        gasPrice: this.options.gasPrice,\n        from: this.options.from,\n        input: this.options.input,\n        provider: this.currentProvider,\n        syncWithContext: this.syncWithContext\n      }, this.getContextObject());\n    } else {\n      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], {\n        gas: this.options.gas,\n        gasPrice: this.options.gasPrice,\n        from: this.options.from,\n        input: this.options.input,\n        provider: this.currentProvider,\n        syncWithContext: this.syncWithContext\n      }, this.getContextObject());\n    }\n    if (this.context) newContract.subscribeToContextEvents(this.context);\n    return newContract;\n  }\n  /**\r\n   * Call this function to deploy the contract to the blockchain. After successful deployment the promise will resolve with a new contract instance.\r\n   *\r\n   * ```ts\r\n   * myContract.deploy({\r\n   *   input: '0x12345...', // data keyword can be used, too. If input is used, data will be ignored.\r\n   *   arguments: [123, 'My String']\r\n   * })\r\n   * .send({\r\n   *   from: '0x1234567890123456789012345678901234567891',\r\n   *   gas: 1500000,\r\n   *   gasPrice: '30000000000000'\r\n   * }, function(error, transactionHash){ ... })\r\n   * .on('error', function(error){ ... })\r\n   * .on('transactionHash', function(transactionHash){ ... })\r\n   * .on('receipt', function(receipt){\r\n   *  console.log(receipt.contractAddress) // contains the new contract address\r\n   * })\r\n   * .on('confirmation', function(confirmationNumber, receipt){ ... })\r\n   * .then(function(newContractInstance){\r\n   *   console.log(newContractInstance.options.address) // instance with the new contract address\r\n   * });\r\n   *\r\n   *\r\n   * // When the data is already set as an option to the contract itself\r\n   * myContract.options.data = '0x12345...';\r\n   *\r\n   * myContract.deploy({\r\n   *   arguments: [123, 'My String']\r\n   * })\r\n   * .send({\r\n   *   from: '0x1234567890123456789012345678901234567891',\r\n   *   gas: 1500000,\r\n   *   gasPrice: '30000000000000'\r\n   * })\r\n   * .then(function(newContractInstance){\r\n   *   console.log(newContractInstance.options.address) // instance with the new contract address\r\n   * });\r\n   *\r\n   *\r\n   * // Simply encoding\r\n   * myContract.deploy({\r\n   *   input: '0x12345...',\r\n   *   arguments: [123, 'My String']\r\n   * })\r\n   * .encodeABI();\r\n   * > '0x12345...0000012345678765432'\r\n   *\r\n   *\r\n   * // Gas estimation\r\n   * myContract.deploy({\r\n   *   input: '0x12345...',\r\n   *   arguments: [123, 'My String']\r\n   * })\r\n   * .estimateGas(function(err, gas){\r\n   *   console.log(gas);\r\n   * });\r\n   * ```\r\n   *\r\n   * @returns - The transaction object\r\n   */\n  deploy(deployOptions) {\n    var _this = this;\n    var _a, _b, _c;\n    let abi = this._jsonInterface.find(j => j.type === 'constructor');\n    if (!abi) {\n      abi = {\n        type: 'constructor',\n        inputs: [],\n        stateMutability: ''\n      };\n    }\n    const _input = format({\n      format: 'bytes'\n    }, (_b = (_a = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.input) !== null && _a !== void 0 ? _a : deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.data) !== null && _b !== void 0 ? _b : this.options.input, DEFAULT_RETURN_FORMAT);\n    if (!_input || _input.trim() === '0x') {\n      throw new Web3ContractError('contract creation without any data provided.');\n    }\n    const args = (_c = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.arguments) !== null && _c !== void 0 ? _c : [];\n    const contractOptions = Object.assign(Object.assign({}, this.options), {\n      input: _input\n    });\n    return {\n      arguments: args,\n      send: options => {\n        const modifiedOptions = Object.assign({}, options);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this._contractMethodDeploySend(abi, args, modifiedOptions, contractOptions);\n      },\n      estimateGas: function (options) {\n        let returnFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RETURN_FORMAT;\n        return __awaiter(_this, void 0, void 0, function* () {\n          const modifiedOptions = Object.assign({}, options);\n          return this._contractMethodEstimateGas({\n            abi: abi,\n            params: args,\n            returnFormat,\n            options: modifiedOptions,\n            contractOptions\n          });\n        });\n      },\n      encodeABI: () => encodeMethodABI(abi, args, format({\n        format: 'bytes'\n      }, _input, DEFAULT_RETURN_FORMAT))\n    };\n  }\n  getPastEvents(param1, param2, param3) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const eventName = typeof param1 === 'string' ? param1 : 'allEvents';\n      const options =\n      // eslint-disable-next-line no-nested-ternary\n      typeof param1 !== 'string' && !isDataFormat(param1) ? param1 : !isDataFormat(param2) ? param2 : {};\n      // eslint-disable-next-line no-nested-ternary\n      const returnFormat = isDataFormat(param1) ? param1 : isDataFormat(param2) ? param2 : param3 !== null && param3 !== void 0 ? param3 : DEFAULT_RETURN_FORMAT;\n      const abi = eventName === 'allEvents' ? ALL_EVENTS_ABI : this._jsonInterface.find(j => 'name' in j && j.name === eventName);\n      if (!abi) {\n        throw new Web3ContractError(`Event ${eventName} not found.`);\n      }\n      const {\n        fromBlock,\n        toBlock,\n        topics,\n        address\n      } = encodeEventABI(this.options, abi, options !== null && options !== void 0 ? options : {});\n      const logs = yield getLogs(this, {\n        fromBlock,\n        toBlock,\n        topics,\n        address\n      }, returnFormat);\n      const decodedLogs = logs.map(log => typeof log === 'string' ? log : decodeEventABI(abi, log, this._jsonInterface, returnFormat));\n      const filter = (_a = options === null || options === void 0 ? void 0 : options.filter) !== null && _a !== void 0 ? _a : {};\n      const filterKeys = Object.keys(filter);\n      if (filterKeys.length > 0) {\n        return decodedLogs.filter(log => {\n          if (typeof log === 'string') return true;\n          return filterKeys.every(key => {\n            var _a;\n            if (Array.isArray(filter[key])) {\n              return filter[key].some(v => String(log.returnValues[key]).toUpperCase() === String(v).toUpperCase());\n            }\n            const inputAbi = (_a = abi.inputs) === null || _a === void 0 ? void 0 : _a.filter(input => input.name === key)[0];\n            if ((inputAbi === null || inputAbi === void 0 ? void 0 : inputAbi.indexed) && inputAbi.type === 'string') {\n              const hashedIndexedString = keccak256(filter[key]);\n              if (hashedIndexedString === String(log.returnValues[key])) return true;\n            }\n            return String(log.returnValues[key]).toUpperCase() === String(filter[key]).toUpperCase();\n          });\n        });\n      }\n      return decodedLogs;\n    });\n  }\n  _parseAndSetAddress(value) {\n    let returnFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RETURN_FORMAT;\n    this._address = value ? toChecksumAddress(format({\n      format: 'address'\n    }, value, returnFormat)) : value;\n  }\n  _parseAndSetJsonInterface(abis) {\n    let returnFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RETURN_FORMAT;\n    var _a, _b, _c, _d, _e;\n    this._functions = {};\n    this._methods = {};\n    this._events = {};\n    let result = [];\n    const functionsAbi = abis.filter(abi => abi.type !== 'error');\n    const errorsAbi = abis.filter(abi => isAbiErrorFragment(abi));\n    for (const a of functionsAbi) {\n      const abi = Object.assign(Object.assign({}, a), {\n        signature: ''\n      });\n      if (isAbiFunctionFragment(abi)) {\n        const methodName = jsonInterfaceMethodToString(abi);\n        const methodSignature = encodeFunctionSignature(methodName);\n        abi.signature = methodSignature;\n        // make constant and payable backwards compatible\n        abi.constant = (_b = (_a = abi.stateMutability === 'view') !== null && _a !== void 0 ? _a : abi.stateMutability === 'pure') !== null && _b !== void 0 ? _b : abi.constant;\n        abi.payable = (_c = abi.stateMutability === 'payable') !== null && _c !== void 0 ? _c : abi.payable;\n        this._overloadedMethodAbis.set(abi.name, [...((_d = this._overloadedMethodAbis.get(abi.name)) !== null && _d !== void 0 ? _d : []), abi]);\n        const abiFragment = (_e = this._overloadedMethodAbis.get(abi.name)) !== null && _e !== void 0 ? _e : [];\n        const contractMethod = this._createContractMethod(abiFragment, errorsAbi);\n        this._functions[methodName] = {\n          signature: methodSignature,\n          method: contractMethod\n        };\n        // We don't know a particular type of the Abi method so can't type check\n        this._methods[abi.name] = this._functions[methodName].method;\n        // We don't know a particular type of the Abi method so can't type check\n        this._methods[methodName] = this._functions[methodName].method;\n        // We don't know a particular type of the Abi method so can't type check\n        this._methods[methodSignature] = this._functions[methodName].method;\n      } else if (isAbiEventFragment(abi)) {\n        const eventName = jsonInterfaceMethodToString(abi);\n        const eventSignature = encodeEventSignature(eventName);\n        const event = this._createContractEvent(abi, returnFormat);\n        abi.signature = eventSignature;\n        if (!(eventName in this._events) || abi.name === 'bound') {\n          // It's a private type and we don't want to expose it and no need to check\n          this._events[eventName] = event;\n        }\n        // It's a private type and we don't want to expose it and no need to check\n        this._events[abi.name] = event;\n        // It's a private type and we don't want to expose it and no need to check\n        this._events[eventSignature] = event;\n      }\n      this._events.allEvents = this._createContractEvent(ALL_EVENTS_ABI, returnFormat);\n      result = [...result, abi];\n    }\n    this._jsonInterface = [...result];\n    this._errorsInterface = errorsAbi;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _getAbiParams(abi, params) {\n    var _a;\n    try {\n      return validatorUtils.transformJsonDataToAbiFormat((_a = abi.inputs) !== null && _a !== void 0 ? _a : [], params);\n    } catch (error) {\n      throw new Web3ContractError(`Invalid parameters for method ${abi.name}: ${error.message}`);\n    }\n  }\n  _createContractMethod(abiArr, errorsAbis) {\n    var _this2 = this;\n    const abi = abiArr[abiArr.length - 1];\n    return function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      var _a, _b;\n      let abiParams;\n      const abis = (_a = _this2._overloadedMethodAbis.get(abi.name)) !== null && _a !== void 0 ? _a : [];\n      let methodAbi = abis[0];\n      const internalErrorsAbis = errorsAbis;\n      const arrayOfAbis = abis.filter(_abi => {\n        var _a;\n        return ((_a = _abi.inputs) !== null && _a !== void 0 ? _a : []).length === params.length;\n      });\n      if (abis.length === 1 || arrayOfAbis.length === 0) {\n        abiParams = _this2._getAbiParams(methodAbi, params);\n        validator.validate((_b = abi.inputs) !== null && _b !== void 0 ? _b : [], abiParams);\n      } else {\n        const errors = [];\n        for (const _abi of arrayOfAbis) {\n          try {\n            abiParams = _this2._getAbiParams(_abi, params);\n            validator.validate(_abi.inputs, abiParams);\n            methodAbi = _abi;\n            break;\n          } catch (e) {\n            errors.push(e);\n          }\n        }\n        if (errors.length === arrayOfAbis.length) {\n          throw new Web3ValidatorError(errors);\n        }\n      }\n      const methods = {\n        arguments: abiParams,\n        call: (options, block) => __awaiter(_this2, void 0, void 0, function* () {\n          return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block);\n        }),\n        send: options => _this2._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),\n        estimateGas: function (options) {\n          let returnFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RETURN_FORMAT;\n          return __awaiter(_this2, void 0, void 0, function* () {\n            return this._contractMethodEstimateGas({\n              abi: methodAbi,\n              params: abiParams,\n              returnFormat,\n              options\n            });\n          });\n        },\n        encodeABI: () => encodeMethodABI(methodAbi, abiParams),\n        createAccessList: (options, block) => __awaiter(_this2, void 0, void 0, function* () {\n          return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block);\n        })\n      };\n      if (methodAbi.stateMutability === 'payable') {\n        return methods;\n      }\n      return methods;\n    };\n  }\n  _contractMethodCall(abi, params, errorsAbi, options, block) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = getEthTxCallParams({\n        abi,\n        params,\n        options,\n        contractOptions: Object.assign(Object.assign({}, this.options), {\n          from: (_a = this.options.from) !== null && _a !== void 0 ? _a : this.config.defaultAccount\n        })\n      });\n      try {\n        const result = yield call(this, tx, block, DEFAULT_RETURN_FORMAT);\n        return decodeMethodReturn(abi, result);\n      } catch (error) {\n        if (error instanceof ContractExecutionError) {\n          // this will parse the error data by trying to decode the ABI error inputs according to EIP-838\n          decodeContractErrorData(errorsAbi, error.innerError);\n        }\n        throw error;\n      }\n    });\n  }\n  _contractMethodCreateAccessList(abi, params, errorsAbi, options, block) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = getCreateAccessListParams({\n        abi,\n        params,\n        options,\n        contractOptions: Object.assign(Object.assign({}, this.options), {\n          from: (_a = this.options.from) !== null && _a !== void 0 ? _a : this.config.defaultAccount\n        })\n      });\n      try {\n        return createAccessList(this, tx, block, DEFAULT_RETURN_FORMAT);\n      } catch (error) {\n        if (error instanceof ContractExecutionError) {\n          // this will parse the error data by trying to decode the ABI error inputs according to EIP-838\n          decodeContractErrorData(errorsAbi, error.innerError);\n        }\n        throw error;\n      }\n    });\n  }\n  _contractMethodSend(abi, params, errorsAbi, options, contractOptions) {\n    var _a, _b;\n    let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;\n    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), {\n      input: undefined,\n      from: (_b = (_a = modifiedContractOptions.from) !== null && _a !== void 0 ? _a : this.defaultAccount) !== null && _b !== void 0 ? _b : undefined\n    });\n    const tx = getSendTxParams({\n      abi,\n      params,\n      options,\n      contractOptions: modifiedContractOptions\n    });\n    const transactionToSend = sendTransaction(this, tx, DEFAULT_RETURN_FORMAT, {\n      // TODO Should make this configurable by the user\n      checkRevertBeforeSending: false\n    });\n    // eslint-disable-next-line no-void\n    void transactionToSend.on('error', error => {\n      if (error instanceof ContractExecutionError) {\n        // this will parse the error data by trying to decode the ABI error inputs according to EIP-838\n        decodeContractErrorData(errorsAbi, error.innerError);\n      }\n    });\n    return transactionToSend;\n  }\n  _contractMethodDeploySend(abi, params, options, contractOptions) {\n    var _a, _b;\n    let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;\n    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), {\n      from: (_b = (_a = modifiedContractOptions.from) !== null && _a !== void 0 ? _a : this.defaultAccount) !== null && _b !== void 0 ? _b : undefined\n    });\n    const tx = getSendTxParams({\n      abi,\n      params,\n      options,\n      contractOptions: modifiedContractOptions\n    });\n    return sendTransaction(this, tx, DEFAULT_RETURN_FORMAT, {\n      transactionResolver: receipt => {\n        if (receipt.status === BigInt(0)) {\n          throw new Web3ContractError(\"code couldn't be stored\", receipt);\n        }\n        const newContract = this.clone();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        newContract.options.address = receipt.contractAddress;\n        return newContract;\n      },\n      // TODO Should make this configurable by the user\n      checkRevertBeforeSending: false\n    });\n  }\n  _contractMethodEstimateGas(_ref) {\n    let {\n      abi,\n      params,\n      returnFormat,\n      options,\n      contractOptions\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = getEstimateGasParams({\n        abi,\n        params,\n        options,\n        contractOptions: contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options\n      });\n      return estimateGas(this, tx, BlockTags.LATEST, returnFormat);\n    });\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _createContractEvent(abi) {\n    var _this3 = this;\n    let returnFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RETURN_FORMAT;\n    return function () {\n      var _a;\n      const {\n        topics,\n        fromBlock\n      } = encodeEventABI(_this3.options, abi, arguments.length <= 0 ? undefined : arguments[0]);\n      const sub = new LogsSubscription({\n        address: _this3.options.address,\n        topics,\n        abi,\n        jsonInterface: _this3._jsonInterface\n      }, {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        subscriptionManager: _this3.subscriptionManager,\n        returnFormat\n      });\n      if (!isNullish(fromBlock)) {\n        // emit past events when fromBlock is defined\n        _this3.getPastEvents(abi.name, {\n          fromBlock,\n          topics\n        }, returnFormat).then(logs => {\n          logs.forEach(log => sub.emit('data', log));\n        }).catch(() => {\n          sub.emit('error', new SubscriptionError('Failed to get past events.'));\n        });\n      }\n      (_a = _this3.subscriptionManager) === null || _a === void 0 ? void 0 : _a.addSubscription(sub).catch(() => {\n        sub.emit('error', new SubscriptionError('Failed to subscribe.'));\n      });\n      return sub;\n    };\n  }\n  subscribeToContextEvents(context) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const contractThis = this;\n    this.context = context;\n    if (contractThis.syncWithContext) {\n      context.on(Web3ConfigEvent.CONFIG_CHANGE, event => {\n        contractThis.setConfig({\n          [event.name]: event.newValue\n        });\n      });\n    }\n  }\n}","map":{"version":3,"names":["Web3Context","Web3ConfigEvent","ContractExecutionError","ContractTransactionDataAndInputError","SubscriptionError","Web3ContractError","createAccessList","call","estimateGas","getLogs","NewHeadsSubscription","sendTransaction","encodeEventSignature","encodeFunctionSignature","decodeContractErrorData","isAbiErrorFragment","isAbiEventFragment","isAbiFunctionFragment","jsonInterfaceMethodToString","BlockTags","DEFAULT_RETURN_FORMAT","format","isDataFormat","keccak256","toChecksumAddress","isNullish","validator","utils","validatorUtils","Web3ValidatorError","ALL_EVENTS_ABI","decodeEventABI","decodeMethodReturn","encodeEventABI","encodeMethodABI","LogsSubscription","getCreateAccessListParams","getEstimateGasParams","getEthTxCallParams","getSendTxParams","isContractInitOptions","isWeb3ContractContext","contractSubscriptions","logs","newHeads","newBlockHeaders","Contract","constructor","jsonInterface","addressOrOptionsOrContext","optionsOrContextOrReturnFormat","contextOrReturnFormat","returnFormat","options","undefined","data","input","contractContext","provider","givenProvider","Object","assign","registeredSubscriptions","syncWithContext","_functions","_overloadedMethodAbis","Map","returnDataFormat","address","_parseAndSetJsonInterface","_parseAndSetAddress","_jsonInterface","gas","_a","gasLimit","gasPrice","from","_b","_c","subscribeToContextEvents","defineProperty","set","value","get","_address","events","_events","methods","_methods","clone","newContract","_errorsInterface","currentProvider","getContextObject","context","deploy","deployOptions","_this","abi","find","j","type","inputs","stateMutability","_input","trim","args","arguments","contractOptions","send","modifiedOptions","_contractMethodDeploySend","length","__awaiter","_contractMethodEstimateGas","params","encodeABI","getPastEvents","param1","param2","param3","eventName","name","fromBlock","toBlock","topics","decodedLogs","map","log","filter","filterKeys","keys","every","key","Array","isArray","some","v","String","returnValues","toUpperCase","inputAbi","indexed","hashedIndexedString","abis","result","functionsAbi","errorsAbi","a","signature","methodName","methodSignature","constant","payable","_d","abiFragment","_e","contractMethod","_createContractMethod","method","eventSignature","event","_createContractEvent","allEvents","_getAbiParams","transformJsonDataToAbiFormat","error","message","abiArr","errorsAbis","_this2","_len","_key","abiParams","methodAbi","internalErrorsAbis","arrayOfAbis","_abi","validate","errors","e","push","block","_contractMethodCall","_contractMethodSend","_contractMethodCreateAccessList","tx","config","defaultAccount","innerError","modifiedContractOptions","transactionToSend","checkRevertBeforeSending","on","transactionResolver","receipt","status","BigInt","contractAddress","_ref","LATEST","_this3","sub","subscriptionManager","then","forEach","emit","catch","addSubscription","contractThis","CONFIG_CHANGE","setConfig","newValue"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-eth-contract\\src\\contract.ts"],"sourcesContent":["﻿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport {\r\n\tWeb3Context,\r\n\tWeb3EventEmitter,\r\n\tWeb3PromiEvent,\r\n\tWeb3ConfigEvent,\r\n\tWeb3SubscriptionManager,\r\n} from 'web3-core';\r\nimport {\r\n\tContractExecutionError,\r\n\tContractTransactionDataAndInputError,\r\n\tSubscriptionError,\r\n\tWeb3ContractError,\r\n} from 'web3-errors';\r\nimport {\r\n\tcreateAccessList,\r\n\tcall,\r\n\testimateGas,\r\n\tgetLogs,\r\n\tNewHeadsSubscription,\r\n\tsendTransaction,\r\n\tSendTransactionEvents,\r\n} from 'web3-eth';\r\nimport {\r\n\tencodeEventSignature,\r\n\tencodeFunctionSignature,\r\n\tdecodeContractErrorData,\r\n\tisAbiErrorFragment,\r\n\tisAbiEventFragment,\r\n\tisAbiFunctionFragment,\r\n\tjsonInterfaceMethodToString,\r\n} from 'web3-eth-abi';\r\nimport {\r\n\tAbiConstructorFragment,\r\n\tAbiErrorFragment,\r\n\tAbiEventFragment,\r\n\tAbiFragment,\r\n\tAbiFunctionFragment,\r\n\tContractAbi,\r\n\tContractConstructorArgs,\r\n\tContractEvent,\r\n\tContractEvents,\r\n\tContractMethod,\r\n\tContractMethodInputParameters,\r\n\tContractMethodOutputParameters,\r\n\tAddress,\r\n\tBlockNumberOrTag,\r\n\tBlockTags,\r\n\tBytes,\r\n\tEthExecutionAPI,\r\n\tFilter,\r\n\tFilterAbis,\r\n\tHexString,\r\n\tLogsInput,\r\n\tMutable,\r\n\tContractInitOptions,\r\n\tNonPayableCallOptions,\r\n\tPayableCallOptions,\r\n\tDataFormat,\r\n\tDEFAULT_RETURN_FORMAT,\r\n\tNumbers,\r\n\tWeb3ValidationErrorObject,\r\n} from 'web3-types';\r\nimport { format, isDataFormat, keccak256, toChecksumAddress } from 'web3-utils';\r\nimport {\r\n\tisNullish,\r\n\tvalidator,\r\n\tutils as validatorUtils,\r\n\tValidationSchemaInput,\r\n\tWeb3ValidatorError,\r\n} from 'web3-validator';\r\nimport { ALL_EVENTS_ABI } from './constants.js';\r\nimport { decodeEventABI, decodeMethodReturn, encodeEventABI, encodeMethodABI } from './encoding.js';\r\nimport { LogsSubscription } from './log_subscription.js';\r\nimport {\r\n\tContractAbiWithSignature,\r\n\tContractEventOptions,\r\n\tContractOptions,\r\n\tEventLog,\r\n\tNonPayableMethodObject,\r\n\tNonPayableTxOptions,\r\n\tPayableMethodObject,\r\n\tPayableTxOptions,\r\n\tWeb3ContractContext,\r\n} from './types.js';\r\nimport {\r\n\tgetCreateAccessListParams,\r\n\tgetEstimateGasParams,\r\n\tgetEthTxCallParams,\r\n\tgetSendTxParams,\r\n\tisContractInitOptions,\r\n\tisWeb3ContractContext,\r\n} from './utils.js';\r\n\r\ntype ContractBoundMethod<\r\n\tAbi extends AbiFunctionFragment,\r\n\tMethod extends ContractMethod<Abi> = ContractMethod<Abi>,\r\n> = (\r\n\t...args: Method['Inputs']\r\n) => Method['Abi']['stateMutability'] extends 'payable' | 'pure'\r\n\t? PayableMethodObject<Method['Inputs'], Method['Outputs']>\r\n\t: NonPayableMethodObject<Method['Inputs'], Method['Outputs']>;\r\n\r\nexport type ContractOverloadedMethodInputs<AbiArr extends ReadonlyArray<unknown>> = NonNullable<\r\n\tAbiArr extends readonly []\r\n\t\t? undefined\r\n\t\t: AbiArr extends readonly [infer A, ...infer R]\r\n\t\t? A extends AbiFunctionFragment\r\n\t\t\t? ContractMethodInputParameters<A['inputs']> | ContractOverloadedMethodInputs<R>\r\n\t\t\t: undefined\r\n\t\t: undefined\r\n>;\r\n\r\nexport type ContractOverloadedMethodOutputs<AbiArr extends ReadonlyArray<unknown>> = NonNullable<\r\n\tAbiArr extends readonly []\r\n\t\t? undefined\r\n\t\t: AbiArr extends readonly [infer A, ...infer R]\r\n\t\t? A extends AbiFunctionFragment\r\n\t\t\t? ContractMethodOutputParameters<A['outputs']> | ContractOverloadedMethodOutputs<R>\r\n\t\t\t: undefined\r\n\t\t: undefined\r\n>;\r\n\r\n// To avoid circular dependency between types and encoding, declared these types here.\r\nexport type ContractMethodsInterface<Abi extends ContractAbi> = {\r\n\t[MethodAbi in FilterAbis<\r\n\t\tAbi,\r\n\t\tAbiFunctionFragment & { type: 'function' }\r\n\t> as MethodAbi['name']]: ContractBoundMethod<MethodAbi>;\r\n\t// To allow users to use method signatures\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n} & { [key: string]: ContractBoundMethod<any> };\r\n\r\n/**\r\n * The event object can be accessed from `myContract.events.myEvent`.\r\n *\r\n * \\> Remember: To subscribe to an event, your provider must have support for subscriptions.\r\n *\r\n * ```ts\r\n * const subscription = await myContract.events.MyEvent([options])\r\n * ```\r\n *\r\n * @param options - The options used to subscribe for the event\r\n * @returns - A Promise resolved with {@link LogsSubscription} object\r\n */\r\nexport type ContractBoundEvent = (options?: ContractEventOptions) => LogsSubscription;\r\n\r\n// To avoid circular dependency between types and encoding, declared these types here.\r\nexport type ContractEventsInterface<\r\n\tAbi extends ContractAbi,\r\n\tEvents extends ContractEvents<Abi> = ContractEvents<Abi>,\r\n> = {\r\n\t[Name in keyof Events | 'allEvents']: ContractBoundEvent;\r\n} & {\r\n\t[key: string]: ContractBoundEvent;\r\n};\r\n\r\n// To avoid circular dependency between types and encoding, declared these types here.\r\nexport type ContractEventEmitterInterface<Abi extends ContractAbi> = {\r\n\t[EventAbi in FilterAbis<\r\n\t\tAbi,\r\n\t\tAbiFunctionFragment & { type: 'event' }\r\n\t> as EventAbi['name']]: ContractEvent<EventAbi>['Inputs'];\r\n};\r\n\r\ntype EventParameters = Parameters<typeof encodeEventABI>[2];\r\n\r\nconst contractSubscriptions = {\r\n\tlogs: LogsSubscription,\r\n\tnewHeads: NewHeadsSubscription,\r\n\tnewBlockHeaders: NewHeadsSubscription,\r\n};\r\n\r\n/**\r\n * The class designed to interact with smart contracts on the Ethereum blockchain.\r\n */\r\nexport class Contract<Abi extends ContractAbi>\r\n\textends Web3Context<EthExecutionAPI, typeof contractSubscriptions>\r\n\timplements Web3EventEmitter<ContractEventEmitterInterface<Abi>>\r\n{\r\n\t/**\r\n\t * The options `object` for the contract instance. `from`, `gas` and `gasPrice` are used as fallback values when sending transactions.\r\n\t *\r\n\t * ```ts\r\n\t * myContract.options;\r\n\t * > {\r\n\t *     address: '0x1234567890123456789012345678901234567891',\r\n\t *     jsonInterface: [...],\r\n\t *     from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe',\r\n\t *     gasPrice: '10000000000000',\r\n\t *     gas: 1000000\r\n\t * }\r\n\t *\r\n\t * myContract.options.from = '0x1234567890123456789012345678901234567891'; // default from address\r\n\t * myContract.options.gasPrice = '20000000000000'; // default gas price in wei\r\n\t * myContract.options.gas = 5000000; // provide as fallback always 5M gas\r\n\t * ```\r\n\t */\r\n\tpublic readonly options: ContractOptions;\r\n\r\n\t/**\r\n\t * Set to true if you want contracts' defaults to sync with global defaults.\r\n\t */\r\n\tpublic syncWithContext = false;\r\n\r\n\tprivate _errorsInterface!: AbiErrorFragment[];\r\n\tprivate _jsonInterface!: ContractAbiWithSignature;\r\n\tprivate _address?: Address;\r\n\tprivate _functions: Record<\r\n\t\tstring,\r\n\t\t{\r\n\t\t\tsignature: string;\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\tmethod: ContractBoundMethod<any>;\r\n\t\t}\r\n\t> = {};\r\n\tprivate readonly _overloadedMethodAbis: Map<string, AbiFunctionFragment[]>;\r\n\tprivate _methods!: ContractMethodsInterface<Abi>;\r\n\tprivate _events!: ContractEventsInterface<Abi>;\r\n\r\n\tprivate context?: Web3Context;\r\n\t/**\r\n\t * Creates a new contract instance with all its methods and events defined in its {@doclink glossary/json_interface | json interface} object.\r\n\t *\r\n\t * ```ts\r\n\t * new web3.eth.Contract(jsonInterface[, address][, options])\r\n\t * ```\r\n\t *\r\n\t * @param jsonInterface - The JSON interface for the contract to instantiate.\r\n\t * @param address - The address of the smart contract to call.\r\n\t * @param options - The options of the contract. Some are used as fallbacks for calls and transactions.\r\n\t * @param context - The context of the contract used for customizing the behavior of the contract.\r\n\t * @returns - The contract instance with all its methods and events.\r\n\t *\r\n\t * ```ts title=\"Example\"\r\n\t * var myContract = new web3.eth.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\r\n\t *   from: '0x1234567890123456789012345678901234567891', // default from address\r\n\t *   gasPrice: '20000000000' // default gas price in wei, 20 gwei in this case\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * To use the type safe interface for these contracts you have to include the ABI definitions in your Typescript project and then declare these as `const`.\r\n\t *\r\n\t * ```ts title=\"Example\"\r\n\t * const myContractAbi = [....] as const; // ABI definitions\r\n\t * const myContract = new web3.eth.Contract(myContractAbi, '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe');\r\n\t * ```\r\n\t */\r\n\tpublic constructor(\r\n\t\tjsonInterface: Abi,\r\n\t\tcontext?: Web3ContractContext | Web3Context,\r\n\t\treturnFormat?: DataFormat,\r\n\t);\r\n\tpublic constructor(\r\n\t\tjsonInterface: Abi,\r\n\t\taddress?: Address,\r\n\t\tcontextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat,\r\n\t\treturnFormat?: DataFormat,\r\n\t);\r\n\tpublic constructor(\r\n\t\tjsonInterface: Abi,\r\n\t\toptions?: ContractInitOptions,\r\n\t\tcontextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat,\r\n\t\treturnFormat?: DataFormat,\r\n\t);\r\n\tpublic constructor(\r\n\t\tjsonInterface: Abi,\r\n\t\taddress: Address | undefined,\r\n\t\toptions: ContractInitOptions,\r\n\t\tcontextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat,\r\n\t\treturnFormat?: DataFormat,\r\n\t);\r\n\tpublic constructor(\r\n\t\tjsonInterface: Abi,\r\n\t\taddressOrOptionsOrContext?:\r\n\t\t\t| Address\r\n\t\t\t| ContractInitOptions\r\n\t\t\t| Web3ContractContext\r\n\t\t\t| Web3Context,\r\n\t\toptionsOrContextOrReturnFormat?:\r\n\t\t\t| ContractInitOptions\r\n\t\t\t| Web3ContractContext\r\n\t\t\t| Web3Context\r\n\t\t\t| DataFormat,\r\n\t\tcontextOrReturnFormat?: Web3ContractContext | Web3Context | DataFormat,\r\n\t\treturnFormat?: DataFormat,\r\n\t) {\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\tconst options = isContractInitOptions(addressOrOptionsOrContext)\r\n\t\t\t? addressOrOptionsOrContext\r\n\t\t\t: isContractInitOptions(optionsOrContextOrReturnFormat)\r\n\t\t\t? optionsOrContextOrReturnFormat\r\n\t\t\t: undefined;\r\n\r\n\t\tif (!isNullish(options) && !isNullish(options.data) && !isNullish(options.input))\r\n\t\t\tthrow new ContractTransactionDataAndInputError({\r\n\t\t\t\tdata: options.data as HexString,\r\n\t\t\t\tinput: options.input as HexString,\r\n\t\t\t});\r\n\r\n\t\tlet contractContext;\r\n\t\tif (isWeb3ContractContext(addressOrOptionsOrContext)) {\r\n\t\t\tcontractContext = addressOrOptionsOrContext;\r\n\t\t} else if (isWeb3ContractContext(optionsOrContextOrReturnFormat)) {\r\n\t\t\tcontractContext = optionsOrContextOrReturnFormat;\r\n\t\t} else {\r\n\t\t\tcontractContext = contextOrReturnFormat;\r\n\t\t}\r\n\r\n\t\tlet provider;\r\n\t\tif (\r\n\t\t\ttypeof addressOrOptionsOrContext === 'object' &&\r\n\t\t\t'provider' in addressOrOptionsOrContext\r\n\t\t) {\r\n\t\t\tprovider = addressOrOptionsOrContext.provider;\r\n\t\t} else if (\r\n\t\t\ttypeof optionsOrContextOrReturnFormat === 'object' &&\r\n\t\t\t'provider' in optionsOrContextOrReturnFormat\r\n\t\t) {\r\n\t\t\tprovider = optionsOrContextOrReturnFormat.provider;\r\n\t\t} else if (\r\n\t\t\ttypeof contextOrReturnFormat === 'object' &&\r\n\t\t\t'provider' in contextOrReturnFormat\r\n\t\t) {\r\n\t\t\tprovider = contextOrReturnFormat.provider;\r\n\t\t} else {\r\n\t\t\tprovider = Contract.givenProvider;\r\n\t\t}\r\n\r\n\t\tsuper({\r\n\t\t\t...contractContext,\r\n\t\t\tprovider,\r\n\t\t\tregisteredSubscriptions: contractSubscriptions,\r\n\t\t});\r\n\r\n\t\tthis._overloadedMethodAbis = new Map<string, AbiFunctionFragment[]>();\r\n\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\tconst returnDataFormat = isDataFormat(contextOrReturnFormat)\r\n\t\t\t? contextOrReturnFormat\r\n\t\t\t: isDataFormat(optionsOrContextOrReturnFormat)\r\n\t\t\t? optionsOrContextOrReturnFormat\r\n\t\t\t: returnFormat ?? DEFAULT_RETURN_FORMAT;\r\n\r\n\t\tconst address =\r\n\t\t\ttypeof addressOrOptionsOrContext === 'string' ? addressOrOptionsOrContext : undefined;\r\n\r\n\t\tthis._parseAndSetJsonInterface(jsonInterface, returnDataFormat);\r\n\r\n\t\tif (!isNullish(address)) {\r\n\t\t\tthis._parseAndSetAddress(address, returnDataFormat);\r\n\t\t}\r\n\r\n\t\tthis.options = {\r\n\t\t\taddress,\r\n\t\t\tjsonInterface: this._jsonInterface,\r\n\t\t\tgas: options?.gas ?? options?.gasLimit,\r\n\t\t\tgasPrice: options?.gasPrice,\r\n\t\t\tfrom: options?.from,\r\n\t\t\tinput: options?.input ?? options?.data,\r\n\t\t};\r\n\r\n\t\tthis.syncWithContext = (options as ContractInitOptions)?.syncWithContext ?? false;\r\n\t\tif (contractContext instanceof Web3Context) {\r\n\t\t\tthis.subscribeToContextEvents(contractContext);\r\n\t\t}\r\n\r\n\t\tObject.defineProperty(this.options, 'address', {\r\n\t\t\tset: (value: Address) => this._parseAndSetAddress(value, returnDataFormat),\r\n\t\t\tget: () => this._address,\r\n\t\t});\r\n\r\n\t\tObject.defineProperty(this.options, 'jsonInterface', {\r\n\t\t\tset: (value: ContractAbi) => this._parseAndSetJsonInterface(value, returnDataFormat),\r\n\t\t\tget: () => this._jsonInterface,\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Subscribe to an event.\r\n\t *\r\n\t * ```ts\r\n\t * await myContract.events.MyEvent([options])\r\n\t * ```\r\n\t *\r\n\t * There is a special event `allEvents` that can be used to subscribe all events.\r\n\t *\r\n\t * ```ts\r\n\t * await myContract.events.allEvents([options])\r\n\t * ```\r\n\t *\r\n\t * @returns - When individual event is accessed will returns {@link ContractBoundEvent} object\r\n\t */\r\n\tpublic get events() {\r\n\t\treturn this._events;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a transaction object for that method, which then can be `called`, `send`, `estimated`, `createAccessList` , or `ABI encoded`.\r\n\t *\r\n\t * The methods of this smart contract are available through:\r\n\t *\r\n\t * The name: `myContract.methods.myMethod(123)`\r\n\t * The name with parameters: `myContract.methods['myMethod(uint256)'](123)`\r\n\t * The signature `myContract.methods['0x58cf5f10'](123)`\r\n\t *\r\n\t * This allows calling functions with same name but different parameters from the JavaScript contract object.\r\n\t *\r\n\t * \\> The method signature does not provide a type safe interface, so we recommend to use method `name` instead.\r\n\t *\r\n\t * ```ts\r\n\t * // calling a method\r\n\t * const result = await myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t * // or sending and using a promise\r\n\t * const receipt = await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t * // or sending and using the events\r\n\t * const sendObject = myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t * sendObject.on('transactionHash', function(hash){\r\n\t *   ...\r\n\t * });\r\n\t * sendObject.on('receipt', function(receipt){\r\n\t *   ...\r\n\t * });\r\n\t * sendObject.on('confirmation', function(confirmationNumber, receipt){\r\n\t *   ...\r\n\t * });\r\n\t * sendObject.on('error', function(error, receipt) {\r\n\t *   ...\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @returns - Either returns {@link PayableMethodObject} or {@link NonPayableMethodObject} based on the definitions of the {@doclink glossary/json_interface | json interface} of that contract.\r\n\t */\r\n\tpublic get methods() {\r\n\t\treturn this._methods;\r\n\t}\r\n\r\n\t/**\r\n\t * Clones the current contract instance. This doesn't deploy contract on blockchain and only creates a local clone.\r\n\t *\r\n\t * @returns - The new contract instance.\r\n\t *\r\n\t * ```ts\r\n\t * const contract1 = new eth.Contract(abi, address, {gasPrice: '12345678', from: fromAddress});\r\n\t *\r\n\t * const contract2 = contract1.clone();\r\n\t * contract2.options.address = address2;\r\n\t *\r\n\t * (contract1.options.address !== contract2.options.address);\r\n\t * > true\r\n\t * ```\r\n\t */\r\n\tpublic clone() {\r\n\t\tlet newContract: Contract<any>;\r\n\r\n\t\tif (this.options.address) {\r\n\t\t\tnewContract = new Contract<Abi>(\r\n\t\t\t\t[...this._jsonInterface, ...this._errorsInterface] as unknown as Abi,\r\n\t\t\t\tthis.options.address,\r\n\t\t\t\t{\r\n\t\t\t\t\tgas: this.options.gas,\r\n\t\t\t\t\tgasPrice: this.options.gasPrice,\r\n\t\t\t\t\tfrom: this.options.from,\r\n\t\t\t\t\tinput: this.options.input,\r\n\t\t\t\t\tprovider: this.currentProvider,\r\n\t\t\t\t\tsyncWithContext: this.syncWithContext,\r\n\t\t\t\t},\r\n\t\t\t\tthis.getContextObject(),\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tnewContract = new Contract<Abi>(\r\n\t\t\t\t[...this._jsonInterface, ...this._errorsInterface] as unknown as Abi,\r\n\t\t\t\t{\r\n\t\t\t\t\tgas: this.options.gas,\r\n\t\t\t\t\tgasPrice: this.options.gasPrice,\r\n\t\t\t\t\tfrom: this.options.from,\r\n\t\t\t\t\tinput: this.options.input,\r\n\t\t\t\t\tprovider: this.currentProvider,\r\n\t\t\t\t\tsyncWithContext: this.syncWithContext,\r\n\t\t\t\t},\r\n\t\t\t\tthis.getContextObject(),\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (this.context) newContract.subscribeToContextEvents(this.context);\r\n\r\n\t\treturn newContract;\r\n\t}\r\n\r\n\t/**\r\n\t * Call this function to deploy the contract to the blockchain. After successful deployment the promise will resolve with a new contract instance.\r\n\t *\r\n\t * ```ts\r\n\t * myContract.deploy({\r\n\t *   input: '0x12345...', // data keyword can be used, too. If input is used, data will be ignored.\r\n\t *   arguments: [123, 'My String']\r\n\t * })\r\n\t * .send({\r\n\t *   from: '0x1234567890123456789012345678901234567891',\r\n\t *   gas: 1500000,\r\n\t *   gasPrice: '30000000000000'\r\n\t * }, function(error, transactionHash){ ... })\r\n\t * .on('error', function(error){ ... })\r\n\t * .on('transactionHash', function(transactionHash){ ... })\r\n\t * .on('receipt', function(receipt){\r\n\t *  console.log(receipt.contractAddress) // contains the new contract address\r\n\t * })\r\n\t * .on('confirmation', function(confirmationNumber, receipt){ ... })\r\n\t * .then(function(newContractInstance){\r\n\t *   console.log(newContractInstance.options.address) // instance with the new contract address\r\n\t * });\r\n\t *\r\n\t *\r\n\t * // When the data is already set as an option to the contract itself\r\n\t * myContract.options.data = '0x12345...';\r\n\t *\r\n\t * myContract.deploy({\r\n\t *   arguments: [123, 'My String']\r\n\t * })\r\n\t * .send({\r\n\t *   from: '0x1234567890123456789012345678901234567891',\r\n\t *   gas: 1500000,\r\n\t *   gasPrice: '30000000000000'\r\n\t * })\r\n\t * .then(function(newContractInstance){\r\n\t *   console.log(newContractInstance.options.address) // instance with the new contract address\r\n\t * });\r\n\t *\r\n\t *\r\n\t * // Simply encoding\r\n\t * myContract.deploy({\r\n\t *   input: '0x12345...',\r\n\t *   arguments: [123, 'My String']\r\n\t * })\r\n\t * .encodeABI();\r\n\t * > '0x12345...0000012345678765432'\r\n\t *\r\n\t *\r\n\t * // Gas estimation\r\n\t * myContract.deploy({\r\n\t *   input: '0x12345...',\r\n\t *   arguments: [123, 'My String']\r\n\t * })\r\n\t * .estimateGas(function(err, gas){\r\n\t *   console.log(gas);\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @returns - The transaction object\r\n\t */\r\n\tpublic deploy(deployOptions?: {\r\n\t\t/**\r\n\t\t * The byte code of the contract.\r\n\t\t */\r\n\t\tdata?: HexString;\r\n\t\tinput?: HexString;\r\n\t\t/**\r\n\t\t * The arguments which get passed to the constructor on deployment.\r\n\t\t */\r\n\t\targuments?: ContractConstructorArgs<Abi>;\r\n\t}) {\r\n\t\tlet abi = this._jsonInterface.find(j => j.type === 'constructor') as AbiConstructorFragment;\r\n\r\n\t\tif (!abi) {\r\n\t\t\tabi = {\r\n\t\t\t\ttype: 'constructor',\r\n\t\t\t\tinputs: [],\r\n\t\t\t\tstateMutability: '',\r\n\t\t\t} as AbiConstructorFragment;\r\n\t\t}\r\n\r\n\t\tconst _input = format(\r\n\t\t\t{ format: 'bytes' },\r\n\t\t\tdeployOptions?.input ?? deployOptions?.data ?? this.options.input,\r\n\t\t\tDEFAULT_RETURN_FORMAT,\r\n\t\t);\r\n\r\n\t\tif (!_input || _input.trim() === '0x') {\r\n\t\t\tthrow new Web3ContractError('contract creation without any data provided.');\r\n\t\t}\r\n\r\n\t\tconst args = deployOptions?.arguments ?? [];\r\n\r\n\t\tconst contractOptions: ContractOptions = { ...this.options, input: _input };\r\n\r\n\t\treturn {\r\n\t\t\targuments: args,\r\n\t\t\tsend: (\r\n\t\t\t\toptions?: PayableTxOptions,\r\n\t\t\t): Web3PromiEvent<\r\n\t\t\t\tContract<Abi>,\r\n\t\t\t\tSendTransactionEvents<typeof DEFAULT_RETURN_FORMAT>\r\n\t\t\t> => {\r\n\t\t\t\tconst modifiedOptions = { ...options };\r\n\r\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n\t\t\t\treturn this._contractMethodDeploySend(\r\n\t\t\t\t\tabi as AbiFunctionFragment,\r\n\t\t\t\t\targs as unknown[],\r\n\t\t\t\t\tmodifiedOptions,\r\n\t\t\t\t\tcontractOptions,\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\testimateGas: async <ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\t\t\toptions?: PayableCallOptions,\r\n\t\t\t\treturnFormat: ReturnFormat = DEFAULT_RETURN_FORMAT as ReturnFormat,\r\n\t\t\t) => {\r\n\t\t\t\tconst modifiedOptions = { ...options };\r\n\r\n\t\t\t\treturn this._contractMethodEstimateGas({\r\n\t\t\t\t\tabi: abi as AbiFunctionFragment,\r\n\t\t\t\t\tparams: args as unknown[],\r\n\t\t\t\t\treturnFormat,\r\n\t\t\t\t\toptions: modifiedOptions,\r\n\t\t\t\t\tcontractOptions,\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tencodeABI: () =>\r\n\t\t\t\tencodeMethodABI(\r\n\t\t\t\t\tabi as AbiFunctionFragment,\r\n\t\t\t\t\targs as unknown[],\r\n\t\t\t\t\tformat({ format: 'bytes' }, _input as Bytes, DEFAULT_RETURN_FORMAT),\r\n\t\t\t\t),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Gets past events for this contract.\r\n\t *\r\n\t * ```ts\r\n\t * const events = await myContract.getPastEvents('MyEvent', {\r\n\t *   filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\r\n\t *   fromBlock: 0,\r\n\t *   toBlock: 'latest'\r\n\t * });\r\n\t *\r\n\t * > [{\r\n\t *   returnValues: {\r\n\t *       myIndexedParam: 20,\r\n\t *       myOtherIndexedParam: '0x123456789...',\r\n\t *       myNonIndexParam: 'My String'\r\n\t *   },\r\n\t *   raw: {\r\n\t *       data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\r\n\t *       topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\r\n\t *   },\r\n\t *   event: 'MyEvent',\r\n\t *   signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\r\n\t *   logIndex: 0,\r\n\t *   transactionIndex: 0,\r\n\t *   transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\r\n\t *   blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\r\n\t *   blockNumber: 1234,\r\n\t *   address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\r\n\t * },{\r\n\t *   ...\r\n\t * }]\r\n\t * ```\r\n\t *\r\n\t * @param eventName - The name of the event in the contract, or `allEvents` to get all events.\r\n\t * @param filter - The filter options used to get events.\r\n\t * @param returnFormat - Return format\r\n\t * @returns - An array with the past event `Objects`, matching the given event name and filter.\r\n\t */\r\n\tpublic async getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\treturnFormat?: ReturnFormat,\r\n\t): Promise<(string | EventLog)[]>;\r\n\tpublic async getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\teventName: keyof ContractEvents<Abi> | 'allEvents',\r\n\t\treturnFormat?: ReturnFormat,\r\n\t): Promise<(string | EventLog)[]>;\r\n\tpublic async getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\tfilter: Omit<Filter, 'address'>,\r\n\t\treturnFormat?: ReturnFormat,\r\n\t): Promise<(string | EventLog)[]>;\r\n\tpublic async getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\teventName: keyof ContractEvents<Abi> | 'allEvents',\r\n\t\tfilter: Omit<Filter, 'address'>,\r\n\t\treturnFormat?: ReturnFormat,\r\n\t): Promise<(string | EventLog)[]>;\r\n\tpublic async getPastEvents<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\tparam1?: keyof ContractEvents<Abi> | 'allEvents' | Omit<Filter, 'address'> | ReturnFormat,\r\n\t\tparam2?: Omit<Filter, 'address'> | ReturnFormat,\r\n\t\tparam3?: ReturnFormat,\r\n\t): Promise<(string | EventLog)[]> {\r\n\t\tconst eventName = typeof param1 === 'string' ? param1 : 'allEvents';\r\n\r\n\t\tconst options =\r\n\t\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\t\ttypeof param1 !== 'string' && !isDataFormat(param1)\r\n\t\t\t\t? param1\r\n\t\t\t\t: !isDataFormat(param2)\r\n\t\t\t\t? param2\r\n\t\t\t\t: {};\r\n\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\tconst returnFormat = isDataFormat(param1)\r\n\t\t\t? param1\r\n\t\t\t: isDataFormat(param2)\r\n\t\t\t? param2\r\n\t\t\t: param3 ?? DEFAULT_RETURN_FORMAT;\r\n\r\n\t\tconst abi =\r\n\t\t\teventName === 'allEvents'\r\n\t\t\t\t? ALL_EVENTS_ABI\r\n\t\t\t\t: (this._jsonInterface.find(\r\n\t\t\t\t\t\tj => 'name' in j && j.name === eventName,\r\n\t\t\t\t  ) as AbiEventFragment & { signature: string });\r\n\r\n\t\tif (!abi) {\r\n\t\t\tthrow new Web3ContractError(`Event ${eventName} not found.`);\r\n\t\t}\r\n\t\tconst { fromBlock, toBlock, topics, address } = encodeEventABI(\r\n\t\t\tthis.options,\r\n\t\t\tabi,\r\n\t\t\toptions ?? {},\r\n\t\t);\r\n\t\tconst logs = await getLogs(this, { fromBlock, toBlock, topics, address }, returnFormat);\r\n\t\tconst decodedLogs = logs.map(log =>\r\n\t\t\ttypeof log === 'string'\r\n\t\t\t\t? log\r\n\t\t\t\t: decodeEventABI(abi, log as LogsInput, this._jsonInterface, returnFormat),\r\n\t\t);\r\n\r\n\t\tconst filter = options?.filter ?? {};\r\n\t\tconst filterKeys = Object.keys(filter);\r\n\r\n\t\tif (filterKeys.length > 0) {\r\n\t\t\treturn decodedLogs.filter(log => {\r\n\t\t\t\tif (typeof log === 'string') return true;\r\n\r\n\t\t\t\treturn filterKeys.every((key: string) => {\r\n\t\t\t\t\tif (Array.isArray(filter[key])) {\r\n\t\t\t\t\t\treturn (filter[key] as Numbers[]).some(\r\n\t\t\t\t\t\t\t(v: Numbers) =>\r\n\t\t\t\t\t\t\t\tString(log.returnValues[key]).toUpperCase() ===\r\n\t\t\t\t\t\t\t\tString(v).toUpperCase(),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst inputAbi = abi.inputs?.filter(input => input.name === key)[0];\r\n\t\t\t\t\tif (inputAbi?.indexed && inputAbi.type === 'string') {\r\n\t\t\t\t\t\tconst hashedIndexedString = keccak256(filter[key] as string);\r\n\t\t\t\t\t\tif (hashedIndexedString === String(log.returnValues[key])) return true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\tString(log.returnValues[key]).toUpperCase() ===\r\n\t\t\t\t\t\tString(filter[key]).toUpperCase()\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn decodedLogs;\r\n\t}\r\n\r\n\tprivate _parseAndSetAddress(value?: Address, returnFormat: DataFormat = DEFAULT_RETURN_FORMAT) {\r\n\t\tthis._address = value\r\n\t\t\t? toChecksumAddress(format({ format: 'address' }, value, returnFormat))\r\n\t\t\t: value;\r\n\t}\r\n\r\n\tprivate _parseAndSetJsonInterface(\r\n\t\tabis: ContractAbi,\r\n\t\treturnFormat: DataFormat = DEFAULT_RETURN_FORMAT,\r\n\t) {\r\n\t\tthis._functions = {};\r\n\r\n\t\tthis._methods = {} as ContractMethodsInterface<Abi>;\r\n\t\tthis._events = {} as ContractEventsInterface<Abi>;\r\n\r\n\t\tlet result: ContractAbi = [];\r\n\r\n\t\tconst functionsAbi = abis.filter(abi => abi.type !== 'error');\r\n\t\tconst errorsAbi = abis.filter(abi =>\r\n\t\t\tisAbiErrorFragment(abi),\r\n\t\t) as unknown as AbiErrorFragment[];\r\n\r\n\t\tfor (const a of functionsAbi) {\r\n\t\t\tconst abi: Mutable<AbiFragment & { signature: HexString }> = {\r\n\t\t\t\t...a,\r\n\t\t\t\tsignature: '',\r\n\t\t\t};\r\n\r\n\t\t\tif (isAbiFunctionFragment(abi)) {\r\n\t\t\t\tconst methodName = jsonInterfaceMethodToString(abi);\r\n\t\t\t\tconst methodSignature = encodeFunctionSignature(methodName);\r\n\t\t\t\tabi.signature = methodSignature;\r\n\r\n\t\t\t\t// make constant and payable backwards compatible\r\n\t\t\t\tabi.constant =\r\n\t\t\t\t\tabi.stateMutability === 'view' ??\r\n\t\t\t\t\tabi.stateMutability === 'pure' ??\r\n\t\t\t\t\tabi.constant;\r\n\r\n\t\t\t\tabi.payable = abi.stateMutability === 'payable' ?? abi.payable;\r\n\t\t\t\tthis._overloadedMethodAbis.set(abi.name, [\r\n\t\t\t\t\t...(this._overloadedMethodAbis.get(abi.name) ?? []),\r\n\t\t\t\t\tabi,\r\n\t\t\t\t]);\r\n\t\t\t\tconst abiFragment = this._overloadedMethodAbis.get(abi.name) ?? [];\r\n\t\t\t\tconst contractMethod = this._createContractMethod<\r\n\t\t\t\t\ttypeof abiFragment,\r\n\t\t\t\t\tAbiErrorFragment\r\n\t\t\t\t>(abiFragment, errorsAbi);\r\n\r\n\t\t\t\tthis._functions[methodName] = {\r\n\t\t\t\t\tsignature: methodSignature,\r\n\t\t\t\t\tmethod: contractMethod,\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// We don't know a particular type of the Abi method so can't type check\r\n\t\t\t\tthis._methods[abi.name as keyof ContractMethodsInterface<Abi>] = this._functions[\r\n\t\t\t\t\tmethodName\r\n\t\t\t\t].method as never;\r\n\r\n\t\t\t\t// We don't know a particular type of the Abi method so can't type check\r\n\t\t\t\tthis._methods[methodName as keyof ContractMethodsInterface<Abi>] = this._functions[\r\n\t\t\t\t\tmethodName\r\n\t\t\t\t].method as never;\r\n\r\n\t\t\t\t// We don't know a particular type of the Abi method so can't type check\r\n\t\t\t\tthis._methods[methodSignature as keyof ContractMethodsInterface<Abi>] = this\r\n\t\t\t\t\t._functions[methodName].method as never;\r\n\t\t\t} else if (isAbiEventFragment(abi)) {\r\n\t\t\t\tconst eventName = jsonInterfaceMethodToString(abi);\r\n\t\t\t\tconst eventSignature = encodeEventSignature(eventName);\r\n\t\t\t\tconst event = this._createContractEvent(abi, returnFormat);\r\n\t\t\t\tabi.signature = eventSignature;\r\n\r\n\t\t\t\tif (!(eventName in this._events) || abi.name === 'bound') {\r\n\t\t\t\t\t// It's a private type and we don't want to expose it and no need to check\r\n\t\t\t\t\tthis._events[eventName as keyof ContractEventsInterface<Abi>] = event as never;\r\n\t\t\t\t}\r\n\t\t\t\t// It's a private type and we don't want to expose it and no need to check\r\n\t\t\t\tthis._events[abi.name as keyof ContractEventsInterface<Abi>] = event as never;\r\n\t\t\t\t// It's a private type and we don't want to expose it and no need to check\r\n\t\t\t\tthis._events[eventSignature as keyof ContractEventsInterface<Abi>] = event as never;\r\n\t\t\t}\r\n\r\n\t\t\tthis._events.allEvents = this._createContractEvent(ALL_EVENTS_ABI, returnFormat);\r\n\r\n\t\t\tresult = [...result, abi];\r\n\t\t}\r\n\r\n\t\tthis._jsonInterface = [...result] as unknown as ContractAbiWithSignature;\r\n\t\tthis._errorsInterface = errorsAbi;\r\n\t}\r\n\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tprivate _getAbiParams(abi: AbiFunctionFragment, params: unknown[]): Array<unknown> {\r\n\t\ttry {\r\n\t\t\treturn validatorUtils.transformJsonDataToAbiFormat(abi.inputs ?? [], params);\r\n\t\t} catch (error) {\r\n\t\t\tthrow new Web3ContractError(\r\n\t\t\t\t`Invalid parameters for method ${abi.name}: ${(error as Error).message}`,\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _createContractMethod<T extends AbiFunctionFragment[], E extends AbiErrorFragment>(\r\n\t\tabiArr: T,\r\n\t\terrorsAbis: E[],\r\n\t): ContractBoundMethod<T[0]> {\r\n\t\tconst abi = abiArr[abiArr.length - 1];\r\n\t\treturn (...params: unknown[]) => {\r\n\t\t\tlet abiParams!: Array<unknown>;\r\n\t\t\tconst abis = this._overloadedMethodAbis.get(abi.name) ?? [];\r\n\t\t\tlet methodAbi: AbiFunctionFragment = abis[0];\r\n\t\t\tconst internalErrorsAbis = errorsAbis;\r\n\r\n\t\t\tconst arrayOfAbis: AbiFunctionFragment[] = abis.filter(\r\n\t\t\t\t_abi => (_abi.inputs ?? []).length === params.length,\r\n\t\t\t);\r\n\r\n\t\t\tif (abis.length === 1 || arrayOfAbis.length === 0) {\r\n\t\t\t\tabiParams = this._getAbiParams(methodAbi, params);\r\n\t\t\t\tvalidator.validate(abi.inputs ?? [], abiParams);\r\n\t\t\t} else {\r\n\t\t\t\tconst errors: Web3ValidationErrorObject[] = [];\r\n\r\n\t\t\t\tfor (const _abi of arrayOfAbis) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tabiParams = this._getAbiParams(_abi, params);\r\n\t\t\t\t\t\tvalidator.validate(\r\n\t\t\t\t\t\t\t_abi.inputs as unknown as ValidationSchemaInput,\r\n\t\t\t\t\t\t\tabiParams,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tmethodAbi = _abi;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\terrors.push(e as Web3ValidationErrorObject);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (errors.length === arrayOfAbis.length) {\r\n\t\t\t\t\tthrow new Web3ValidatorError(errors);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconst methods = {\r\n\t\t\t\targuments: abiParams,\r\n\r\n\t\t\t\tcall: async (\r\n\t\t\t\t\toptions?: PayableCallOptions | NonPayableCallOptions,\r\n\t\t\t\t\tblock?: BlockNumberOrTag,\r\n\t\t\t\t) =>\r\n\t\t\t\t\tthis._contractMethodCall(\r\n\t\t\t\t\t\tmethodAbi,\r\n\t\t\t\t\t\tabiParams,\r\n\t\t\t\t\t\tinternalErrorsAbis,\r\n\t\t\t\t\t\toptions,\r\n\t\t\t\t\t\tblock,\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\tsend: (options?: PayableTxOptions | NonPayableTxOptions) =>\r\n\t\t\t\t\tthis._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),\r\n\r\n\t\t\t\testimateGas: async <ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\t\t\t\toptions?: PayableCallOptions | NonPayableCallOptions,\r\n\t\t\t\t\treturnFormat: ReturnFormat = DEFAULT_RETURN_FORMAT as ReturnFormat,\r\n\t\t\t\t) =>\r\n\t\t\t\t\tthis._contractMethodEstimateGas({\r\n\t\t\t\t\t\tabi: methodAbi,\r\n\t\t\t\t\t\tparams: abiParams,\r\n\t\t\t\t\t\treturnFormat,\r\n\t\t\t\t\t\toptions,\r\n\t\t\t\t\t}),\r\n\r\n\t\t\t\tencodeABI: () => encodeMethodABI(methodAbi, abiParams),\r\n\r\n\t\t\t\tcreateAccessList: async (\r\n\t\t\t\t\toptions?: PayableCallOptions | NonPayableCallOptions,\r\n\t\t\t\t\tblock?: BlockNumberOrTag,\r\n\t\t\t\t) =>\r\n\t\t\t\t\tthis._contractMethodCreateAccessList(\r\n\t\t\t\t\t\tmethodAbi,\r\n\t\t\t\t\t\tabiParams,\r\n\t\t\t\t\t\tinternalErrorsAbis,\r\n\t\t\t\t\t\toptions,\r\n\t\t\t\t\t\tblock,\r\n\t\t\t\t\t),\r\n\t\t\t};\r\n\r\n\t\t\tif (methodAbi.stateMutability === 'payable') {\r\n\t\t\t\treturn methods as PayableMethodObject<\r\n\t\t\t\t\tContractOverloadedMethodInputs<T>,\r\n\t\t\t\t\tContractOverloadedMethodOutputs<T>\r\n\t\t\t\t>;\r\n\t\t\t}\r\n\t\t\treturn methods as NonPayableMethodObject<\r\n\t\t\t\tContractOverloadedMethodInputs<T>,\r\n\t\t\t\tContractOverloadedMethodOutputs<T>\r\n\t\t\t>;\r\n\t\t};\r\n\t}\r\n\r\n\tprivate async _contractMethodCall<Options extends PayableCallOptions | NonPayableCallOptions>(\r\n\t\tabi: AbiFunctionFragment,\r\n\t\tparams: unknown[],\r\n\t\terrorsAbi: AbiErrorFragment[],\r\n\t\toptions?: Options,\r\n\t\tblock?: BlockNumberOrTag,\r\n\t) {\r\n\t\tconst tx = getEthTxCallParams({\r\n\t\t\tabi,\r\n\t\t\tparams,\r\n\t\t\toptions,\r\n\t\t\tcontractOptions: {\r\n\t\t\t\t...this.options,\r\n\t\t\t\tfrom: this.options.from ?? this.config.defaultAccount,\r\n\t\t\t},\r\n\t\t});\r\n\t\ttry {\r\n\t\t\tconst result = await call(this, tx, block, DEFAULT_RETURN_FORMAT);\r\n\t\t\treturn decodeMethodReturn(abi, result);\r\n\t\t} catch (error: unknown) {\r\n\t\t\tif (error instanceof ContractExecutionError) {\r\n\t\t\t\t// this will parse the error data by trying to decode the ABI error inputs according to EIP-838\r\n\t\t\t\tdecodeContractErrorData(errorsAbi, error.innerError);\r\n\t\t\t}\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async _contractMethodCreateAccessList<\r\n\t\tOptions extends PayableCallOptions | NonPayableCallOptions,\r\n\t>(\r\n\t\tabi: AbiFunctionFragment,\r\n\t\tparams: unknown[],\r\n\t\terrorsAbi: AbiErrorFragment[],\r\n\t\toptions?: Options,\r\n\t\tblock?: BlockNumberOrTag,\r\n\t) {\r\n\t\tconst tx = getCreateAccessListParams({\r\n\t\t\tabi,\r\n\t\t\tparams,\r\n\t\t\toptions,\r\n\t\t\tcontractOptions: {\r\n\t\t\t\t...this.options,\r\n\t\t\t\tfrom: this.options.from ?? this.config.defaultAccount,\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\ttry {\r\n\t\t\treturn createAccessList(this, tx, block, DEFAULT_RETURN_FORMAT);\r\n\t\t} catch (error: unknown) {\r\n\t\t\tif (error instanceof ContractExecutionError) {\r\n\t\t\t\t// this will parse the error data by trying to decode the ABI error inputs according to EIP-838\r\n\t\t\t\tdecodeContractErrorData(errorsAbi, error.innerError);\r\n\t\t\t}\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _contractMethodSend<Options extends PayableCallOptions | NonPayableCallOptions>(\r\n\t\tabi: AbiFunctionFragment,\r\n\t\tparams: unknown[],\r\n\t\terrorsAbi: AbiErrorFragment[],\r\n\t\toptions?: Options,\r\n\t\tcontractOptions?: ContractOptions,\r\n\t) {\r\n\t\tlet modifiedContractOptions = contractOptions ?? this.options;\r\n\t\tmodifiedContractOptions = {\r\n\t\t\t...modifiedContractOptions,\r\n\t\t\tinput: undefined,\r\n\t\t\tfrom: modifiedContractOptions.from ?? this.defaultAccount ?? undefined,\r\n\t\t};\r\n\r\n\t\tconst tx = getSendTxParams({\r\n\t\t\tabi,\r\n\t\t\tparams,\r\n\t\t\toptions,\r\n\t\t\tcontractOptions: modifiedContractOptions,\r\n\t\t});\r\n\t\tconst transactionToSend = sendTransaction(this, tx, DEFAULT_RETURN_FORMAT, {\r\n\t\t\t// TODO Should make this configurable by the user\r\n\t\t\tcheckRevertBeforeSending: false,\r\n\t\t});\r\n\r\n\t\t// eslint-disable-next-line no-void\r\n\t\tvoid transactionToSend.on('error', (error: unknown) => {\r\n\t\t\tif (error instanceof ContractExecutionError) {\r\n\t\t\t\t// this will parse the error data by trying to decode the ABI error inputs according to EIP-838\r\n\t\t\t\tdecodeContractErrorData(errorsAbi, error.innerError);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn transactionToSend;\r\n\t}\r\n\r\n\tprivate _contractMethodDeploySend<Options extends PayableCallOptions | NonPayableCallOptions>(\r\n\t\tabi: AbiFunctionFragment,\r\n\t\tparams: unknown[],\r\n\t\toptions?: Options,\r\n\t\tcontractOptions?: ContractOptions,\r\n\t) {\r\n\t\tlet modifiedContractOptions = contractOptions ?? this.options;\r\n\t\tmodifiedContractOptions = {\r\n\t\t\t...modifiedContractOptions,\r\n\t\t\tfrom: modifiedContractOptions.from ?? this.defaultAccount ?? undefined,\r\n\t\t};\r\n\r\n\t\tconst tx = getSendTxParams({\r\n\t\t\tabi,\r\n\t\t\tparams,\r\n\t\t\toptions,\r\n\t\t\tcontractOptions: modifiedContractOptions,\r\n\t\t});\r\n\r\n\t\treturn sendTransaction(this, tx, DEFAULT_RETURN_FORMAT, {\r\n\t\t\ttransactionResolver: receipt => {\r\n\t\t\t\tif (receipt.status === BigInt(0)) {\r\n\t\t\t\t\tthrow new Web3ContractError(\"code couldn't be stored\", receipt);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst newContract = this.clone();\r\n\r\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n\t\t\t\tnewContract.options.address = receipt.contractAddress;\r\n\t\t\t\treturn newContract;\r\n\t\t\t},\r\n\t\t\t// TODO Should make this configurable by the user\r\n\t\t\tcheckRevertBeforeSending: false,\r\n\t\t});\r\n\t}\r\n\r\n\tprivate async _contractMethodEstimateGas<\r\n\t\tOptions extends PayableCallOptions | NonPayableCallOptions,\r\n\t\tReturnFormat extends DataFormat,\r\n\t>({\r\n\t\tabi,\r\n\t\tparams,\r\n\t\treturnFormat,\r\n\t\toptions,\r\n\t\tcontractOptions,\r\n\t}: {\r\n\t\tabi: AbiFunctionFragment;\r\n\t\tparams: unknown[];\r\n\t\treturnFormat: ReturnFormat;\r\n\t\toptions?: Options;\r\n\t\tcontractOptions?: ContractOptions;\r\n\t}) {\r\n\t\tconst tx = getEstimateGasParams({\r\n\t\t\tabi,\r\n\t\t\tparams,\r\n\t\t\toptions,\r\n\t\t\tcontractOptions: contractOptions ?? this.options,\r\n\t\t});\r\n\r\n\t\treturn estimateGas(this, tx, BlockTags.LATEST, returnFormat);\r\n\t}\r\n\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tprivate _createContractEvent(\r\n\t\tabi: AbiEventFragment & { signature: HexString },\r\n\t\treturnFormat: DataFormat = DEFAULT_RETURN_FORMAT,\r\n\t): ContractBoundEvent {\r\n\t\treturn (...params: unknown[]) => {\r\n\t\t\tconst { topics, fromBlock } = encodeEventABI(\r\n\t\t\t\tthis.options,\r\n\t\t\t\tabi,\r\n\t\t\t\tparams[0] as EventParameters,\r\n\t\t\t);\r\n\t\t\tconst sub = new LogsSubscription(\r\n\t\t\t\t{\r\n\t\t\t\t\taddress: this.options.address,\r\n\t\t\t\t\ttopics,\r\n\t\t\t\t\tabi,\r\n\t\t\t\t\tjsonInterface: this._jsonInterface,\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n\t\t\t\t\tsubscriptionManager: this.subscriptionManager as Web3SubscriptionManager<\r\n\t\t\t\t\t\tunknown,\r\n\t\t\t\t\t\tany\r\n\t\t\t\t\t>,\r\n\t\t\t\t\treturnFormat,\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t\tif (!isNullish(fromBlock)) {\r\n\t\t\t\t// emit past events when fromBlock is defined\r\n\t\t\t\tthis.getPastEvents(abi.name, { fromBlock, topics }, returnFormat)\r\n\t\t\t\t\t.then(logs => {\r\n\t\t\t\t\t\tlogs.forEach(log => sub.emit('data', log as EventLog));\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.catch(() => {\r\n\t\t\t\t\t\tsub.emit('error', new SubscriptionError('Failed to get past events.'));\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tthis.subscriptionManager?.addSubscription(sub).catch(() => {\r\n\t\t\t\tsub.emit('error', new SubscriptionError('Failed to subscribe.'));\r\n\t\t\t});\r\n\r\n\t\t\treturn sub;\r\n\t\t};\r\n\t}\r\n\r\n\tprotected subscribeToContextEvents<T extends Web3Context>(context: T): void {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\r\n\t\tconst contractThis = this;\r\n\t\tthis.context = context;\r\n\r\n\t\tif (contractThis.syncWithContext) {\r\n\t\t\tcontext.on(Web3ConfigEvent.CONFIG_CHANGE, event => {\r\n\t\t\t\tcontractThis.setConfig({ [event.name]: event.newValue });\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
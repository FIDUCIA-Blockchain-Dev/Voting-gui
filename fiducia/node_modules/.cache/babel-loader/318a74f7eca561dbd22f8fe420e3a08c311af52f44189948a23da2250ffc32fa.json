{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nimport { InvalidBytesError, InvalidNumberError } from 'web3-errors';\nimport { VALID_ETH_BASE_TYPES } from './constants.js';\nimport { isAbiParameterSchema } from './validation/abi.js';\nimport { isHexStrict } from './validation/string.js';\nimport { Web3ValidatorError } from './errors.js';\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\nexport const parseBaseType = type => {\n  // Remove all empty spaces to avoid any parsing issue.\n  let strippedType = type.replace(/ /, '');\n  let baseTypeSize;\n  let isArray = false;\n  let arraySizes = [];\n  if (type.includes('[')) {\n    // Extract the array type\n    strippedType = strippedType.slice(0, strippedType.indexOf('['));\n    // Extract array indexes\n    arraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)].map(match => parseInt(match[1], 10)).map(size => Number.isNaN(size) ? -1 : size);\n    isArray = arraySizes.length > 0;\n  }\n  if (VALID_ETH_BASE_TYPES.includes(strippedType)) {\n    return {\n      baseType: strippedType,\n      isArray,\n      baseTypeSize,\n      arraySizes\n    };\n  }\n  if (strippedType.startsWith('int')) {\n    baseTypeSize = parseInt(strippedType.substring(3), 10);\n    strippedType = 'int';\n  } else if (strippedType.startsWith('uint')) {\n    baseTypeSize = parseInt(type.substring(4), 10);\n    strippedType = 'uint';\n  } else if (strippedType.startsWith('bytes')) {\n    baseTypeSize = parseInt(strippedType.substring(5), 10);\n    strippedType = 'bytes';\n  } else {\n    return {\n      baseType: undefined,\n      isArray: false,\n      baseTypeSize: undefined,\n      arraySizes\n    };\n  }\n  return {\n    baseType: strippedType,\n    isArray,\n    baseTypeSize,\n    arraySizes\n  };\n};\nconst convertEthType = function (type) {\n  let parentSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const typePropertyPresent = Object.keys(parentSchema).includes('type');\n  if (typePropertyPresent) {\n    throw new Web3ValidatorError([{\n      keyword: 'eth',\n      message: 'Either \"eth\" or \"type\" can be presented in schema',\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n  const {\n    baseType,\n    baseTypeSize\n  } = parseBaseType(type);\n  if (!baseType && !extraTypes.includes(type)) {\n    throw new Web3ValidatorError([{\n      keyword: 'eth',\n      message: `Eth data type \"${type}\" is not valid`,\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n  if (baseType) {\n    if (baseType === 'tuple') {\n      throw new Error('\"tuple\" type is not implemented directly.');\n    }\n    return {\n      format: `${baseType}${baseTypeSize !== null && baseTypeSize !== void 0 ? baseTypeSize : ''}`,\n      required: true\n    };\n  }\n  if (type) {\n    return {\n      format: type,\n      required: true\n    };\n  }\n  return {};\n};\nexport const abiSchemaToJsonSchema = function (abis) {\n  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/0';\n  const schema = {\n    type: 'array',\n    items: [],\n    maxItems: abis.length,\n    minItems: abis.length\n  };\n  for (const [index, abi] of abis.entries()) {\n    // eslint-disable-next-line no-nested-ternary\n    let abiType;\n    let abiName;\n    let abiComponents = [];\n    // If it's a complete Abi Parameter\n    // e.g. {name: 'a', type: 'uint'}\n    if (isAbiParameterSchema(abi)) {\n      abiType = abi.type;\n      abiName = abi.name;\n      abiComponents = abi.components;\n      // If its short form string value e.g. ['uint']\n    } else if (typeof abi === 'string') {\n      abiType = abi;\n      abiName = `${level}/${index}`;\n      // If it's provided in short form of tuple e.g. [['uint', 'string']]\n    } else if (Array.isArray(abi)) {\n      // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n      if (abi[0] && typeof abi[0] === 'string' && abi[0].startsWith('tuple') && !Array.isArray(abi[0]) && abi[1] && Array.isArray(abi[1])) {\n        // eslint-disable-next-line prefer-destructuring\n        abiType = abi[0];\n        abiName = `${level}/${index}`;\n        abiComponents = abi[1];\n      } else {\n        abiType = 'tuple';\n        abiName = `${level}/${index}`;\n        abiComponents = abi;\n      }\n    }\n    const {\n      baseType,\n      isArray,\n      arraySizes\n    } = parseBaseType(abiType);\n    let childSchema;\n    let lastSchema = schema;\n    for (let i = arraySizes.length - 1; i > 0; i -= 1) {\n      childSchema = {\n        type: 'array',\n        items: [],\n        maxItems: arraySizes[i],\n        minItems: arraySizes[i]\n      };\n      if (arraySizes[i] < 0) {\n        delete childSchema.maxItems;\n        delete childSchema.minItems;\n      }\n      lastSchema.items = childSchema;\n      lastSchema = childSchema;\n    }\n    if (baseType === 'tuple' && !isArray) {\n      const nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);\n      nestedTuple.$id = abiName;\n      lastSchema.items.push(nestedTuple);\n    } else if (baseType === 'tuple' && isArray) {\n      const arraySize = arraySizes[0];\n      const item = {\n        $id: abiName,\n        type: 'array',\n        items: abiSchemaToJsonSchema(abiComponents, abiName),\n        maxItems: arraySize,\n        minItems: arraySize\n      };\n      if (arraySize < 0) {\n        delete item.maxItems;\n        delete item.minItems;\n      }\n      lastSchema.items.push(item);\n    } else if (isArray) {\n      const arraySize = arraySizes[0];\n      const item = {\n        type: 'array',\n        $id: abiName,\n        items: convertEthType(String(baseType)),\n        minItems: arraySize,\n        maxItems: arraySize\n      };\n      if (arraySize < 0) {\n        delete item.maxItems;\n        delete item.minItems;\n      }\n      lastSchema.items.push(item);\n    } else if (Array.isArray(lastSchema.items)) {\n      // Array of non-tuple items\n      lastSchema.items.push(Object.assign({\n        $id: abiName\n      }, convertEthType(abiType)));\n    } else {\n      // Nested object\n      lastSchema.items.items.push(Object.assign({\n        $id: abiName\n      }, convertEthType(abiType)));\n    }\n  }\n  return schema;\n};\nexport const ethAbiToJsonSchema = abis => abiSchemaToJsonSchema(abis);\nexport const fetchArrayElement = (data, level) => {\n  if (level === 1) {\n    return data;\n  }\n  return fetchArrayElement(data[0], level - 1);\n};\nexport const transformJsonDataToAbiFormat = (abis, data, transformedData) => {\n  const newData = [];\n  for (const [index, abi] of abis.entries()) {\n    // eslint-disable-next-line no-nested-ternary\n    let abiType;\n    let abiName;\n    let abiComponents = [];\n    // If it's a complete Abi Parameter\n    // e.g. {name: 'a', type: 'uint'}\n    if (isAbiParameterSchema(abi)) {\n      abiType = abi.type;\n      abiName = abi.name;\n      abiComponents = abi.components;\n      // If its short form string value e.g. ['uint']\n    } else if (typeof abi === 'string') {\n      abiType = abi;\n      // If it's provided in short form of tuple e.g. [['uint', 'string']]\n    } else if (Array.isArray(abi)) {\n      // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n      if (abi[1] && Array.isArray(abi[1])) {\n        abiType = abi[0];\n        abiComponents = abi[1];\n      } else {\n        abiType = 'tuple';\n        abiComponents = abi;\n      }\n    }\n    const {\n      baseType,\n      isArray,\n      arraySizes\n    } = parseBaseType(abiType);\n    const dataItem = Array.isArray(data) ? data[index] : data[abiName];\n    if (baseType === 'tuple' && !isArray) {\n      newData.push(transformJsonDataToAbiFormat(abiComponents, dataItem, transformedData));\n    } else if (baseType === 'tuple' && isArray) {\n      const tupleData = [];\n      for (const tupleItem of dataItem) {\n        // Nested array\n        if (arraySizes.length > 1) {\n          const nestedItems = fetchArrayElement(tupleItem, arraySizes.length - 1);\n          const nestedData = [];\n          for (const nestedItem of nestedItems) {\n            nestedData.push(transformJsonDataToAbiFormat(abiComponents, nestedItem, transformedData));\n          }\n          tupleData.push(nestedData);\n        } else {\n          tupleData.push(transformJsonDataToAbiFormat(abiComponents, tupleItem, transformedData));\n        }\n      }\n      newData.push(tupleData);\n    } else {\n      newData.push(dataItem);\n    }\n  }\n  // Have to reassign before pushing to transformedData\n  // eslint-disable-next-line no-param-reassign\n  transformedData = transformedData !== null && transformedData !== void 0 ? transformedData : [];\n  transformedData.push(...newData);\n  return transformedData;\n};\n/**\r\n * Code points to int\r\n */\nexport const codePointToInt = codePoint => {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n  throw new Error(`Invalid code point: ${codePoint}`);\n};\n/**\r\n * Converts value to it's number representation\r\n */\nexport const hexToNumber = value => {\n  if (!isHexStrict(value)) {\n    throw new Error('Invalid hex string');\n  }\n  const [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n  const num = BigInt(hexValue);\n  if (num > Number.MAX_SAFE_INTEGER) {\n    return negative ? -num : num;\n  }\n  if (num < Number.MIN_SAFE_INTEGER) {\n    return num;\n  }\n  return negative ? -1 * Number(num) : Number(num);\n};\n/**\r\n * Converts value to it's hex representation\r\n */\nexport const numberToHex = value => {\n  if ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n    return `-0x${value.toString(16).slice(1)}`;\n  }\n  if ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n    return `0x${value.toString(16)}`;\n  }\n  if (typeof value === 'string' && isHexStrict(value)) {\n    const [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n    const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n    return `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;\n  }\n  if (typeof value === 'string' && !isHexStrict(value)) {\n    return numberToHex(BigInt(value));\n  }\n  throw new InvalidNumberError(value);\n};\n/**\r\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\r\n */\nexport const padLeft = function (value, characterAmount) {\n  let sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n  if (typeof value === 'string' && !isHexStrict(value)) {\n    return value.padStart(characterAmount, sign);\n  }\n  const hex = typeof value === 'string' && isHexStrict(value) ? value : numberToHex(value);\n  const [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\n  return `${prefix}${hexValue.padStart(characterAmount, sign)}`;\n};\nexport function uint8ArrayToHexString(uint8Array) {\n  let hexString = '0x';\n  for (const e of uint8Array) {\n    const hex = e.toString(16);\n    hexString += hex.length === 1 ? `0${hex}` : hex;\n  }\n  return hexString;\n}\nexport function hexToUint8Array(hex) {\n  let value;\n  if (hex.toLowerCase().startsWith('0x')) {\n    value = hex.slice(2);\n  } else {\n    value = hex;\n  }\n  if (value.length % 2 !== 0) {\n    throw new InvalidBytesError(`hex string has odd length: ${hex}`);\n  }\n  const bytes = new Uint8Array(Math.ceil(value.length / 2));\n  for (let i = 0; i < bytes.length; i += 1) {\n    const byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n    bytes[i] = byte;\n  }\n  return bytes;\n}","map":{"version":3,"names":["InvalidBytesError","InvalidNumberError","VALID_ETH_BASE_TYPES","isAbiParameterSchema","isHexStrict","Web3ValidatorError","extraTypes","parseBaseType","type","strippedType","replace","baseTypeSize","isArray","arraySizes","includes","slice","indexOf","matchAll","map","match","parseInt","size","Number","isNaN","length","baseType","startsWith","substring","undefined","convertEthType","parentSchema","arguments","typePropertyPresent","Object","keys","keyword","message","params","eth","instancePath","schemaPath","Error","format","required","abiSchemaToJsonSchema","abis","level","schema","items","maxItems","minItems","index","abi","entries","abiType","abiName","abiComponents","name","components","Array","childSchema","lastSchema","i","nestedTuple","$id","push","arraySize","item","String","assign","ethAbiToJsonSchema","fetchArrayElement","data","transformJsonDataToAbiFormat","transformedData","newData","dataItem","tupleData","tupleItem","nestedItems","nestedData","nestedItem","codePointToInt","codePoint","hexToNumber","value","negative","hexValue","num","BigInt","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","numberToHex","toString","hex","split","toLowerCase","padLeft","characterAmount","sign","padStart","prefix","uint8ArrayToHexString","uint8Array","hexString","e","hexToUint8Array","bytes","Uint8Array","Math","ceil","byte"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-validator\\src\\utils.ts"],"sourcesContent":["ï»¿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { InvalidBytesError, InvalidNumberError } from 'web3-errors';\r\nimport { VALID_ETH_BASE_TYPES } from './constants.js';\r\nimport {\r\n\tFullValidationSchema,\r\n\tJsonSchema,\r\n\tSchema,\r\n\tShortValidationSchema,\r\n\tValidationSchemaInput,\r\n\tValidInputTypes,\r\n} from './types.js';\r\nimport { isAbiParameterSchema } from './validation/abi.js';\r\nimport { isHexStrict } from './validation/string.js';\r\nimport { Web3ValidatorError } from './errors.js';\r\n\r\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\r\n\r\nexport const parseBaseType = <T = typeof VALID_ETH_BASE_TYPES[number]>(\r\n\ttype: string,\r\n): {\r\n\tbaseType?: T;\r\n\tbaseTypeSize: number | undefined;\r\n\tarraySizes: number[];\r\n\tisArray: boolean;\r\n} => {\r\n\t// Remove all empty spaces to avoid any parsing issue.\r\n\tlet strippedType = type.replace(/ /, '');\r\n\tlet baseTypeSize: number | undefined;\r\n\tlet isArray = false;\r\n\tlet arraySizes: number[] = [];\r\n\r\n\tif (type.includes('[')) {\r\n\t\t// Extract the array type\r\n\t\tstrippedType = strippedType.slice(0, strippedType.indexOf('['));\r\n\t\t// Extract array indexes\r\n\t\tarraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)]\r\n\t\t\t.map(match => parseInt(match[1], 10))\r\n\t\t\t.map(size => (Number.isNaN(size) ? -1 : size));\r\n\r\n\t\tisArray = arraySizes.length > 0;\r\n\t}\r\n\r\n\tif (VALID_ETH_BASE_TYPES.includes(strippedType)) {\r\n\t\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\r\n\t}\r\n\r\n\tif (strippedType.startsWith('int')) {\r\n\t\tbaseTypeSize = parseInt(strippedType.substring(3), 10);\r\n\t\tstrippedType = 'int';\r\n\t} else if (strippedType.startsWith('uint')) {\r\n\t\tbaseTypeSize = parseInt(type.substring(4), 10);\r\n\t\tstrippedType = 'uint';\r\n\t} else if (strippedType.startsWith('bytes')) {\r\n\t\tbaseTypeSize = parseInt(strippedType.substring(5), 10);\r\n\t\tstrippedType = 'bytes';\r\n\t} else {\r\n\t\treturn { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };\r\n\t}\r\n\r\n\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\r\n};\r\n\r\nconst convertEthType = (\r\n\ttype: string,\r\n\tparentSchema: Schema = {},\r\n): { format?: string; required?: boolean } => {\r\n\tconst typePropertyPresent = Object.keys(parentSchema).includes('type');\r\n\r\n\tif (typePropertyPresent) {\r\n\t\tthrow new Web3ValidatorError([\r\n\t\t\t{\r\n\t\t\t\tkeyword: 'eth',\r\n\t\t\t\tmessage: 'Either \"eth\" or \"type\" can be presented in schema',\r\n\t\t\t\tparams: { eth: type },\r\n\t\t\t\tinstancePath: '',\r\n\t\t\t\tschemaPath: '',\r\n\t\t\t},\r\n\t\t]);\r\n\t}\r\n\r\n\tconst { baseType, baseTypeSize } = parseBaseType(type);\r\n\r\n\tif (!baseType && !extraTypes.includes(type)) {\r\n\t\tthrow new Web3ValidatorError([\r\n\t\t\t{\r\n\t\t\t\tkeyword: 'eth',\r\n\t\t\t\tmessage: `Eth data type \"${type}\" is not valid`,\r\n\t\t\t\tparams: { eth: type },\r\n\t\t\t\tinstancePath: '',\r\n\t\t\t\tschemaPath: '',\r\n\t\t\t},\r\n\t\t]);\r\n\t}\r\n\r\n\tif (baseType) {\r\n\t\tif (baseType === 'tuple') {\r\n\t\t\tthrow new Error('\"tuple\" type is not implemented directly.');\r\n\t\t}\r\n\t\treturn { format: `${baseType}${baseTypeSize ?? ''}`, required: true };\r\n\t}\r\n\tif (type) {\r\n\t\treturn { format: type, required: true };\r\n\t}\r\n\r\n\treturn {};\r\n};\r\n\r\nexport const abiSchemaToJsonSchema = (\r\n\tabis: ShortValidationSchema | FullValidationSchema,\r\n\tlevel = '/0',\r\n) => {\r\n\tconst schema: JsonSchema = {\r\n\t\ttype: 'array',\r\n\t\titems: [],\r\n\t\tmaxItems: abis.length,\r\n\t\tminItems: abis.length,\r\n\t};\r\n\r\n\tfor (const [index, abi] of abis.entries()) {\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\tlet abiType!: string;\r\n\t\tlet abiName!: string;\r\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\r\n\r\n\t\t// If it's a complete Abi Parameter\r\n\t\t// e.g. {name: 'a', type: 'uint'}\r\n\t\tif (isAbiParameterSchema(abi)) {\r\n\t\t\tabiType = abi.type;\r\n\t\t\tabiName = abi.name;\r\n\t\t\tabiComponents = abi.components as FullValidationSchema;\r\n\t\t\t// If its short form string value e.g. ['uint']\r\n\t\t} else if (typeof abi === 'string') {\r\n\t\t\tabiType = abi;\r\n\t\t\tabiName = `${level}/${index}`;\r\n\r\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\r\n\t\t} else if (Array.isArray(abi)) {\r\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\r\n\t\t\tif (\r\n\t\t\t\tabi[0] &&\r\n\t\t\t\ttypeof abi[0] === 'string' &&\r\n\t\t\t\tabi[0].startsWith('tuple') &&\r\n\t\t\t\t!Array.isArray(abi[0]) &&\r\n\t\t\t\tabi[1] &&\r\n\t\t\t\tArray.isArray(abi[1])\r\n\t\t\t) {\r\n\t\t\t\t// eslint-disable-next-line prefer-destructuring\r\n\t\t\t\tabiType = abi[0];\r\n\t\t\t\tabiName = `${level}/${index}`;\r\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\r\n\t\t\t} else {\r\n\t\t\t\tabiType = 'tuple';\r\n\t\t\t\tabiName = `${level}/${index}`;\r\n\t\t\t\tabiComponents = abi;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\r\n\r\n\t\tlet childSchema: JsonSchema;\r\n\t\tlet lastSchema = schema;\r\n\t\tfor (let i = arraySizes.length - 1; i > 0; i -= 1) {\r\n\t\t\tchildSchema = {\r\n\t\t\t\ttype: 'array',\r\n\t\t\t\titems: [],\r\n\t\t\t\tmaxItems: arraySizes[i],\r\n\t\t\t\tminItems: arraySizes[i],\r\n\t\t\t};\r\n\r\n\t\t\tif (arraySizes[i] < 0) {\r\n\t\t\t\tdelete childSchema.maxItems;\r\n\t\t\t\tdelete childSchema.minItems;\r\n\t\t\t}\r\n\r\n\t\t\tlastSchema.items = childSchema;\r\n\t\t\tlastSchema = childSchema;\r\n\t\t}\r\n\r\n\t\tif (baseType === 'tuple' && !isArray) {\r\n\t\t\tconst nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);\r\n\t\t\tnestedTuple.$id = abiName;\r\n\t\t\t(lastSchema.items as JsonSchema[]).push(nestedTuple);\r\n\t\t} else if (baseType === 'tuple' && isArray) {\r\n\t\t\tconst arraySize = arraySizes[0];\r\n\t\t\tconst item: JsonSchema = {\r\n\t\t\t\t$id: abiName,\r\n\t\t\t\ttype: 'array',\r\n\t\t\t\titems: abiSchemaToJsonSchema(abiComponents, abiName),\r\n\t\t\t\tmaxItems: arraySize,\r\n\t\t\t\tminItems: arraySize,\r\n\t\t\t};\r\n\r\n\t\t\tif (arraySize < 0) {\r\n\t\t\t\tdelete item.maxItems;\r\n\t\t\t\tdelete item.minItems;\r\n\t\t\t}\r\n\r\n\t\t\t(lastSchema.items as JsonSchema[]).push(item);\r\n\t\t} else if (isArray) {\r\n\t\t\tconst arraySize = arraySizes[0];\r\n\t\t\tconst item: JsonSchema = {\r\n\t\t\t\ttype: 'array',\r\n\t\t\t\t$id: abiName,\r\n\t\t\t\titems: convertEthType(String(baseType)),\r\n\t\t\t\tminItems: arraySize,\r\n\t\t\t\tmaxItems: arraySize,\r\n\t\t\t};\r\n\r\n\t\t\tif (arraySize < 0) {\r\n\t\t\t\tdelete item.maxItems;\r\n\t\t\t\tdelete item.minItems;\r\n\t\t\t}\r\n\r\n\t\t\t(lastSchema.items as JsonSchema[]).push(item);\r\n\t\t} else if (Array.isArray(lastSchema.items)) {\r\n\t\t\t// Array of non-tuple items\r\n\t\t\tlastSchema.items.push({ $id: abiName, ...convertEthType(abiType) });\r\n\t\t} else {\r\n\t\t\t// Nested object\r\n\t\t\t((lastSchema.items as JsonSchema).items as JsonSchema[]).push({\r\n\t\t\t\t$id: abiName,\r\n\t\t\t\t...convertEthType(abiType),\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn schema;\r\n};\r\n\r\nexport const ethAbiToJsonSchema = (abis: ValidationSchemaInput) => abiSchemaToJsonSchema(abis);\r\n\r\nexport const fetchArrayElement = (data: Array<unknown>, level: number): unknown => {\r\n\tif (level === 1) {\r\n\t\treturn data;\r\n\t}\r\n\r\n\treturn fetchArrayElement(data[0] as Array<unknown>, level - 1);\r\n};\r\n\r\nexport const transformJsonDataToAbiFormat = (\r\n\tabis: FullValidationSchema,\r\n\tdata: ReadonlyArray<unknown> | Record<string, unknown>,\r\n\ttransformedData?: Array<unknown>,\r\n): Array<unknown> => {\r\n\tconst newData: Array<unknown> = [];\r\n\r\n\tfor (const [index, abi] of abis.entries()) {\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\tlet abiType!: string;\r\n\t\tlet abiName!: string;\r\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\r\n\r\n\t\t// If it's a complete Abi Parameter\r\n\t\t// e.g. {name: 'a', type: 'uint'}\r\n\t\tif (isAbiParameterSchema(abi)) {\r\n\t\t\tabiType = abi.type;\r\n\t\t\tabiName = abi.name;\r\n\t\t\tabiComponents = abi.components as FullValidationSchema;\r\n\t\t\t// If its short form string value e.g. ['uint']\r\n\t\t} else if (typeof abi === 'string') {\r\n\t\t\tabiType = abi;\r\n\r\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\r\n\t\t} else if (Array.isArray(abi)) {\r\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\r\n\t\t\tif (abi[1] && Array.isArray(abi[1])) {\r\n\t\t\t\tabiType = abi[0] as string;\r\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\r\n\t\t\t} else {\r\n\t\t\t\tabiType = 'tuple';\r\n\t\t\t\tabiComponents = abi;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\r\n\t\tconst dataItem = Array.isArray(data)\r\n\t\t\t? (data as Array<unknown>)[index]\r\n\t\t\t: (data as Record<string, unknown>)[abiName];\r\n\r\n\t\tif (baseType === 'tuple' && !isArray) {\r\n\t\t\tnewData.push(\r\n\t\t\t\ttransformJsonDataToAbiFormat(\r\n\t\t\t\t\tabiComponents as FullValidationSchema,\r\n\t\t\t\t\tdataItem as Array<unknown>,\r\n\t\t\t\t\ttransformedData,\r\n\t\t\t\t),\r\n\t\t\t);\r\n\t\t} else if (baseType === 'tuple' && isArray) {\r\n\t\t\tconst tupleData = [];\r\n\t\t\tfor (const tupleItem of dataItem as Array<unknown>) {\r\n\t\t\t\t// Nested array\r\n\t\t\t\tif (arraySizes.length > 1) {\r\n\t\t\t\t\tconst nestedItems = fetchArrayElement(\r\n\t\t\t\t\t\ttupleItem as Array<unknown>,\r\n\t\t\t\t\t\tarraySizes.length - 1,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tconst nestedData = [];\r\n\r\n\t\t\t\t\tfor (const nestedItem of nestedItems as Array<unknown>) {\r\n\t\t\t\t\t\tnestedData.push(\r\n\t\t\t\t\t\t\ttransformJsonDataToAbiFormat(\r\n\t\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\r\n\t\t\t\t\t\t\t\tnestedItem as Array<unknown>,\r\n\t\t\t\t\t\t\t\ttransformedData,\r\n\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttupleData.push(nestedData);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttupleData.push(\r\n\t\t\t\t\t\ttransformJsonDataToAbiFormat(\r\n\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\r\n\t\t\t\t\t\t\ttupleItem as Array<unknown>,\r\n\t\t\t\t\t\t\ttransformedData,\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tnewData.push(tupleData);\r\n\t\t} else {\r\n\t\t\tnewData.push(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t// Have to reassign before pushing to transformedData\r\n\t// eslint-disable-next-line no-param-reassign\r\n\ttransformedData = transformedData ?? [];\r\n\ttransformedData.push(...newData);\r\n\r\n\treturn transformedData;\r\n};\r\n\r\n/**\r\n * Code points to int\r\n */\r\n\r\nexport const codePointToInt = (codePoint: number): number => {\r\n\tif (codePoint >= 48 && codePoint <= 57) {\r\n\t\t/* ['0'..'9'] -> [0..9] */\r\n\t\treturn codePoint - 48;\r\n\t}\r\n\r\n\tif (codePoint >= 65 && codePoint <= 70) {\r\n\t\t/* ['A'..'F'] -> [10..15] */\r\n\t\treturn codePoint - 55;\r\n\t}\r\n\r\n\tif (codePoint >= 97 && codePoint <= 102) {\r\n\t\t/* ['a'..'f'] -> [10..15] */\r\n\t\treturn codePoint - 87;\r\n\t}\r\n\r\n\tthrow new Error(`Invalid code point: ${codePoint}`);\r\n};\r\n\r\n/**\r\n * Converts value to it's number representation\r\n */\r\nexport const hexToNumber = (value: string): bigint | number => {\r\n\tif (!isHexStrict(value)) {\r\n\t\tthrow new Error('Invalid hex string');\r\n\t}\r\n\r\n\tconst [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\r\n\tconst num = BigInt(hexValue);\r\n\r\n\tif (num > Number.MAX_SAFE_INTEGER) {\r\n\t\treturn negative ? -num : num;\r\n\t}\r\n\r\n\tif (num < Number.MIN_SAFE_INTEGER) {\r\n\t\treturn num;\r\n\t}\r\n\r\n\treturn negative ? -1 * Number(num) : Number(num);\r\n};\r\n\r\n/**\r\n * Converts value to it's hex representation\r\n */\r\nexport const numberToHex = (value: ValidInputTypes): string => {\r\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\r\n\t\treturn `-0x${value.toString(16).slice(1)}`;\r\n\t}\r\n\r\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\r\n\t\treturn `0x${value.toString(16)}`;\r\n\t}\r\n\r\n\tif (typeof value === 'string' && isHexStrict(value)) {\r\n\t\tconst [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\r\n\t\tconst hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\r\n\t\treturn `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;\r\n\t}\r\n\r\n\tif (typeof value === 'string' && !isHexStrict(value)) {\r\n\t\treturn numberToHex(BigInt(value));\r\n\t}\r\n\r\n\tthrow new InvalidNumberError(value);\r\n};\r\n\r\n/**\r\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\r\n */\r\nexport const padLeft = (value: ValidInputTypes, characterAmount: number, sign = '0'): string => {\r\n\tif (typeof value === 'string' && !isHexStrict(value)) {\r\n\t\treturn value.padStart(characterAmount, sign);\r\n\t}\r\n\r\n\tconst hex = typeof value === 'string' && isHexStrict(value) ? value : numberToHex(value);\r\n\r\n\tconst [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\r\n\r\n\treturn `${prefix}${hexValue.padStart(characterAmount, sign)}`;\r\n};\r\n\r\nexport function uint8ArrayToHexString(uint8Array: Uint8Array): string {\r\n\tlet hexString = '0x';\r\n\tfor (const e of uint8Array) {\r\n\t\tconst hex = e.toString(16);\r\n\t\thexString += hex.length === 1 ? `0${hex}` : hex;\r\n\t}\r\n\treturn hexString;\r\n}\r\n\r\nexport function hexToUint8Array(hex: string): Uint8Array {\r\n\tlet value;\r\n\tif (hex.toLowerCase().startsWith('0x')) {\r\n\t\tvalue = hex.slice(2);\r\n\t} else {\r\n\t\tvalue = hex;\r\n\t}\r\n\tif (value.length % 2 !== 0) {\r\n\t\tthrow new InvalidBytesError(`hex string has odd length: ${hex}`);\r\n\t}\r\n\tconst bytes = new Uint8Array(Math.ceil(value.length / 2));\r\n\tfor (let i = 0; i < bytes.length; i += 1) {\r\n\t\tconst byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);\r\n\t\tbytes[i] = byte;\r\n\t}\r\n\treturn bytes;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { bytesToUtf8, utf8ToBytes } from 'ethereum-cryptography/utils.js';\nimport { isAddress, isHex, isHexStrict, isNullish, isInt, utils as validatorUtils, validator } from 'web3-validator';\nimport { HexProcessingError, InvalidAddressError, InvalidBytesError, InvalidNumberError, InvalidUnitError } from 'web3-errors';\nconst base = BigInt(10);\nconst expo10 = expo => base ** BigInt(expo);\n// Ref: https://ethdocs.org/en/latest/ether.html\n/** @internal */\nexport const ethUnitMap = {\n  noether: BigInt('0'),\n  wei: BigInt(1),\n  kwei: expo10(3),\n  Kwei: expo10(3),\n  babbage: expo10(3),\n  femtoether: expo10(3),\n  mwei: expo10(6),\n  Mwei: expo10(6),\n  lovelace: expo10(6),\n  picoether: expo10(6),\n  gwei: expo10(9),\n  Gwei: expo10(9),\n  shannon: expo10(9),\n  nanoether: expo10(9),\n  nano: expo10(9),\n  szabo: expo10(12),\n  microether: expo10(12),\n  micro: expo10(12),\n  finney: expo10(15),\n  milliether: expo10(15),\n  milli: expo10(15),\n  ether: expo10(18),\n  kether: expo10(21),\n  grand: expo10(21),\n  mether: expo10(24),\n  gether: expo10(27),\n  tether: expo10(30)\n};\n/**\r\n * Convert a value from bytes to Uint8Array\r\n * @param data - Data to be converted\r\n * @returns - The Uint8Array representation of the input data\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\r\n * > Uint8Array(1) [ 171 ]\r\n * ```\r\n */\nexport const bytesToUint8Array = data => {\n  validator.validate(['bytes'], [data]);\n  if (data instanceof Uint8Array) {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    return new Uint8Array(data);\n  }\n  if (typeof data === 'string') {\n    return validatorUtils.hexToUint8Array(data);\n  }\n  throw new InvalidBytesError(data);\n};\n/**\r\n * @internal\r\n */\nconst {\n  uint8ArrayToHexString\n} = validatorUtils;\n/**\r\n * Convert a byte array to a hex string\r\n * @param bytes - Byte array to be converted\r\n * @returns - The hex string representation of the input byte array\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\r\n * > \"0x480c\"\r\n *\r\n */\nexport const bytesToHex = bytes => uint8ArrayToHexString(bytesToUint8Array(bytes));\n/**\r\n * Convert a hex string to a byte array\r\n * @param hex - Hex string to be converted\r\n * @returns - The byte array representation of the input hex string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToBytes('0x74657374'));\r\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\r\n * ```\r\n */\nexport const hexToBytes = bytes => {\n  if (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\n    return bytesToUint8Array(`0x${bytes}`);\n  }\n  return bytesToUint8Array(bytes);\n};\n/**\r\n * Converts value to it's number representation\r\n * @param value - Hex string to be converted\r\n * @returns - The number representation of the input value\r\n *\r\n * @example\r\n * ```ts\r\n * conoslle.log(web3.utils.hexToNumber('0xa'));\r\n * > 10\r\n * ```\r\n */\nexport const hexToNumber = value => {\n  validator.validate(['hex'], [value]);\n  // To avoid duplicate code and circular dependency we will\n  // use `hexToNumber` implementation from `web3-validator`\n  return validatorUtils.hexToNumber(value);\n};\n/**\r\n * Converts value to it's number representation @alias `hexToNumber`\r\n */\nexport const toDecimal = hexToNumber;\n/**\r\n * Converts value to it's hex representation\r\n * @param value - Value to be converted\r\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\r\n * @returns - The hex representation of the input value\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.numberToHex(10));\r\n * > \"0xa\"\r\n * ```\r\n */\nexport const numberToHex = (value, hexstrict) => {\n  validator.validate(['int'], [value]);\n  // To avoid duplicate code and circular dependency we will\n  // use `numberToHex` implementation from `web3-validator`\n  let updatedValue = validatorUtils.numberToHex(value);\n  // return validatorUtils.numberToHex(value);\n  if (hexstrict) {\n    if (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\n      // To avoid duplicate a circular dependancy we will not be using the padLeft method\n      updatedValue = '0x0'.concat(updatedValue.slice(2));\n    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-')) updatedValue = '-0x0'.concat(updatedValue.slice(3));\n  }\n  return updatedValue;\n};\n/**\r\n * Converts value to it's hex representation @alias `numberToHex`\r\n *\r\n */\nexport const fromDecimal = numberToHex;\n/**\r\n * Converts value to it's decimal representation in string\r\n * @param value - Hex string to be converted\r\n * @returns - The decimal representation of the input value\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToNumberString('0xa'));\r\n * > \"10\"\r\n * ```\r\n */\nexport const hexToNumberString = data => hexToNumber(data).toString();\n/**\r\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\r\n * @param str - Utf8 string to be converted\r\n * @returns - The hex representation of the input string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(utf8ToHex('web3.js'));\r\n * > \"0x776562332e6a73\"\r\n *\r\n */\nexport const utf8ToHex = str => {\n  validator.validate(['string'], [str]);\n  // To be compatible with 1.x trim null character\n  // eslint-disable-next-line no-control-regex\n  let strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, '');\n  // eslint-disable-next-line no-control-regex\n  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\n  return bytesToHex(new TextEncoder().encode(strWithoutNullCharacter));\n};\n/**\r\n * @alias utf8ToHex\r\n */\nexport const fromUtf8 = utf8ToHex;\n/**\r\n * @alias utf8ToHex\r\n */\nexport const stringToHex = utf8ToHex;\n/**\r\n * Should be called to get utf8 from it's hex representation\r\n * @param str - Hex string to be converted\r\n * @returns - Utf8 string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\r\n * > Hello World\r\n * ```\r\n */\nexport const hexToUtf8 = str => bytesToUtf8(hexToBytes(str));\n/**\r\n * @alias hexToUtf8\r\n */\nexport const toUtf8 = input => {\n  if (typeof input === 'string') {\n    return hexToUtf8(input);\n  }\n  validator.validate(['bytes'], [input]);\n  return bytesToUtf8(input);\n};\n/**\r\n * @alias hexToUtf8\r\n */\nexport const hexToString = hexToUtf8;\n/**\r\n * Should be called to get hex representation (prefixed by 0x) of ascii string\r\n * @param str - String to be converted to hex\r\n * @returns - Hex string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.asciiToHex('Hello World'));\r\n * > 0x48656c6c6f20576f726c64\r\n * ```\r\n */\nexport const asciiToHex = str => {\n  validator.validate(['string'], [str]);\n  let hexString = '';\n  for (let i = 0; i < str.length; i += 1) {\n    const hexCharCode = str.charCodeAt(i).toString(16);\n    // might need a leading 0\n    hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\n  }\n  return `0x${hexString}`;\n};\n/**\r\n * @alias asciiToHex\r\n */\nexport const fromAscii = asciiToHex;\n/**\r\n * Should be called to get ascii from it's hex representation\r\n * @param str - Hex string to be converted to ascii\r\n * @returns - Ascii string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\r\n * > Hello World\r\n * ```\r\n */\nexport const hexToAscii = str => {\n  const decoder = new TextDecoder('ascii');\n  return decoder.decode(hexToBytes(str));\n};\n/**\r\n * @alias hexToAscii\r\n */\nexport const toAscii = hexToAscii;\n/**\r\n * Auto converts any given value into it's hex representation.\r\n * @param value - Value to be converted to hex\r\n * @param returnType - If true, it will return the type of the value\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toHex(10));\r\n * > 0xa\r\n *\r\n * console.log(web3.utils.toHex('0x123', true));\r\n * > bytes\r\n *```\r\n */\nexport const toHex = (value, returnType) => {\n  if (typeof value === 'string' && isAddress(value)) {\n    return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n  }\n  if (typeof value === 'boolean') {\n    // eslint-disable-next-line no-nested-ternary\n    return returnType ? 'bool' : value ? '0x01' : '0x00';\n  }\n  if (typeof value === 'number') {\n    // eslint-disable-next-line no-nested-ternary\n    return returnType ? value < 0 ? 'int256' : 'uint256' : numberToHex(value);\n  }\n  if (typeof value === 'bigint') {\n    return returnType ? 'bigint' : numberToHex(value);\n  }\n  if (typeof value === 'object' && !!value) {\n    return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n  }\n  if (typeof value === 'string') {\n    if (value.startsWith('-0x') || value.startsWith('-0X')) {\n      return returnType ? 'int256' : numberToHex(value);\n    }\n    if (isHexStrict(value)) {\n      return returnType ? 'bytes' : value;\n    }\n    if (isHex(value) && !isInt(value)) {\n      return returnType ? 'bytes' : `0x${value}`;\n    }\n    if (!Number.isFinite(value)) {\n      return returnType ? 'string' : utf8ToHex(value);\n    }\n  }\n  throw new HexProcessingError(value);\n};\n/**\r\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\r\n * @param value - The value to convert\r\n * @returns - Returns the value in number or bigint representation\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toNumber(1));\r\n * > 1\r\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\r\n * > 9007199254740991\r\n *\r\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\r\n * > 9007199254740991\r\n *\r\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\r\n * > 9007199254740992n\r\n *\r\n * ```\r\n */\nexport const toNumber = value => {\n  if (typeof value === 'number') {\n    return value;\n  }\n  if (typeof value === 'bigint') {\n    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;\n  }\n  if (typeof value === 'string' && isHexStrict(value)) {\n    return hexToNumber(value);\n  }\n  try {\n    return toNumber(BigInt(value));\n  } catch (_a) {\n    throw new InvalidNumberError(value);\n  }\n};\n/**\r\n * Auto converts any given value into it's bigint representation\r\n *\r\n * @param value - The value to convert\r\n * @returns - Returns the value in bigint representation\r\n\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toBigInt(1));\r\n * > 1n\r\n * ```\r\n */\nexport const toBigInt = value => {\n  if (typeof value === 'number') {\n    return BigInt(value);\n  }\n  if (typeof value === 'bigint') {\n    return value;\n  }\n  // isHex passes for dec, too\n  if (typeof value === 'string' && isHex(value)) {\n    return BigInt(value);\n  }\n  throw new InvalidNumberError(value);\n};\n/**\r\n * Takes a number of wei and converts it to any other ether unit.\r\n * @param number - The value in wei\r\n * @param unit - The unit to convert to\r\n * @returns - Returns the converted value in the given unit\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\r\n * > 0.000000000000000001\r\n *\r\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\r\n * > 0.000000001\r\n * ```\r\n */\nexport const fromWei = (number, unit) => {\n  const denomination = ethUnitMap[unit];\n  if (!denomination) {\n    throw new InvalidUnitError(unit);\n  }\n  // value in wei would always be integer\n  // 13456789, 1234\n  const value = String(toNumber(number));\n  // count number of zeros in denomination\n  // 1000000 -> 6\n  const numberOfZerosInDenomination = denomination.toString().length - 1;\n  if (numberOfZerosInDenomination <= 0) {\n    return value.toString();\n  }\n  // pad the value with required zeros\n  // 13456789 -> 13456789, 1234 -> 001234\n  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');\n  // get the integer part of value by counting number of zeros from start\n  // 13456789 -> '13'\n  // 001234 -> ''\n  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);\n  // get the fraction part of value by counting number of zeros backward\n  // 13456789 -> '456789'\n  // 001234 -> '001234'\n  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\n  if (integer === '') {\n    return `0.${fraction}`;\n  }\n  if (fraction === '') {\n    return integer;\n  }\n  return `${integer}.${fraction}`;\n};\n/**\r\n * Takes a number of a unit and converts it to wei.\r\n *\r\n * @param number - The number to convert.\r\n * @param unit - {@link EtherUnits} The unit of the number passed.\r\n * @returns The number converted to wei.\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\r\n * > 1000000000000000 //(wei)\r\n * ```\r\n */\n// todo in 1.x unit defaults to 'ether'\nexport const toWei = (number, unit) => {\n  validator.validate(['number'], [number]);\n  const denomination = ethUnitMap[unit];\n  if (!denomination) {\n    throw new InvalidUnitError(unit);\n  }\n  // if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n  // to avoid `fraction` to be null use `concat` with empty string\n  const [integer, fraction] = String(typeof number === 'string' && !isHexStrict(number) ? number : toNumber(number)).split('.').concat('');\n  // join the value removing `.` from\n  // 24.56 -> 2456\n  const value = BigInt(`${integer}${fraction}`);\n  // multiply value with denomination\n  // 2456 * 1000000 -> 2456000000\n  const updatedValue = value * denomination;\n  // count number of zeros in denomination\n  const numberOfZerosInDenomination = denomination.toString().length - 1;\n  // check which either `fraction` or `denomination` have lower number of zeros\n  const decimals = Math.min(fraction.length, numberOfZerosInDenomination);\n  if (decimals === 0) {\n    return updatedValue.toString();\n  }\n  // Add zeros to make length equal to required decimal points\n  // If string is larger than decimal points required then remove last zeros\n  return updatedValue.toString().padStart(decimals, '0').slice(0, -decimals);\n};\n/**\r\n * Will convert an upper or lowercase Ethereum address to a checksum address.\r\n * @param address - An address string\r\n * @returns\tThe checksum address\r\n * @example\r\n * ```ts\r\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\r\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\r\n * ```\r\n */\nexport const toChecksumAddress = address => {\n  if (!isAddress(address, false)) {\n    throw new InvalidAddressError(address);\n  }\n  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\n  const hash = bytesToHex(keccak256(utf8ToBytes(lowerCaseAddress)));\n  if (isNullish(hash) || hash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470') return ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n  let checksumAddress = '0x';\n  const addressHash = hash.replace(/^0x/i, '');\n  for (let i = 0; i < lowerCaseAddress.length; i += 1) {\n    // If ith character is 8 to f then make it uppercase\n    if (parseInt(addressHash[i], 16) > 7) {\n      checksumAddress += lowerCaseAddress[i].toUpperCase();\n    } else {\n      checksumAddress += lowerCaseAddress[i];\n    }\n  }\n  return checksumAddress;\n};","map":{"version":3,"names":["keccak256","bytesToUtf8","utf8ToBytes","isAddress","isHex","isHexStrict","isNullish","isInt","utils","validatorUtils","validator","HexProcessingError","InvalidAddressError","InvalidBytesError","InvalidNumberError","InvalidUnitError","base","BigInt","expo10","expo","ethUnitMap","noether","wei","kwei","Kwei","babbage","femtoether","mwei","Mwei","lovelace","picoether","gwei","Gwei","shannon","nanoether","nano","szabo","microether","micro","finney","milliether","milli","ether","kether","grand","mether","gether","tether","bytesToUint8Array","data","validate","Uint8Array","Array","isArray","hexToUint8Array","uint8ArrayToHexString","bytesToHex","bytes","hexToBytes","slice","toLowerCase","hexToNumber","value","toDecimal","numberToHex","hexstrict","updatedValue","startsWith","length","concat","fromDecimal","hexToNumberString","toString","utf8ToHex","str","strWithoutNullCharacter","replace","TextEncoder","encode","fromUtf8","stringToHex","hexToUtf8","toUtf8","input","hexToString","asciiToHex","hexString","i","hexCharCode","charCodeAt","fromAscii","hexToAscii","decoder","TextDecoder","decode","toAscii","toHex","returnType","JSON","stringify","Number","isFinite","toNumber","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","_a","toBigInt","fromWei","number","unit","denomination","String","numberOfZerosInDenomination","zeroPaddedValue","padStart","integer","fraction","toWei","split","decimals","Math","min","toChecksumAddress","address","lowerCaseAddress","hash","checksumAddress","addressHash","parseInt","toUpperCase"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-utils\\src\\converters.ts"],"sourcesContent":["﻿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\r\nimport { bytesToUtf8, utf8ToBytes } from 'ethereum-cryptography/utils.js';\r\nimport { Address, Bytes, HexString, Numbers, ValueTypes } from 'web3-types';\r\nimport {\r\n\tisAddress,\r\n\tisHex,\r\n\tisHexStrict,\r\n\tisNullish,\r\n\tisInt,\r\n\tutils as validatorUtils,\r\n\tvalidator,\r\n} from 'web3-validator';\r\n\r\nimport {\r\n\tHexProcessingError,\r\n\tInvalidAddressError,\r\n\tInvalidBytesError,\r\n\tInvalidNumberError,\r\n\tInvalidUnitError,\r\n} from 'web3-errors';\r\n\r\nconst base = BigInt(10);\r\nconst expo10 = (expo: number) => base ** BigInt(expo);\r\n\r\n// Ref: https://ethdocs.org/en/latest/ether.html\r\n/** @internal */\r\nexport const ethUnitMap = {\r\n\tnoether: BigInt('0'),\r\n\twei: BigInt(1),\r\n\tkwei: expo10(3),\r\n\tKwei: expo10(3),\r\n\tbabbage: expo10(3),\r\n\tfemtoether: expo10(3),\r\n\tmwei: expo10(6),\r\n\tMwei: expo10(6),\r\n\tlovelace: expo10(6),\r\n\tpicoether: expo10(6),\r\n\tgwei: expo10(9),\r\n\tGwei: expo10(9),\r\n\tshannon: expo10(9),\r\n\tnanoether: expo10(9),\r\n\tnano: expo10(9),\r\n\tszabo: expo10(12),\r\n\tmicroether: expo10(12),\r\n\tmicro: expo10(12),\r\n\tfinney: expo10(15),\r\n\tmilliether: expo10(15),\r\n\tmilli: expo10(15),\r\n\tether: expo10(18),\r\n\tkether: expo10(21),\r\n\tgrand: expo10(21),\r\n\tmether: expo10(24),\r\n\tgether: expo10(27),\r\n\ttether: expo10(30),\r\n};\r\n\r\nexport type EtherUnits = keyof typeof ethUnitMap;\r\n/**\r\n * Convert a value from bytes to Uint8Array\r\n * @param data - Data to be converted\r\n * @returns - The Uint8Array representation of the input data\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\r\n * > Uint8Array(1) [ 171 ]\r\n * ```\r\n */\r\nexport const bytesToUint8Array = (data: Bytes): Uint8Array | never => {\r\n\tvalidator.validate(['bytes'], [data]);\r\n\r\n\tif (data instanceof Uint8Array) {\r\n\t\treturn data;\r\n\t}\r\n\r\n\tif (Array.isArray(data)) {\r\n\t\treturn new Uint8Array(data);\r\n\t}\r\n\r\n\tif (typeof data === 'string') {\r\n\t\treturn validatorUtils.hexToUint8Array(data);\r\n\t}\r\n\r\n\tthrow new InvalidBytesError(data);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nconst { uint8ArrayToHexString } = validatorUtils;\r\n\r\n/**\r\n * Convert a byte array to a hex string\r\n * @param bytes - Byte array to be converted\r\n * @returns - The hex string representation of the input byte array\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\r\n * > \"0x480c\"\r\n *\r\n */\r\nexport const bytesToHex = (bytes: Bytes): HexString =>\r\n\tuint8ArrayToHexString(bytesToUint8Array(bytes));\r\n\r\n/**\r\n * Convert a hex string to a byte array\r\n * @param hex - Hex string to be converted\r\n * @returns - The byte array representation of the input hex string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToBytes('0x74657374'));\r\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\r\n * ```\r\n */\r\nexport const hexToBytes = (bytes: HexString): Uint8Array => {\r\n\tif (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\r\n\t\treturn bytesToUint8Array(`0x${bytes}`);\r\n\t}\r\n\treturn bytesToUint8Array(bytes);\r\n};\r\n\r\n/**\r\n * Converts value to it's number representation\r\n * @param value - Hex string to be converted\r\n * @returns - The number representation of the input value\r\n *\r\n * @example\r\n * ```ts\r\n * conoslle.log(web3.utils.hexToNumber('0xa'));\r\n * > 10\r\n * ```\r\n */\r\nexport const hexToNumber = (value: HexString): bigint | number => {\r\n\tvalidator.validate(['hex'], [value]);\r\n\r\n\t// To avoid duplicate code and circular dependency we will\r\n\t// use `hexToNumber` implementation from `web3-validator`\r\n\treturn validatorUtils.hexToNumber(value);\r\n};\r\n\r\n/**\r\n * Converts value to it's number representation @alias `hexToNumber`\r\n */\r\nexport const toDecimal = hexToNumber;\r\n\r\n/**\r\n * Converts value to it's hex representation\r\n * @param value - Value to be converted\r\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\r\n * @returns - The hex representation of the input value\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.numberToHex(10));\r\n * > \"0xa\"\r\n * ```\r\n */\r\nexport const numberToHex = (value: Numbers, hexstrict?: boolean): HexString => {\r\n\tvalidator.validate(['int'], [value]);\r\n\t// To avoid duplicate code and circular dependency we will\r\n\t// use `numberToHex` implementation from `web3-validator`\r\n\tlet updatedValue = validatorUtils.numberToHex(value);\r\n\t// return validatorUtils.numberToHex(value);\r\n\tif (hexstrict) {\r\n\t\tif (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\r\n\t\t\t// To avoid duplicate a circular dependancy we will not be using the padLeft method\r\n\t\t\tupdatedValue = '0x0'.concat(updatedValue.slice(2));\r\n\t\t} else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-'))\r\n\t\t\tupdatedValue = '-0x0'.concat(updatedValue.slice(3));\r\n\t}\r\n\treturn updatedValue;\r\n};\r\n/**\r\n * Converts value to it's hex representation @alias `numberToHex`\r\n *\r\n */\r\nexport const fromDecimal = numberToHex;\r\n\r\n/**\r\n * Converts value to it's decimal representation in string\r\n * @param value - Hex string to be converted\r\n * @returns - The decimal representation of the input value\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToNumberString('0xa'));\r\n * > \"10\"\r\n * ```\r\n */\r\nexport const hexToNumberString = (data: HexString): string => hexToNumber(data).toString();\r\n\r\n/**\r\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\r\n * @param str - Utf8 string to be converted\r\n * @returns - The hex representation of the input string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(utf8ToHex('web3.js'));\r\n * > \"0x776562332e6a73\"\r\n *\r\n */\r\nexport const utf8ToHex = (str: string): HexString => {\r\n\tvalidator.validate(['string'], [str]);\r\n\r\n\t// To be compatible with 1.x trim null character\r\n\t// eslint-disable-next-line no-control-regex\r\n\tlet strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, '');\r\n\t// eslint-disable-next-line no-control-regex\r\n\tstrWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\r\n\r\n\treturn bytesToHex(new TextEncoder().encode(strWithoutNullCharacter));\r\n};\r\n\r\n/**\r\n * @alias utf8ToHex\r\n */\r\n\r\nexport const fromUtf8 = utf8ToHex;\r\n/**\r\n * @alias utf8ToHex\r\n */\r\nexport const stringToHex = utf8ToHex;\r\n\r\n/**\r\n * Should be called to get utf8 from it's hex representation\r\n * @param str - Hex string to be converted\r\n * @returns - Utf8 string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\r\n * > Hello World\r\n * ```\r\n */\r\nexport const hexToUtf8 = (str: HexString): string => bytesToUtf8(hexToBytes(str));\r\n\r\n/**\r\n * @alias hexToUtf8\r\n */\r\nexport const toUtf8 = (input: HexString | Uint8Array) => {\r\n\tif (typeof input === 'string') {\r\n\t\treturn hexToUtf8(input);\r\n\t}\r\n\tvalidator.validate(['bytes'], [input]);\r\n\treturn bytesToUtf8(input);\r\n};\r\n\r\n/**\r\n * @alias hexToUtf8\r\n */\r\nexport const hexToString = hexToUtf8;\r\n\r\n/**\r\n * Should be called to get hex representation (prefixed by 0x) of ascii string\r\n * @param str - String to be converted to hex\r\n * @returns - Hex string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.asciiToHex('Hello World'));\r\n * > 0x48656c6c6f20576f726c64\r\n * ```\r\n */\r\nexport const asciiToHex = (str: string): HexString => {\r\n\tvalidator.validate(['string'], [str]);\r\n\tlet hexString = '';\r\n\tfor (let i = 0; i < str.length; i += 1) {\r\n\t\tconst hexCharCode = str.charCodeAt(i).toString(16);\r\n\t\t// might need a leading 0\r\n\t\thexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\r\n\t}\r\n\treturn `0x${hexString}`;\r\n};\r\n\r\n/**\r\n * @alias asciiToHex\r\n */\r\nexport const fromAscii = asciiToHex;\r\n\r\n/**\r\n * Should be called to get ascii from it's hex representation\r\n * @param str - Hex string to be converted to ascii\r\n * @returns - Ascii string\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\r\n * > Hello World\r\n * ```\r\n */\r\nexport const hexToAscii = (str: HexString): string => {\r\n\tconst decoder = new TextDecoder('ascii');\r\n\treturn decoder.decode(hexToBytes(str));\r\n};\r\n\r\n/**\r\n * @alias hexToAscii\r\n */\r\nexport const toAscii = hexToAscii;\r\n\r\n/**\r\n * Auto converts any given value into it's hex representation.\r\n * @param value - Value to be converted to hex\r\n * @param returnType - If true, it will return the type of the value\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toHex(10));\r\n * > 0xa\r\n *\r\n * console.log(web3.utils.toHex('0x123', true));\r\n * > bytes\r\n *```\r\n */\r\nexport const toHex = (\r\n\tvalue: Numbers | Bytes | Address | boolean | object,\r\n\treturnType?: boolean,\r\n): HexString | ValueTypes => {\r\n\tif (typeof value === 'string' && isAddress(value)) {\r\n\t\treturn returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\r\n\t}\r\n\r\n\tif (typeof value === 'boolean') {\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\treturn returnType ? 'bool' : value ? '0x01' : '0x00';\r\n\t}\r\n\r\n\tif (typeof value === 'number') {\r\n\t\t// eslint-disable-next-line no-nested-ternary\r\n\t\treturn returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value);\r\n\t}\r\n\r\n\tif (typeof value === 'bigint') {\r\n\t\treturn returnType ? 'bigint' : numberToHex(value);\r\n\t}\r\n\r\n\tif (typeof value === 'object' && !!value) {\r\n\t\treturn returnType ? 'string' : utf8ToHex(JSON.stringify(value));\r\n\t}\r\n\r\n\tif (typeof value === 'string') {\r\n\t\tif (value.startsWith('-0x') || value.startsWith('-0X')) {\r\n\t\t\treturn returnType ? 'int256' : numberToHex(value);\r\n\t\t}\r\n\r\n\t\tif (isHexStrict(value)) {\r\n\t\t\treturn returnType ? 'bytes' : value;\r\n\t\t}\r\n\t\tif (isHex(value) && !isInt(value)) {\r\n\t\t\treturn returnType ? 'bytes' : `0x${value}`;\r\n\t\t}\r\n\r\n\t\tif (!Number.isFinite(value)) {\r\n\t\t\treturn returnType ? 'string' : utf8ToHex(value);\r\n\t\t}\r\n\t}\r\n\r\n\tthrow new HexProcessingError(value);\r\n};\r\n\r\n/**\r\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\r\n * @param value - The value to convert\r\n * @returns - Returns the value in number or bigint representation\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toNumber(1));\r\n * > 1\r\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\r\n * > 9007199254740991\r\n *\r\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\r\n * > 9007199254740991\r\n *\r\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\r\n * > 9007199254740992n\r\n *\r\n * ```\r\n */\r\nexport const toNumber = (value: Numbers): number | bigint => {\r\n\tif (typeof value === 'number') {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tif (typeof value === 'bigint') {\r\n\t\treturn value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER\r\n\t\t\t? Number(value)\r\n\t\t\t: value;\r\n\t}\r\n\r\n\tif (typeof value === 'string' && isHexStrict(value)) {\r\n\t\treturn hexToNumber(value);\r\n\t}\r\n\r\n\ttry {\r\n\t\treturn toNumber(BigInt(value));\r\n\t} catch {\r\n\t\tthrow new InvalidNumberError(value);\r\n\t}\r\n};\r\n\r\n/**\r\n * Auto converts any given value into it's bigint representation\r\n *\r\n * @param value - The value to convert\r\n * @returns - Returns the value in bigint representation\r\n\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toBigInt(1));\r\n * > 1n\r\n * ```\r\n */\r\nexport const toBigInt = (value: unknown): bigint => {\r\n\tif (typeof value === 'number') {\r\n\t\treturn BigInt(value);\r\n\t}\r\n\r\n\tif (typeof value === 'bigint') {\r\n\t\treturn value;\r\n\t}\r\n\r\n\t// isHex passes for dec, too\r\n\tif (typeof value === 'string' && isHex(value)) {\r\n\t\treturn BigInt(value);\r\n\t}\r\n\r\n\tthrow new InvalidNumberError(value);\r\n};\r\n\r\n/**\r\n * Takes a number of wei and converts it to any other ether unit.\r\n * @param number - The value in wei\r\n * @param unit - The unit to convert to\r\n * @returns - Returns the converted value in the given unit\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\r\n * > 0.000000000000000001\r\n *\r\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\r\n * > 0.000000001\r\n * ```\r\n */\r\nexport const fromWei = (number: Numbers, unit: EtherUnits): string => {\r\n\tconst denomination = ethUnitMap[unit];\r\n\r\n\tif (!denomination) {\r\n\t\tthrow new InvalidUnitError(unit);\r\n\t}\r\n\r\n\t// value in wei would always be integer\r\n\t// 13456789, 1234\r\n\tconst value = String(toNumber(number));\r\n\r\n\t// count number of zeros in denomination\r\n\t// 1000000 -> 6\r\n\tconst numberOfZerosInDenomination = denomination.toString().length - 1;\r\n\r\n\tif (numberOfZerosInDenomination <= 0) {\r\n\t\treturn value.toString();\r\n\t}\r\n\r\n\t// pad the value with required zeros\r\n\t// 13456789 -> 13456789, 1234 -> 001234\r\n\tconst zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');\r\n\r\n\t// get the integer part of value by counting number of zeros from start\r\n\t// 13456789 -> '13'\r\n\t// 001234 -> ''\r\n\tconst integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);\r\n\r\n\t// get the fraction part of value by counting number of zeros backward\r\n\t// 13456789 -> '456789'\r\n\t// 001234 -> '001234'\r\n\tconst fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\r\n\r\n\tif (integer === '') {\r\n\t\treturn `0.${fraction}`;\r\n\t}\r\n\r\n\tif (fraction === '') {\r\n\t\treturn integer;\r\n\t}\r\n\r\n\treturn `${integer}.${fraction}`;\r\n};\r\n\r\n/**\r\n * Takes a number of a unit and converts it to wei.\r\n *\r\n * @param number - The number to convert.\r\n * @param unit - {@link EtherUnits} The unit of the number passed.\r\n * @returns The number converted to wei.\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\r\n * > 1000000000000000 //(wei)\r\n * ```\r\n */\r\n// todo in 1.x unit defaults to 'ether'\r\nexport const toWei = (number: Numbers, unit: EtherUnits): string => {\r\n\tvalidator.validate(['number'], [number]);\r\n\r\n\tconst denomination = ethUnitMap[unit];\r\n\r\n\tif (!denomination) {\r\n\t\tthrow new InvalidUnitError(unit);\r\n\t}\r\n\r\n\t// if value is decimal e.g. 24.56 extract `integer` and `fraction` part\r\n\t// to avoid `fraction` to be null use `concat` with empty string\r\n\tconst [integer, fraction] = String(\r\n\t\ttypeof number === 'string' && !isHexStrict(number) ? number : toNumber(number),\r\n\t)\r\n\t\t.split('.')\r\n\t\t.concat('');\r\n\r\n\t// join the value removing `.` from\r\n\t// 24.56 -> 2456\r\n\tconst value = BigInt(`${integer}${fraction}`);\r\n\r\n\t// multiply value with denomination\r\n\t// 2456 * 1000000 -> 2456000000\r\n\tconst updatedValue = value * denomination;\r\n\r\n\t// count number of zeros in denomination\r\n\tconst numberOfZerosInDenomination = denomination.toString().length - 1;\r\n\r\n\t// check which either `fraction` or `denomination` have lower number of zeros\r\n\tconst decimals = Math.min(fraction.length, numberOfZerosInDenomination);\r\n\r\n\tif (decimals === 0) {\r\n\t\treturn updatedValue.toString();\r\n\t}\r\n\r\n\t// Add zeros to make length equal to required decimal points\r\n\t// If string is larger than decimal points required then remove last zeros\r\n\treturn updatedValue.toString().padStart(decimals, '0').slice(0, -decimals);\r\n};\r\n\r\n/**\r\n * Will convert an upper or lowercase Ethereum address to a checksum address.\r\n * @param address - An address string\r\n * @returns\tThe checksum address\r\n * @example\r\n * ```ts\r\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\r\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\r\n * ```\r\n */\r\nexport const toChecksumAddress = (address: Address): string => {\r\n\tif (!isAddress(address, false)) {\r\n\t\tthrow new InvalidAddressError(address);\r\n\t}\r\n\r\n\tconst lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\r\n\r\n\tconst hash = bytesToHex(keccak256(utf8ToBytes(lowerCaseAddress)));\r\n\r\n\tif (\r\n\t\tisNullish(hash) ||\r\n\t\thash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\r\n\t)\r\n\t\treturn ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\r\n\r\n\tlet checksumAddress = '0x';\r\n\r\n\tconst addressHash = hash.replace(/^0x/i, '');\r\n\r\n\tfor (let i = 0; i < lowerCaseAddress.length; i += 1) {\r\n\t\t// If ith character is 8 to f then make it uppercase\r\n\t\tif (parseInt(addressHash[i], 16) > 7) {\r\n\t\t\tchecksumAddress += lowerCaseAddress[i].toUpperCase();\r\n\t\t} else {\r\n\t\t\tchecksumAddress += lowerCaseAddress[i];\r\n\t\t}\r\n\t}\r\n\treturn checksumAddress;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
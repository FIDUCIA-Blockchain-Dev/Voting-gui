{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ConnectionError, ConnectionNotOpenError, InvalidClientError, MaxAttemptsReachedOnReconnectingError, PendingRequestsOnReconnectingError, RequestAlreadySentError, Web3WSProviderError } from 'web3-errors';\nimport { Eip1193Provider } from './web3_eip1193_provider.js';\nimport { ChunkResponseParser } from './chunk_response_parser.js';\nimport { isNullish } from './validation.js';\nimport { Web3DeferredPromise } from './web3_deferred_promise.js';\nimport * as jsonRpc from './json_rpc.js';\nconst DEFAULT_RECONNECTION_OPTIONS = {\n  autoReconnect: true,\n  delay: 5000,\n  maxAttempts: 5\n};\nconst NORMAL_CLOSE_CODE = 1000; // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\nexport class SocketProvider extends Eip1193Provider {\n  /**\r\n   * This is an abstract class for implementing a socket provider (e.g. WebSocket, IPC). It extends the EIP-1193 provider {@link EIP1193Provider}.\r\n   * @param socketPath - The path to the socket (e.g. /ipc/path or ws://localhost:8546)\r\n   * @param socketOptions - The options for the socket connection. Its type is supposed to be specified in the inherited classes.\r\n   * @param reconnectOptions - The options for the socket reconnection {@link ReconnectOptions}\r\n   */\n  constructor(socketPath, socketOptions, reconnectOptions) {\n    super();\n    this._connectionStatus = 'connecting';\n    // Message handlers. Due to bounding of `this` and removing the listeners we have to keep it's reference.\n    this._onMessageHandler = this._onMessage.bind(this);\n    this._onOpenHandler = this._onConnect.bind(this);\n    this._onCloseHandler = this._onCloseEvent.bind(this);\n    this._onErrorHandler = this._onError.bind(this);\n    if (!this._validateProviderPath(socketPath)) throw new InvalidClientError(socketPath);\n    this._socketPath = socketPath;\n    this._socketOptions = socketOptions;\n    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});\n    this._pendingRequestsQueue = new Map();\n    this._sentRequestsQueue = new Map();\n    this._init();\n    this.connect();\n    this.chunkResponseParser = new ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);\n    this.chunkResponseParser.onError(() => {\n      this._clearQueues();\n    });\n    this.isReconnecting = false;\n  }\n  get SocketConnection() {\n    return this._socketConnection;\n  }\n  _init() {\n    this._reconnectAttempts = 0;\n  }\n  /**\r\n   * Try to establish a connection to the socket\r\n   */\n  connect() {\n    try {\n      this._openSocketConnection();\n      this._connectionStatus = 'connecting';\n      this._addSocketListeners();\n    } catch (e) {\n      if (!this.isReconnecting) {\n        this._connectionStatus = 'disconnected';\n        if (e && e.message) {\n          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);\n        } else {\n          throw new InvalidClientError(this._socketPath);\n        }\n      } else {\n        setImmediate(() => {\n          this._reconnect();\n        });\n      }\n    }\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _validateProviderPath(path) {\n    return !!path;\n  }\n  /**\r\n   *\r\n   * @returns `true` if the socket supports subscriptions\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n  supportsSubscriptions() {\n    return true;\n  }\n  on(type, listener) {\n    this._eventEmitter.on(type, listener);\n  }\n  once(type, listener) {\n    this._eventEmitter.once(type, listener);\n  }\n  removeListener(type, listener) {\n    this._eventEmitter.removeListener(type, listener);\n  }\n  _onDisconnect(code, data) {\n    this._connectionStatus = 'disconnected';\n    super._onDisconnect(code, data);\n  }\n  /**\r\n   * Disconnects the socket\r\n   * @param code - The code to be sent to the server\r\n   * @param data - The data to be sent to the server\r\n   */\n  disconnect(code, data) {\n    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE;\n    this._removeSocketListeners();\n    if (this.getStatus() !== 'disconnected') {\n      this._closeSocketConnection(disconnectCode, data);\n    }\n    this._onDisconnect(disconnectCode, data);\n  }\n  /**\r\n   * Removes all listeners for the specified event type.\r\n   * @param type - The event type to remove the listeners for\r\n   */\n  removeAllListeners(type) {\n    this._eventEmitter.removeAllListeners(type);\n  }\n  _onError(event) {\n    // do not emit error while trying to reconnect\n    if (this.isReconnecting) {\n      this._reconnect();\n    } else {\n      this._eventEmitter.emit('error', event);\n    }\n  }\n  /**\r\n   * Resets the socket, removing all listeners and pending requests\r\n   */\n  reset() {\n    this._sentRequestsQueue.clear();\n    this._pendingRequestsQueue.clear();\n    this._init();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n  }\n  _reconnect() {\n    if (this.isReconnecting) {\n      return;\n    }\n    this.isReconnecting = true;\n    if (this._sentRequestsQueue.size > 0) {\n      this._sentRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());\n        this._sentRequestsQueue.delete(key);\n      });\n    }\n    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {\n      this._reconnectAttempts += 1;\n      setTimeout(() => {\n        this._removeSocketListeners();\n        this.connect();\n        this.isReconnecting = false;\n      }, this._reconnectOptions.delay);\n    } else {\n      this.isReconnecting = false;\n      this._clearQueues();\n      this._removeSocketListeners();\n      this._eventEmitter.emit('error', new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));\n    }\n  }\n  /**\r\n   *  Creates a request object to be sent to the server\r\n   */\n  request(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isNullish(this._socketConnection)) {\n        throw new Error('Connection is undefined');\n      }\n      // if socket disconnected - open connection\n      if (this.getStatus() === 'disconnected') {\n        this.connect();\n      }\n      const requestId = jsonRpc.isBatchRequest(request) ? request[0].id : request.id;\n      if (!requestId) {\n        throw new Web3WSProviderError('Request Id not defined');\n      }\n      if (this._sentRequestsQueue.has(requestId)) {\n        throw new RequestAlreadySentError(requestId);\n      }\n      const deferredPromise = new Web3DeferredPromise();\n      deferredPromise.catch(error => {\n        this._eventEmitter.emit('error', error);\n      });\n      const reqItem = {\n        payload: request,\n        deferredPromise\n      };\n      if (this.getStatus() === 'connecting') {\n        this._pendingRequestsQueue.set(requestId, reqItem);\n        return reqItem.deferredPromise;\n      }\n      this._sentRequestsQueue.set(requestId, reqItem);\n      try {\n        this._sendToSocket(reqItem.payload);\n      } catch (error) {\n        this._sentRequestsQueue.delete(requestId);\n        this._eventEmitter.emit('error', error);\n      }\n      return deferredPromise;\n    });\n  }\n  _onConnect() {\n    this._connectionStatus = 'connected';\n    this._reconnectAttempts = 0;\n    super._onConnect();\n    this._sendPendingRequests();\n  }\n  _sendPendingRequests() {\n    for (const [id, value] of this._pendingRequestsQueue.entries()) {\n      this._sendToSocket(value.payload);\n      this._pendingRequestsQueue.delete(id);\n      this._sentRequestsQueue.set(id, value);\n    }\n  }\n  _onMessage(event) {\n    const responses = this._parseResponses(event);\n    if (responses.length === 0) {\n      // no responses means lost connection, autoreconnect if possible\n      if (this._reconnectOptions.autoReconnect) {\n        this._reconnect();\n      }\n      return;\n    }\n    for (const response of responses) {\n      if (jsonRpc.isResponseWithNotification(response) && response.method.endsWith('_subscription')) {\n        this._eventEmitter.emit('message', response);\n        return;\n      }\n      const requestId = jsonRpc.isBatchResponse(response) ? response[0].id : response.id;\n      const requestItem = this._sentRequestsQueue.get(requestId);\n      if (!requestItem) {\n        return;\n      }\n      if (jsonRpc.isBatchResponse(response) || jsonRpc.isResponseWithResult(response) || jsonRpc.isResponseWithError(response)) {\n        this._eventEmitter.emit('message', response);\n        requestItem.deferredPromise.resolve(response);\n      }\n      this._sentRequestsQueue.delete(requestId);\n    }\n  }\n  _clearQueues(event) {\n    if (this._pendingRequestsQueue.size > 0) {\n      this._pendingRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new ConnectionNotOpenError(event));\n        this._pendingRequestsQueue.delete(key);\n      });\n    }\n    if (this._sentRequestsQueue.size > 0) {\n      this._sentRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new ConnectionNotOpenError(event));\n        this._sentRequestsQueue.delete(key);\n      });\n    }\n    this._removeSocketListeners();\n  }\n}","map":{"version":3,"names":["ConnectionError","ConnectionNotOpenError","InvalidClientError","MaxAttemptsReachedOnReconnectingError","PendingRequestsOnReconnectingError","RequestAlreadySentError","Web3WSProviderError","Eip1193Provider","ChunkResponseParser","isNullish","Web3DeferredPromise","jsonRpc","DEFAULT_RECONNECTION_OPTIONS","autoReconnect","delay","maxAttempts","NORMAL_CLOSE_CODE","SocketProvider","constructor","socketPath","socketOptions","reconnectOptions","_connectionStatus","_onMessageHandler","_onMessage","bind","_onOpenHandler","_onConnect","_onCloseHandler","_onCloseEvent","_onErrorHandler","_onError","_validateProviderPath","_socketPath","_socketOptions","_reconnectOptions","Object","assign","_pendingRequestsQueue","Map","_sentRequestsQueue","_init","connect","chunkResponseParser","_eventEmitter","onError","_clearQueues","isReconnecting","SocketConnection","_socketConnection","_reconnectAttempts","_openSocketConnection","_addSocketListeners","e","message","setImmediate","_reconnect","path","supportsSubscriptions","on","type","listener","once","removeListener","_onDisconnect","code","data","disconnect","disconnectCode","_removeSocketListeners","getStatus","_closeSocketConnection","removeAllListeners","event","emit","reset","clear","size","forEach","request","key","deferredPromise","reject","delete","setTimeout","Error","requestId","isBatchRequest","id","has","catch","error","reqItem","payload","set","_sendToSocket","_sendPendingRequests","value","entries","responses","_parseResponses","length","response","isResponseWithNotification","method","endsWith","isBatchResponse","requestItem","get","isResponseWithResult","isResponseWithError","resolve"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-utils\\src\\socket_provider.ts"],"sourcesContent":["/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\nimport {\r\n\tConnectionEvent,\r\n\tEip1193EventName,\r\n\tEthExecutionAPI,\r\n\tJsonRpcBatchRequest,\r\n\tJsonRpcBatchResponse,\r\n\tJsonRpcId,\r\n\tJsonRpcNotification,\r\n\tJsonRpcRequest,\r\n\tJsonRpcResponse,\r\n\tJsonRpcResponseWithResult,\r\n\tJsonRpcResult,\r\n\tProviderConnectInfo,\r\n\tProviderMessage,\r\n\tProviderRpcError,\r\n\tSocketRequestItem,\r\n\tWeb3APIMethod,\r\n\tWeb3APIPayload,\r\n\tWeb3APIReturnType,\r\n\tWeb3APISpec,\r\n\tWeb3Eip1193ProviderEventCallback,\r\n\tWeb3ProviderEventCallback,\r\n\tWeb3ProviderMessageEventCallback,\r\n\tWeb3ProviderStatus,\r\n} from 'web3-types';\r\nimport {\r\n\tConnectionError,\r\n\tConnectionNotOpenError,\r\n\tInvalidClientError,\r\n\tMaxAttemptsReachedOnReconnectingError,\r\n\tPendingRequestsOnReconnectingError,\r\n\tRequestAlreadySentError,\r\n\tWeb3WSProviderError,\r\n} from 'web3-errors';\r\nimport { Eip1193Provider } from './web3_eip1193_provider.js';\r\nimport { ChunkResponseParser } from './chunk_response_parser.js';\r\nimport { isNullish } from './validation.js';\r\nimport { Web3DeferredPromise } from './web3_deferred_promise.js';\r\nimport * as jsonRpc from './json_rpc.js';\r\n\r\nexport type ReconnectOptions = {\r\n\tautoReconnect: boolean;\r\n\tdelay: number;\r\n\tmaxAttempts: number;\r\n};\r\n\r\nconst DEFAULT_RECONNECTION_OPTIONS = {\r\n\tautoReconnect: true,\r\n\tdelay: 5000,\r\n\tmaxAttempts: 5,\r\n};\r\n\r\nconst NORMAL_CLOSE_CODE = 1000; // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\r\n\r\nexport abstract class SocketProvider<\r\n\tMessageEvent,\r\n\tCloseEvent,\r\n\tErrorEvent,\r\n\tAPI extends Web3APISpec = EthExecutionAPI,\r\n> extends Eip1193Provider<API> {\r\n\tprotected isReconnecting: boolean;\r\n\tprotected readonly _socketPath: string;\r\n\tprotected readonly chunkResponseParser: ChunkResponseParser;\r\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\tprotected readonly _pendingRequestsQueue: Map<JsonRpcId, SocketRequestItem<any, any, any>>;\r\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\tprotected readonly _sentRequestsQueue: Map<JsonRpcId, SocketRequestItem<any, any, any>>;\r\n\tprotected _reconnectAttempts!: number;\r\n\tprotected readonly _socketOptions?: unknown;\r\n\tprotected readonly _reconnectOptions: ReconnectOptions;\r\n\tprotected _socketConnection?: unknown;\r\n\tpublic get SocketConnection() {\r\n\t\treturn this._socketConnection;\r\n\t}\r\n\tprotected _connectionStatus: Web3ProviderStatus;\r\n\tprotected readonly _onMessageHandler: (event: MessageEvent) => void;\r\n\tprotected readonly _onOpenHandler: () => void;\r\n\tprotected readonly _onCloseHandler: (event: CloseEvent) => void;\r\n\tprotected readonly _onErrorHandler: (event: ErrorEvent) => void;\r\n\r\n\t/**\r\n\t * This is an abstract class for implementing a socket provider (e.g. WebSocket, IPC). It extends the EIP-1193 provider {@link EIP1193Provider}.\r\n\t * @param socketPath - The path to the socket (e.g. /ipc/path or ws://localhost:8546)\r\n\t * @param socketOptions - The options for the socket connection. Its type is supposed to be specified in the inherited classes.\r\n\t * @param reconnectOptions - The options for the socket reconnection {@link ReconnectOptions}\r\n\t */\r\n\tpublic constructor(\r\n\t\tsocketPath: string,\r\n\t\tsocketOptions?: unknown,\r\n\t\treconnectOptions?: Partial<ReconnectOptions>,\r\n\t) {\r\n\t\tsuper();\r\n\t\tthis._connectionStatus = 'connecting';\r\n\r\n\t\t// Message handlers. Due to bounding of `this` and removing the listeners we have to keep it's reference.\r\n\t\tthis._onMessageHandler = this._onMessage.bind(this);\r\n\t\tthis._onOpenHandler = this._onConnect.bind(this);\r\n\t\tthis._onCloseHandler = this._onCloseEvent.bind(this);\r\n\t\tthis._onErrorHandler = this._onError.bind(this);\r\n\r\n\t\tif (!this._validateProviderPath(socketPath)) throw new InvalidClientError(socketPath);\r\n\r\n\t\tthis._socketPath = socketPath;\r\n\t\tthis._socketOptions = socketOptions;\r\n\r\n\t\tthis._reconnectOptions = {\r\n\t\t\t...DEFAULT_RECONNECTION_OPTIONS,\r\n\t\t\t...(reconnectOptions ?? {}),\r\n\t\t};\r\n\r\n\t\tthis._pendingRequestsQueue = new Map<JsonRpcId, SocketRequestItem<any, any, any>>();\r\n\t\tthis._sentRequestsQueue = new Map<JsonRpcId, SocketRequestItem<any, any, any>>();\r\n\r\n\t\tthis._init();\r\n\t\tthis.connect();\r\n\t\tthis.chunkResponseParser = new ChunkResponseParser(\r\n\t\t\tthis._eventEmitter,\r\n\t\t\tthis._reconnectOptions.autoReconnect,\r\n\t\t);\r\n\t\tthis.chunkResponseParser.onError(() => {\r\n\t\t\tthis._clearQueues();\r\n\t\t});\r\n\t\tthis.isReconnecting = false;\r\n\t}\r\n\r\n\tprotected _init() {\r\n\t\tthis._reconnectAttempts = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Try to establish a connection to the socket\r\n\t */\r\n\tpublic connect(): void {\r\n\t\ttry {\r\n\t\t\tthis._openSocketConnection();\r\n\t\t\tthis._connectionStatus = 'connecting';\r\n\t\t\tthis._addSocketListeners();\r\n\t\t} catch (e) {\r\n\t\t\tif (!this.isReconnecting) {\r\n\t\t\t\tthis._connectionStatus = 'disconnected';\r\n\t\t\t\tif (e && (e as Error).message) {\r\n\t\t\t\t\tthrow new ConnectionError(\r\n\t\t\t\t\t\t`Error while connecting to ${this._socketPath}. Reason: ${\r\n\t\t\t\t\t\t\t(e as Error).message\r\n\t\t\t\t\t\t}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new InvalidClientError(this._socketPath);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tsetImmediate(() => {\r\n\t\t\t\t\tthis._reconnect();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected abstract _openSocketConnection(): void;\r\n\tprotected abstract _addSocketListeners(): void;\r\n\r\n\tprotected abstract _removeSocketListeners(): void;\r\n\r\n\tprotected abstract _onCloseEvent(_event: unknown): void;\r\n\r\n\tprotected abstract _sendToSocket(_payload: Web3APIPayload<API, any>): void;\r\n\r\n\tprotected abstract _parseResponses(_event: MessageEvent): JsonRpcResponse[];\r\n\r\n\tprotected abstract _closeSocketConnection(_code?: number, _data?: string): void;\r\n\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tprotected _validateProviderPath(path: string): boolean {\r\n\t\treturn !!path;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @returns `true` if the socket supports subscriptions\r\n\t */\r\n\t// eslint-disable-next-line class-methods-use-this\r\n\tpublic supportsSubscriptions(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Registers a listener for the specified event type.\r\n\t * @param type - The event type to listen for\r\n\t * @param listener - The callback to be invoked when the event is emitted\r\n\t */\r\n\tpublic on(\r\n\t\ttype: 'disconnect',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderRpcError>,\r\n\t): void;\r\n\tpublic on(\r\n\t\ttype: 'connect',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderConnectInfo>,\r\n\t): void;\r\n\tpublic on(type: 'chainChanged', listener: Web3Eip1193ProviderEventCallback<string>): void;\r\n\tpublic on(type: 'accountsChanged', listener: Web3Eip1193ProviderEventCallback<string[]>): void;\r\n\tpublic on<T = JsonRpcResult>(\r\n\t\ttype: 'message',\r\n\t\tlistener:\r\n\t\t\t| Web3Eip1193ProviderEventCallback<ProviderMessage>\r\n\t\t\t| Web3ProviderMessageEventCallback<T>,\r\n\t): void;\r\n\tpublic on<T = JsonRpcResult>(\r\n\t\ttype: string,\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<unknown> | Web3ProviderEventCallback<T>,\r\n\t): void;\r\n\tpublic on<T = JsonRpcResult, P = unknown>(\r\n\t\ttype: string | Eip1193EventName,\r\n\t\tlistener:\r\n\t\t\t| Web3Eip1193ProviderEventCallback<P>\r\n\t\t\t| Web3ProviderMessageEventCallback<T>\r\n\t\t\t| Web3ProviderEventCallback<T>,\r\n\t): void {\r\n\t\tthis._eventEmitter.on(type, listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Registers a listener for the specified event type that will be invoked at most once.\r\n\t * @param type  - The event type to listen for\r\n\t * @param listener - The callback to be invoked when the event is emitted\r\n\t */\r\n\tpublic once(\r\n\t\ttype: 'disconnect',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderRpcError>,\r\n\t): void;\r\n\tpublic once(\r\n\t\ttype: 'connect',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderConnectInfo>,\r\n\t): void;\r\n\tpublic once(type: 'chainChanged', listener: Web3Eip1193ProviderEventCallback<string>): void;\r\n\tpublic once(\r\n\t\ttype: 'accountsChanged',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<string[]>,\r\n\t): void;\r\n\tpublic once<T = JsonRpcResult>(\r\n\t\ttype: 'message',\r\n\t\tlistener:\r\n\t\t\t| Web3Eip1193ProviderEventCallback<ProviderMessage>\r\n\t\t\t| Web3ProviderMessageEventCallback<T>,\r\n\t): void;\r\n\tpublic once<T = JsonRpcResult>(\r\n\t\ttype: string,\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<unknown> | Web3ProviderEventCallback<T>,\r\n\t): void;\r\n\tpublic once<T = JsonRpcResult, P = unknown>(\r\n\t\ttype: string | Eip1193EventName,\r\n\t\tlistener:\r\n\t\t\t| Web3Eip1193ProviderEventCallback<P>\r\n\t\t\t| Web3ProviderMessageEventCallback<T>\r\n\t\t\t| Web3ProviderEventCallback<T>,\r\n\t): void {\r\n\t\tthis._eventEmitter.once(type, listener);\r\n\t}\r\n\r\n\t/**\r\n\t *  Removes a listener for the specified event type.\r\n\t * @param type - The event type to remove the listener for\r\n\t * @param listener - The callback to be executed\r\n\t */\r\n\tpublic removeListener(\r\n\t\ttype: 'disconnect',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderRpcError>,\r\n\t): void;\r\n\tpublic removeListener(\r\n\t\ttype: 'connect',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderConnectInfo>,\r\n\t): void;\r\n\tpublic removeListener(\r\n\t\ttype: 'chainChanged',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<string>,\r\n\t): void;\r\n\tpublic removeListener(\r\n\t\ttype: 'accountsChanged',\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<string[]>,\r\n\t): void;\r\n\tpublic removeListener<T = JsonRpcResult>(\r\n\t\ttype: 'message',\r\n\t\tlistener:\r\n\t\t\t| Web3Eip1193ProviderEventCallback<ProviderMessage>\r\n\t\t\t| Web3ProviderMessageEventCallback<T>,\r\n\t): void;\r\n\tpublic removeListener<T = JsonRpcResult>(\r\n\t\ttype: string,\r\n\t\tlistener: Web3Eip1193ProviderEventCallback<unknown> | Web3ProviderEventCallback<T>,\r\n\t): void;\r\n\tpublic removeListener<T = JsonRpcResult, P = unknown>(\r\n\t\ttype: string | Eip1193EventName,\r\n\t\tlistener:\r\n\t\t\t| Web3Eip1193ProviderEventCallback<P>\r\n\t\t\t| Web3ProviderMessageEventCallback<T>\r\n\t\t\t| Web3ProviderEventCallback<T>,\r\n\t): void {\r\n\t\tthis._eventEmitter.removeListener(type, listener);\r\n\t}\r\n\r\n\tprotected _onDisconnect(code?: number, data?: string) {\r\n\t\tthis._connectionStatus = 'disconnected';\r\n\t\tsuper._onDisconnect(code, data);\r\n\t}\r\n\r\n\t/**\r\n\t * Disconnects the socket\r\n\t * @param code - The code to be sent to the server\r\n\t * @param data - The data to be sent to the server\r\n\t */\r\n\tpublic disconnect(code?: number, data?: string): void {\r\n\t\tconst disconnectCode = code ?? NORMAL_CLOSE_CODE;\r\n\t\tthis._removeSocketListeners();\r\n\t\tif (this.getStatus() !== 'disconnected') {\r\n\t\t\tthis._closeSocketConnection(disconnectCode, data);\r\n\t\t}\r\n\t\tthis._onDisconnect(disconnectCode, data);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all listeners for the specified event type.\r\n\t * @param type - The event type to remove the listeners for\r\n\t */\r\n\tpublic removeAllListeners(type: string): void {\r\n\t\tthis._eventEmitter.removeAllListeners(type);\r\n\t}\r\n\r\n\tprotected _onError(event: ErrorEvent): void {\r\n\t\t// do not emit error while trying to reconnect\r\n\t\tif (this.isReconnecting) {\r\n\t\t\tthis._reconnect();\r\n\t\t} else {\r\n\t\t\tthis._eventEmitter.emit('error', event);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the socket, removing all listeners and pending requests\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis._sentRequestsQueue.clear();\r\n\t\tthis._pendingRequestsQueue.clear();\r\n\r\n\t\tthis._init();\r\n\t\tthis._removeSocketListeners();\r\n\t\tthis._addSocketListeners();\r\n\t}\r\n\r\n\tprotected _reconnect(): void {\r\n\t\tif (this.isReconnecting) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.isReconnecting = true;\r\n\r\n\t\tif (this._sentRequestsQueue.size > 0) {\r\n\t\t\tthis._sentRequestsQueue.forEach(\r\n\t\t\t\t(request: SocketRequestItem<any, any, any>, key: JsonRpcId) => {\r\n\t\t\t\t\trequest.deferredPromise.reject(new PendingRequestsOnReconnectingError());\r\n\t\t\t\t\tthis._sentRequestsQueue.delete(key);\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {\r\n\t\t\tthis._reconnectAttempts += 1;\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tthis._removeSocketListeners();\r\n\t\t\t\tthis.connect();\r\n\t\t\t\tthis.isReconnecting = false;\r\n\t\t\t}, this._reconnectOptions.delay);\r\n\t\t} else {\r\n\t\t\tthis.isReconnecting = false;\r\n\t\t\tthis._clearQueues();\r\n\t\t\tthis._removeSocketListeners();\r\n\t\t\tthis._eventEmitter.emit(\r\n\t\t\t\t'error',\r\n\t\t\t\tnew MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts),\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *  Creates a request object to be sent to the server\r\n\t */\r\n\tpublic async request<\r\n\t\tMethod extends Web3APIMethod<API>,\r\n\t\tResultType = Web3APIReturnType<API, Method>,\r\n\t>(request: Web3APIPayload<API, Method>): Promise<JsonRpcResponseWithResult<ResultType>> {\r\n\t\tif (isNullish(this._socketConnection)) {\r\n\t\t\tthrow new Error('Connection is undefined');\r\n\t\t}\r\n\t\t// if socket disconnected - open connection\r\n\t\tif (this.getStatus() === 'disconnected') {\r\n\t\t\tthis.connect();\r\n\t\t}\r\n\r\n\t\tconst requestId = jsonRpc.isBatchRequest(request)\r\n\t\t\t? (request as unknown as JsonRpcBatchRequest)[0].id\r\n\t\t\t: (request as unknown as JsonRpcRequest).id;\r\n\r\n\t\tif (!requestId) {\r\n\t\t\tthrow new Web3WSProviderError('Request Id not defined');\r\n\t\t}\r\n\r\n\t\tif (this._sentRequestsQueue.has(requestId)) {\r\n\t\t\tthrow new RequestAlreadySentError(requestId);\r\n\t\t}\r\n\r\n\t\tconst deferredPromise = new Web3DeferredPromise<JsonRpcResponseWithResult<ResultType>>();\r\n\t\tdeferredPromise.catch(error => {\r\n\t\t\tthis._eventEmitter.emit('error', error);\r\n\t\t});\r\n\t\tconst reqItem: SocketRequestItem<API, Method, JsonRpcResponseWithResult<ResultType>> = {\r\n\t\t\tpayload: request,\r\n\t\t\tdeferredPromise,\r\n\t\t};\r\n\r\n\t\tif (this.getStatus() === 'connecting') {\r\n\t\t\tthis._pendingRequestsQueue.set(requestId, reqItem);\r\n\r\n\t\t\treturn reqItem.deferredPromise;\r\n\t\t}\r\n\r\n\t\tthis._sentRequestsQueue.set(requestId, reqItem);\r\n\r\n\t\ttry {\r\n\t\t\tthis._sendToSocket(reqItem.payload);\r\n\t\t} catch (error) {\r\n\t\t\tthis._sentRequestsQueue.delete(requestId);\r\n\r\n\t\t\tthis._eventEmitter.emit('error', error);\r\n\t\t}\r\n\r\n\t\treturn deferredPromise;\r\n\t}\r\n\r\n\tprotected _onConnect() {\r\n\t\tthis._connectionStatus = 'connected';\r\n\t\tthis._reconnectAttempts = 0;\r\n\t\tsuper._onConnect();\r\n\t\tthis._sendPendingRequests();\r\n\t}\r\n\r\n\tprivate _sendPendingRequests() {\r\n\t\tfor (const [id, value] of this._pendingRequestsQueue.entries()) {\r\n\t\t\tthis._sendToSocket(value.payload as Web3APIPayload<API, any>);\r\n\t\t\tthis._pendingRequestsQueue.delete(id);\r\n\t\t\tthis._sentRequestsQueue.set(id, value);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected _onMessage(event: MessageEvent): void {\r\n\t\tconst responses = this._parseResponses(event);\r\n\t\tif (responses.length === 0) {\r\n\t\t\t// no responses means lost connection, autoreconnect if possible\r\n\t\t\tif (this._reconnectOptions.autoReconnect) {\r\n\t\t\t\tthis._reconnect();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfor (const response of responses) {\r\n\t\t\tif (\r\n\t\t\t\tjsonRpc.isResponseWithNotification(response as JsonRpcNotification) &&\r\n\t\t\t\t(response as JsonRpcNotification).method.endsWith('_subscription')\r\n\t\t\t) {\r\n\t\t\t\tthis._eventEmitter.emit('message', response);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst requestId = jsonRpc.isBatchResponse(response)\r\n\t\t\t\t? (response as unknown as JsonRpcBatchResponse)[0].id\r\n\t\t\t\t: (response as unknown as JsonRpcResponseWithResult).id;\r\n\r\n\t\t\tconst requestItem = this._sentRequestsQueue.get(requestId);\r\n\r\n\t\t\tif (!requestItem) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (\r\n\t\t\t\tjsonRpc.isBatchResponse(response) ||\r\n\t\t\t\tjsonRpc.isResponseWithResult(response) ||\r\n\t\t\t\tjsonRpc.isResponseWithError(response)\r\n\t\t\t) {\r\n\t\t\t\tthis._eventEmitter.emit('message', response);\r\n\t\t\t\trequestItem.deferredPromise.resolve(response);\r\n\t\t\t}\r\n\r\n\t\t\tthis._sentRequestsQueue.delete(requestId);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected _clearQueues(event?: ConnectionEvent) {\r\n\t\tif (this._pendingRequestsQueue.size > 0) {\r\n\t\t\tthis._pendingRequestsQueue.forEach(\r\n\t\t\t\t(request: SocketRequestItem<any, any, any>, key: JsonRpcId) => {\r\n\t\t\t\t\trequest.deferredPromise.reject(new ConnectionNotOpenError(event));\r\n\t\t\t\t\tthis._pendingRequestsQueue.delete(key);\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (this._sentRequestsQueue.size > 0) {\r\n\t\t\tthis._sentRequestsQueue.forEach(\r\n\t\t\t\t(request: SocketRequestItem<any, any, any>, key: JsonRpcId) => {\r\n\t\t\t\t\trequest.deferredPromise.reject(new ConnectionNotOpenError(event));\r\n\t\t\t\t\tthis._sentRequestsQueue.delete(key);\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis._removeSocketListeners();\r\n\t}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
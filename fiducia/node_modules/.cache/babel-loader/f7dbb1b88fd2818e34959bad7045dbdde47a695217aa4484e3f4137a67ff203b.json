{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nexport {};","map":{"version":3,"names":[],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-eth-contract\\src\\types.ts"],"sourcesContent":["/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { Web3ContextInitOptions, Web3PromiEvent } from 'web3-core';\r\nimport { NewHeadsSubscription, SendTransactionEvents } from 'web3-eth';\r\nimport {\r\n\tAccessListResult,\r\n\tBlockNumberOrTag,\r\n\tEthExecutionAPI,\r\n\tHexString,\r\n\tNumbers,\r\n\tTransactionReceipt,\r\n\tNonPayableCallOptions,\r\n\tPayableCallOptions,\r\n\tDataFormat,\r\n\tDEFAULT_RETURN_FORMAT,\r\n\tFormatType,\r\n\tAbiFragment,\r\n\tAddress,\r\n\tBytes,\r\n\tContractAbi,\r\n\tHexString32Bytes,\r\n\tUint,\r\n} from 'web3-types';\r\n// eslint-disable-next-line import/no-cycle\r\nimport { LogsSubscription } from './log_subscription.js';\r\n\r\nexport type NonPayableTxOptions = NonPayableCallOptions;\r\nexport type PayableTxOptions = PayableCallOptions;\r\n\r\nexport type ContractAbiWithSignature = ReadonlyArray<AbiFragment & { signature: HexString }>;\r\n\r\nexport interface EventLog {\r\n\treadonly event: string;\r\n\treadonly id?: string;\r\n\treadonly logIndex?: bigint | number | string;\r\n\treadonly transactionIndex?: bigint | number | string;\r\n\treadonly transactionHash?: HexString32Bytes;\r\n\treadonly blockHash?: HexString32Bytes;\r\n\treadonly blockNumber?: bigint | number | string;\r\n\treadonly address: string;\r\n\treadonly topics: HexString[];\r\n\treadonly data: HexString;\r\n\treadonly raw?: { data: string; topics: unknown[] };\r\n\treadonly returnValues: Record<string, unknown>;\r\n\treadonly signature?: HexString;\r\n}\r\n\r\nexport interface ContractEventOptions {\r\n\t/**\r\n\t * Let you filter events by indexed parameters, e.g. `{filter: {myNumber: [12,13]}}` means all events where `myNumber` is `12` or `13`.\r\n\t */\r\n\tfilter?: Record<string, unknown>;\r\n\t/**\r\n\t * The block number (greater than or equal to) from which to get events on. Pre-defined block numbers as `earliest`, `latest`, `pending`, `safe` or `finalized` can also be used. For specific range use {@link Contract.getPastEvents}.\r\n\t */\r\n\tfromBlock?: BlockNumberOrTag;\r\n\t/**\r\n\t * This allows to manually set the topics for the event filter. If given the filter property and event signature, (topic[0]) will not be set automatically. Each topic can also be a nested array of topics that behaves as `or` operation between the given nested topics.\r\n\t */\r\n\ttopics?: string[];\r\n}\r\n\r\nexport interface ContractOptions {\r\n\t/**\r\n\t * The maximum gas provided for a transaction (gas limit).\r\n\t */\r\n\treadonly gas?: Uint;\r\n\t/**\r\n\t * The gas price in wei to use for transactions.\r\n\t */\r\n\treadonly gasPrice?: Uint;\r\n\t/**\r\n\t * The address transactions should be made from.\r\n\t */\r\n\treadonly from?: Address;\r\n\t/**\r\n\t * The byte code of the contract. Used when the contract gets {@link Contract.deploy | deployed}\r\n\t */\r\n\treadonly input?: Bytes;\r\n\t/**\r\n\t * The {@doclink glossary/json_interface | json interface} object derived from the [ABI](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI) of this contract.\r\n\t *\r\n\t * Re-setting this will regenerate the methods and events of the contract instance.\r\n\t *\r\n\t * ```ts\r\n\t * myContract.options.jsonInterface;\r\n\t * > [{\r\n\t *     \"type\":\"function\",\r\n\t *     \"name\":\"foo\",\r\n\t *     \"inputs\": [{\"name\":\"a\",\"type\":\"uint256\"}],\r\n\t *     \"outputs\": [{\"name\":\"b\",\"type\":\"address\"}],\r\n\t * \t   \"signature\": \"0x...\",\r\n\t * },{\r\n\t *     \"type\":\"event\",\r\n\t *     \"name\":\"Event\",\r\n\t *     \"inputs\": [{\"name\":\"a\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"b\",\"type\":\"bytes32\",\"indexed\":false}],\r\n\t * \t   \"signature\": \"0x...\",\r\n\t * }]\r\n\t *\r\n\t * // Set a new ABI interface\r\n\t * // Note: the \"signature\" of every function and event's ABI is not needed to be provided when assigning.\r\n\t * //\tIt will be calculated and set automatically inside the setter.\r\n\t * myContract.options.jsonInterface = [...];\r\n\t * ```\r\n\t */\r\n\tget jsonInterface(): ContractAbiWithSignature;\r\n\tset jsonInterface(value: ContractAbi);\r\n\r\n\t/**\r\n\t * The address used for this contract instance. All transactions generated by web3.js from this contract will contain this address as the `to`.\r\n\t *\r\n\t * The address will be stored in lowercase.\r\n\t *\r\n\t * ```ts\r\n\t * myContract.options.address;\r\n\t * > '0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae'\r\n\t *\r\n\t * // set a new address\r\n\t * myContract.options.address = '0x1234FFDD...';\r\n\t * ```\r\n\t */\r\n\taddress?: Address; // All transactions generated by web3.js from this contract will contain this address as the \"to\".\r\n\t/**\r\n\t * The max priority fee per gas to use for transactions.\r\n\t */\r\n\tmaxPriorityFeePerGas?: Uint;\r\n\t/**\r\n\t * The max fee per gas to use for transactions.\r\n\t */\r\n\tmaxFeePerGas?: Uint;\r\n}\r\n\r\nexport interface NonPayableMethodObject<Inputs = unknown[], Outputs = unknown[]> {\r\n\targuments: Inputs;\r\n\t/**\r\n\t * This will call a method and execute its smart contract method in the EVM without sending any transaction. Note calling cannot alter the smart contract state.\r\n\t *\r\n\t * ```ts\r\n\t * // using the promise\r\n\t * const result = await myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t * // MULTI-ARGUMENT RETURN:\r\n\t * // Solidity\r\n\t * contract MyContract {\r\n\t *   function myFunction() returns(uint256 myNumber, string myString) {\r\n\t *       return (23456, \"Hello!%\");\r\n\t *   }\r\n\t * }\r\n\t *\r\n\t * // web3.js\r\n\t * var MyContract = new web3.eth.Contract(abi, address);\r\n\t * const result = MyContract.methods.myFunction().call()\r\n\t * console.log(result)\r\n\t * > Result {\r\n\t *   myNumber: '23456',\r\n\t *   myString: 'Hello!%',\r\n\t *   0: '23456', // these are here as fallbacks if the name is not know or given\r\n\t *   1: 'Hello!%'\r\n\t * }\r\n\t *\r\n\t *\r\n\t * // SINGLE-ARGUMENT RETURN:\r\n\t * // Solidity\r\n\t * contract MyContract {\r\n\t *   function myFunction() returns(string myString) {\r\n\t *       return \"Hello!%\";\r\n\t *   }\r\n\t * }\r\n\t *\r\n\t * // web3.js\r\n\t * const MyContract = new web3.eth.Contract(abi, address);\r\n\t * const result = await MyContract.methods.myFunction().call();\r\n\t * console.log(result);\r\n\t * > \"Hello!%\"\r\n\t * ```\r\n\t *\r\n\t * @param tx - The options used for calling.\r\n\t * @param block - If you pass this parameter it will not use the default block set with contract.defaultBlock. Pre-defined block numbers as `earliest`, `latest`, `pending`, `safe` or `finalized can also be used. Useful for requesting data from or replaying transactions in past blocks.\r\n\t * @returns - The return value(s) of the smart contract method. If it returns a single value, it’s returned as is. If it has multiple return values they are returned as an object with properties and indices.\r\n\t */\r\n\r\n\tcall<SpecialOutput = Outputs>(\r\n\t\ttx?: NonPayableCallOptions,\r\n\t\tblock?: BlockNumberOrTag,\r\n\t): Promise<SpecialOutput>;\r\n\r\n\t/**\r\n\t * This will send a transaction to the smart contract and execute its method. Note this can alter the smart contract state.\r\n\t *\r\n\t * ```ts\r\n\t * await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t * const receipt = await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t *\r\n\t * // using the event emitter\r\n\t * const sendObj = myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})\r\n\t * sendObj.on('transactionHash', function(hash){\r\n\t *   ...\r\n\t * });\r\n\t *\r\n\t * sendObj.on('confirmation', function(confirmationNumber, receipt){\r\n\t *   ...\r\n\t * });\r\n\t *\r\n\t * sendObj.on('receipt', function(receipt){\r\n\t *   // receipt example\r\n\t *   console.log(receipt);\r\n\t *   > {\r\n\t *       \"transactionHash\": \"0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\",\r\n\t *       \"transactionIndex\": 0,\r\n\t *       \"blockHash\": \"0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46\",\r\n\t *       \"blockNumber\": 3,\r\n\t *       \"contractAddress\": \"0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe\",\r\n\t *       \"cumulativeGasUsed\": 314159,\r\n\t *       \"gasUsed\": 30234,\r\n\t *       \"events\": {\r\n\t *           \"MyEvent\": {\r\n\t *               returnValues: {\r\n\t *                   myIndexedParam: 20,\r\n\t *                   myOtherIndexedParam: '0x123456789...',\r\n\t *                   myNonIndexParam: 'My String'\r\n\t *               },\r\n\t *               raw: {\r\n\t *                   data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\r\n\t *                   topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\r\n\t *               },\r\n\t *               event: 'MyEvent',\r\n\t *               signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\r\n\t *               logIndex: 0,\r\n\t *               transactionIndex: 0,\r\n\t *               transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\r\n\t *               blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\r\n\t *               blockNumber: 1234,\r\n\t *               address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\r\n\t *           },\r\n\t *           \"MyOtherEvent\": {\r\n\t *               ...\r\n\t *           },\r\n\t *           \"MyMultipleEvent\":[{...}, {...}] // If there are multiple of the same event, they will be in an array\r\n\t *       }\r\n\t *   }\r\n\t * });\r\n\t *\r\n\t * sendObj.on('error', function(error, receipt) { // If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.\r\n\t *   ...\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @param tx - The options used for sending.\r\n\t * @returns - Returns a {@link PromiEvent} resolved with transaction receipt.\r\n\t */\r\n\tsend(\r\n\t\ttx?: NonPayableTxOptions,\r\n\t): Web3PromiEvent<\r\n\t\tFormatType<TransactionReceipt, typeof DEFAULT_RETURN_FORMAT>,\r\n\t\tSendTransactionEvents<typeof DEFAULT_RETURN_FORMAT>\r\n\t>;\r\n\r\n\t/**\r\n\t * Returns the amount of gas consumed by executing the method locally without creating a new transaction on the blockchain.\r\n\t * The returned amount can be used as a gas estimate for executing the transaction publicly. The actual gas used can be\r\n\t * different when sending the transaction later, as the state of the smart contract can be different at that time.\r\n\t *\r\n\t * ```ts\r\n\t * const gasAmount = await myContract.methods.myMethod(123).estimateGas({gas: 5000000});\r\n\t * if(gasAmount == 5000000) {\r\n\t *   console.log('Method ran out of gas');\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param options  - The options used for calling\r\n\t * @param returnFormat - The data format you want the output in.\r\n\t * @returns - The gas amount estimated.\r\n\t */\r\n\testimateGas<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\toptions?: NonPayableCallOptions,\r\n\t\treturnFormat?: ReturnFormat,\r\n\t): Promise<FormatType<Numbers, ReturnFormat>>;\r\n\r\n\t/**\r\n\t * Encodes the ABI for this method. The resulting hex string is 32-bit function signature hash plus the passed parameters in Solidity tightly packed format.\r\n\t * This can be used to send a transaction, call a method, or pass it into another smart contract’s method as arguments.\r\n\t * Set the data field on `web3.eth.sendTransaction` options as the encodeABI() result and it is the same as calling the contract method with `contract.myMethod.send()`.\r\n\t *\r\n\t * Some use cases for encodeABI() include: preparing a smart contract transaction for a multi signature wallet,\r\n\t * working with offline wallets and cold storage and creating transaction payload for complex smart contract proxy calls.\r\n\t *\r\n\t * @returns - The encoded ABI byte code to send via a transaction or call.\r\n\t */\r\n\tencodeABI(): string;\r\n\r\n\t/**\r\n\t * This method generates an access list for a transaction. You must specify a `from` address and `gas` if it’s not specified in options.\r\n\t *\r\n\t * @param options - The options used for createAccessList.\r\n\t * @param block - If you pass this parameter it will not use the default block set with contract.defaultBlock. Pre-defined block numbers as `earliest`, `latest`, `pending`, `safe` or `finalized can also be used. Useful for requesting data from or replaying transactions in past blocks.\r\n\t * @returns The returned data of the createAccessList,  e.g. The generated access list for transaction.\r\n\t *\r\n\t * ```ts\r\n\t *  const result = await MyContract.methods.myFunction().createAccessList();\r\n\t *  console.log(result);\r\n\t *\r\n\t * > {\r\n\t *  \"accessList\": [\r\n\t *     {\r\n\t *       \"address\": \"0x15859bdf5aff2080a9968f6a410361e9598df62f\",\r\n\t *       \"storageKeys\": [\r\n\t *         \"0x0000000000000000000000000000000000000000000000000000000000000000\"\r\n\t *       ]\r\n\t *     }\r\n\t *   ],\r\n\t *   \"gasUsed\": \"0x7671\"\r\n\t * }\r\n\t * ```\r\n\t */\r\n\tcreateAccessList(\r\n\t\ttx?: NonPayableCallOptions,\r\n\t\tblock?: BlockNumberOrTag,\r\n\t): Promise<AccessListResult>;\r\n}\r\n\r\nexport interface PayableMethodObject<Inputs = unknown[], Outputs = unknown[]> {\r\n\targuments: Inputs;\r\n\t/**\r\n\t * Will call a method and execute its smart contract method in the EVM without sending any transaction. Note calling cannot alter the smart contract state.\r\n\t *\r\n\t * ```ts\r\n\t * // using the promise\r\n\t * const result = await myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t * // MULTI-ARGUMENT RETURN:\r\n\t * // Solidity\r\n\t * contract MyContract {\r\n\t *   function myFunction() returns(uint256 myNumber, string myString) {\r\n\t *       return (23456, \"Hello!%\");\r\n\t *   }\r\n\t * }\r\n\t *\r\n\t * // web3.js\r\n\t * var MyContract = new web3.eth.Contract(abi, address);\r\n\t * const result = MyContract.methods.myFunction().call()\r\n\t * console.log(result)\r\n\t * > Result {\r\n\t *   myNumber: '23456',\r\n\t *   myString: 'Hello!%',\r\n\t *   0: '23456', // these are here as fallbacks if the name is not know or given\r\n\t *   1: 'Hello!%'\r\n\t * }\r\n\t *\r\n\t *\r\n\t * // SINGLE-ARGUMENT RETURN:\r\n\t * // Solidity\r\n\t * contract MyContract {\r\n\t *   function myFunction() returns(string myString) {\r\n\t *       return \"Hello!%\";\r\n\t *   }\r\n\t * }\r\n\t *\r\n\t * // web3.js\r\n\t * const MyContract = new web3.eth.Contract(abi, address);\r\n\t * const result = await MyContract.methods.myFunction().call();\r\n\t * console.log(result);\r\n\t * > \"Hello!%\"\r\n\t * ```\r\n\t *\r\n\t * @param tx - The options used for calling.\r\n\t * @param block - If you pass this parameter it will not use the default block set with contract.defaultBlock. Pre-defined block numbers as `earliest`, `latest`, `pending`, `safe` or `finalized can also be used. Useful for requesting data from or replaying transactions in past blocks.\r\n\t * @returns - The return value(s) of the smart contract method. If it returns a single value, it’s returned as is. If it has multiple return values they are returned as an object with properties and indices.\r\n\t */\r\n\tcall<SpecialOutput = Outputs>(\r\n\t\ttx?: PayableCallOptions,\r\n\t\tblock?: BlockNumberOrTag,\r\n\t): Promise<SpecialOutput>;\r\n\r\n\t/**\r\n\t * Will send a transaction to the smart contract and execute its method. Note this can alter the smart contract state.\r\n\t *\r\n\t * ```ts\r\n\t * await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t * const receipt = await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\r\n\t *\r\n\t *\r\n\t * // using the event emitter\r\n\t * const sendObj = myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})\r\n\t * sendObj.on('transactionHash', function(hash){\r\n\t *   ...\r\n\t * });\r\n\t *\r\n\t * sendObj.on('confirmation', function(confirmationNumber, receipt){\r\n\t *   ...\r\n\t * });\r\n\t *\r\n\t * sendObj.on('receipt', function(receipt){\r\n\t *   // receipt example\r\n\t *   console.log(receipt);\r\n\t *   > {\r\n\t *       \"transactionHash\": \"0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\",\r\n\t *       \"transactionIndex\": 0,\r\n\t *       \"blockHash\": \"0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46\",\r\n\t *       \"blockNumber\": 3,\r\n\t *       \"contractAddress\": \"0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe\",\r\n\t *       \"cumulativeGasUsed\": 314159,\r\n\t *       \"gasUsed\": 30234,\r\n\t *       \"events\": {\r\n\t *           \"MyEvent\": {\r\n\t *               returnValues: {\r\n\t *                   myIndexedParam: 20,\r\n\t *                   myOtherIndexedParam: '0x123456789...',\r\n\t *                   myNonIndexParam: 'My String'\r\n\t *               },\r\n\t *               raw: {\r\n\t *                   data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\r\n\t *                   topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\r\n\t *               },\r\n\t *               event: 'MyEvent',\r\n\t *               signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\r\n\t *               logIndex: 0,\r\n\t *               transactionIndex: 0,\r\n\t *               transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\r\n\t *               blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\r\n\t *               blockNumber: 1234,\r\n\t *               address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\r\n\t *           },\r\n\t *           \"MyOtherEvent\": {\r\n\t *               ...\r\n\t *           },\r\n\t *           \"MyMultipleEvent\":[{...}, {...}] // If there are multiple of the same event, they will be in an array\r\n\t *       }\r\n\t *   }\r\n\t * });\r\n\t *\r\n\t * sendObj.on('error', function(error, receipt) { // If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.\r\n\t *   ...\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @param tx - The options used for sending.\r\n\t * @returns - Returns a {@link PromiEvent} object resolved with transaction receipt.\r\n\t */\r\n\tsend(\r\n\t\ttx?: PayableTxOptions,\r\n\t): Web3PromiEvent<\r\n\t\tFormatType<TransactionReceipt, typeof DEFAULT_RETURN_FORMAT>,\r\n\t\tSendTransactionEvents<typeof DEFAULT_RETURN_FORMAT>\r\n\t>;\r\n\r\n\t/**\r\n\t * Returns the amount of gas consumed by executing the method locally without creating a new transaction on the blockchain.\r\n\t * The returned amount can be used as a gas estimate for executing the transaction publicly. The actual gas used can be\r\n\t * different when sending the transaction later, as the state of the smart contract can be different at that time.\r\n\t *\r\n\t * ```ts\r\n\t * const gasAmount = await myContract.methods.myMethod(123).estimateGas({gas: 5000000});\r\n\t * if(gasAmount == 5000000) {\r\n\t *   console.log('Method ran out of gas');\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param options  - The options used for calling\r\n\t * @param returnFormat - The data format you want the output in.\r\n\t * @returns - The gas amount estimated.\r\n\t */\r\n\testimateGas<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(\r\n\t\toptions?: PayableCallOptions,\r\n\t\treturnFormat?: ReturnFormat,\r\n\t): Promise<FormatType<Numbers, ReturnFormat>>;\r\n\r\n\t/**\r\n\t * Encodes the ABI for this method. The resulting hex string is 32-bit function signature hash plus the passed parameters in Solidity tightly packed format.\r\n\t * This can be used to send a transaction, call a method, or pass it into another smart contract’s method as arguments.\r\n\t * Set the data field on `web3.eth.sendTransaction` options as the encodeABI() result and it is the same as calling the contract method with `contract.myMethod.send()`.\r\n\t *\r\n\t * Some use cases for encodeABI() include: preparing a smart contract transaction for a multi signature wallet,\r\n\t * working with offline wallets and cold storage and creating transaction payload for complex smart contract proxy calls.\r\n\t *\r\n\t * @returns - The encoded ABI byte code to send via a transaction or call.\r\n\t */\r\n\tencodeABI(): HexString;\r\n\r\n\t/**\r\n\t * This method generates an access list for a transaction. You must specify a `from` address and `gas` if it’s not specified in options.\r\n\t *\r\n\t * @param options - The options used for createAccessList.\r\n\t * @param block - If you pass this parameter it will not use the default block set with contract.defaultBlock. Pre-defined block numbers as `earliest`, `latest`, `pending`, `safe` or `finalized can also be used. Useful for requesting data from or replaying transactions in past blocks.\r\n\t * @returns The returned data of the createAccessList,  e.g. The generated access list for transaction.\r\n\t *\r\n\t * ```ts\r\n\t *  const result = await MyContract.methods.myFunction().createAccessList();\r\n\t *  console.log(result);\r\n\t *\r\n\t * > {\r\n\t *  \"accessList\": [\r\n\t *     {\r\n\t *       \"address\": \"0x15859bdf5aff2080a9968f6a410361e9598df62f\",\r\n\t *       \"storageKeys\": [\r\n\t *         \"0x0000000000000000000000000000000000000000000000000000000000000000\"\r\n\t *       ]\r\n\t *     }\r\n\t *   ],\r\n\t *   \"gasUsed\": \"0x7671\"\r\n\t * }\r\n\t *```\r\n\t */\r\n\tcreateAccessList(tx?: PayableCallOptions, block?: BlockNumberOrTag): Promise<AccessListResult>;\r\n}\r\n\r\nexport type Web3ContractContext = Partial<\r\n\tWeb3ContextInitOptions<\r\n\t\tEthExecutionAPI,\r\n\t\t{\r\n\t\t\tlogs: typeof LogsSubscription;\r\n\t\t\tnewHeads: typeof NewHeadsSubscription;\r\n\t\t\tnewBlockHeaders: typeof NewHeadsSubscription;\r\n\t\t}\r\n\t>\r\n>;\r\n"],"mappings":"AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = a => a instanceof Uint8Array;\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  if (hex.length % 2) throw new Error('hex string is invalid: unpadded ' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nexports.hexToBytes = hexToBytes;\n// Big Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nconst numberToBytesBE = (n, len) => hexToBytes(n.toString(16).padStart(len * 2, '0'));\nexports.numberToBytesBE = numberToBytesBE;\nconst numberToBytesLE = (n, len) => (0, exports.numberToBytesBE)(n, len).reverse();\nexports.numberToBytesLE = numberToBytesLE;\n// Returns variable number bytes (minimal bigint encoding?)\nconst numberToVarBytesBE = n => hexToBytes(numberToHexUnpadded(n));\nexports.numberToVarBytesBE = numberToVarBytesBE;\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\nexports.ensureBytes = ensureBytes;\n// Copies several Uint8Arrays into one.\nfunction concatBytes() {\n  for (var _len = arguments.length, arrs = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrs[_key] = arguments[_key];\n  }\n  const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrs.forEach(a => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\nexports.equalBytes = equalBytes;\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n// Amount of bits inside bigint (Same as n.toString(2).length)\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\nexports.bitLen = bitLen;\n// Gets single bit at position. NOTE: first bit position is 0 (same as arrays)\n// Same as !!+Array.from(n.toString(2)).reverse()[pos]\nconst bitGet = (n, pos) => n >> BigInt(pos) & _1n;\nexports.bitGet = bitGet;\n// Sets single bit at position\nconst bitSet = (n, pos, value) => n | (value ? _1n : _0n) << BigInt(pos);\nexports.bitSet = bitSet;\n// Return mask for N bits (Same as BigInt(`0b${Array(i).fill('1').join('')}`))\n// Not using ** operator with bigints for old engines.\nconst bitMask = n => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\r\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n * @returns function that will call DRBG until 2nd arg returns something meaningful\r\n * @example\r\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\r\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\r\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = function () {\n    for (var _len2 = arguments.length, b = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      b[_key2] = arguments[_key2];\n    }\n    return hmacFn(k, v, ...b);\n  }; // hmac(k)(v, ...values)\n  const reseed = function () {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u8n();\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators) {\n  let optValidators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\nexports.validateObject = validateObject;\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });","map":{"version":3,"names":["_0n","BigInt","_1n","_2n","u8a","a","Uint8Array","hexes","Array","from","length","v","i","toString","padStart","bytesToHex","bytes","Error","hex","exports","numberToHexUnpadded","num","hexToNumber","hexToBytes","array","j","hexByte","slice","byte","Number","parseInt","isNaN","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","n","len","numberToBytesLE","numberToVarBytesBE","ensureBytes","title","expectedLength","res","e","concatBytes","_len","arguments","arrs","_key","r","reduce","sum","pad","forEach","set","equalBytes","b1","b2","utf8ToBytes","str","TextEncoder","encode","bitLen","bitGet","pos","bitSet","value","bitMask","u8n","data","u8fr","arr","createHmacDrbg","hashLen","qByteLen","hmacFn","k","reset","fill","h","_len2","b","_key2","reseed","seed","undefined","gen","out","sl","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","isSafeInteger","isArray","field","object","Fp","isValid","hash","outputLen","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\@noble\\curves\\src\\abstract\\utils.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\nconst _2n = BigInt(2);\r\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\r\n\r\n// We accept hex strings besides Uint8Array for simplicity\r\nexport type Hex = Uint8Array | string;\r\n// Very few implementations accept numbers, we do it to ease learning curve\r\nexport type PrivKey = Hex | bigint;\r\nexport type CHash = {\r\n  (message: Uint8Array | string): Uint8Array;\r\n  blockLen: number;\r\n  outputLen: number;\r\n  create(opts?: { dkLen?: number }): any; // For shake\r\n};\r\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\r\n\r\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\r\nexport function bytesToHex(bytes: Uint8Array): string {\r\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\r\n  // pre-caching improves the speed 6x\r\n  let hex = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    hex += hexes[bytes[i]];\r\n  }\r\n  return hex;\r\n}\r\n\r\nexport function numberToHexUnpadded(num: number | bigint): string {\r\n  const hex = num.toString(16);\r\n  return hex.length & 1 ? `0${hex}` : hex;\r\n}\r\n\r\nexport function hexToNumber(hex: string): bigint {\r\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\r\n  // Big Endian\r\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\r\n}\r\n\r\n// Caching slows it down 2-3x\r\nexport function hexToBytes(hex: string): Uint8Array {\r\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\r\n  if (hex.length % 2) throw new Error('hex string is invalid: unpadded ' + hex.length);\r\n  const array = new Uint8Array(hex.length / 2);\r\n  for (let i = 0; i < array.length; i++) {\r\n    const j = i * 2;\r\n    const hexByte = hex.slice(j, j + 2);\r\n    const byte = Number.parseInt(hexByte, 16);\r\n    if (Number.isNaN(byte) || byte < 0) throw new Error('invalid byte sequence');\r\n    array[i] = byte;\r\n  }\r\n  return array;\r\n}\r\n\r\n// Big Endian\r\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\r\n  return hexToNumber(bytesToHex(bytes));\r\n}\r\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\r\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\r\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\r\n}\r\n\r\nexport const numberToBytesBE = (n: bigint, len: number) =>\r\n  hexToBytes(n.toString(16).padStart(len * 2, '0'));\r\nexport const numberToBytesLE = (n: bigint, len: number) => numberToBytesBE(n, len).reverse();\r\n// Returns variable number bytes (minimal bigint encoding?)\r\nexport const numberToVarBytesBE = (n: bigint) => hexToBytes(numberToHexUnpadded(n));\r\n\r\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\r\n  let res: Uint8Array;\r\n  if (typeof hex === 'string') {\r\n    try {\r\n      res = hexToBytes(hex);\r\n    } catch (e) {\r\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\r\n    }\r\n  } else if (u8a(hex)) {\r\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\r\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\r\n    res = Uint8Array.from(hex);\r\n  } else {\r\n    throw new Error(`${title} must be hex string or Uint8Array`);\r\n  }\r\n  const len = res.length;\r\n  if (typeof expectedLength === 'number' && len !== expectedLength)\r\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\r\n  return res;\r\n}\r\n\r\n// Copies several Uint8Arrays into one.\r\nexport function concatBytes(...arrs: Uint8Array[]): Uint8Array {\r\n  const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));\r\n  let pad = 0; // walk through each item, ensure they have proper type\r\n  arrs.forEach((a) => {\r\n    if (!u8a(a)) throw new Error('Uint8Array expected');\r\n    r.set(a, pad);\r\n    pad += a.length;\r\n  });\r\n  return r;\r\n}\r\n\r\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\r\n  // We don't care about timing attacks here\r\n  if (b1.length !== b2.length) return false;\r\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\r\n  return true;\r\n}\r\n\r\n// Global symbols in both browsers and Node.js since v11\r\n// See https://github.com/microsoft/TypeScript/issues/31535\r\ndeclare const TextEncoder: any;\r\nexport function utf8ToBytes(str: string): Uint8Array {\r\n  if (typeof str !== 'string') {\r\n    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\r\n  }\r\n  return new TextEncoder().encode(str);\r\n}\r\n\r\n// Bit operations\r\n\r\n// Amount of bits inside bigint (Same as n.toString(2).length)\r\nexport function bitLen(n: bigint) {\r\n  let len;\r\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\r\n  return len;\r\n}\r\n// Gets single bit at position. NOTE: first bit position is 0 (same as arrays)\r\n// Same as !!+Array.from(n.toString(2)).reverse()[pos]\r\nexport const bitGet = (n: bigint, pos: number) => (n >> BigInt(pos)) & _1n;\r\n// Sets single bit at position\r\nexport const bitSet = (n: bigint, pos: number, value: boolean) =>\r\n  n | ((value ? _1n : _0n) << BigInt(pos));\r\n// Return mask for N bits (Same as BigInt(`0b${Array(i).fill('1').join('')}`))\r\n// Not using ** operator with bigints for old engines.\r\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\r\n\r\n// DRBG\r\n\r\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\r\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\r\ntype Pred<T> = (v: Uint8Array) => T | undefined;\r\n/**\r\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n * @returns function that will call DRBG until 2nd arg returns something meaningful\r\n * @example\r\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\r\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\r\n */\r\nexport function createHmacDrbg<T>(\r\n  hashLen: number,\r\n  qByteLen: number,\r\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\r\n): (seed: Uint8Array, predicate: Pred<T>) => T {\r\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\r\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\r\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\r\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\r\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\r\n  let i = 0; // Iterations counter, will throw when over 1000\r\n  const reset = () => {\r\n    v.fill(1);\r\n    k.fill(0);\r\n    i = 0;\r\n  };\r\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\r\n  const reseed = (seed = u8n()) => {\r\n    // HMAC-DRBG reseed() function. Steps D-G\r\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\r\n    v = h(); // v = hmac(k || v)\r\n    if (seed.length === 0) return;\r\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\r\n    v = h(); // v = hmac(k || v)\r\n  };\r\n  const gen = () => {\r\n    // HMAC-DRBG generate() function\r\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\r\n    let len = 0;\r\n    const out: Uint8Array[] = [];\r\n    while (len < qByteLen) {\r\n      v = h();\r\n      const sl = v.slice();\r\n      out.push(sl);\r\n      len += v.length;\r\n    }\r\n    return concatBytes(...out);\r\n  };\r\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\r\n    reset();\r\n    reseed(seed); // Steps D-G\r\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\r\n    while (!(res = pred(gen()))) reseed();\r\n    reset();\r\n    return res;\r\n  };\r\n  return genUntil;\r\n}\r\n\r\n// Validating curves and fields\r\n\r\nconst validatorFns = {\r\n  bigint: (val: any) => typeof val === 'bigint',\r\n  function: (val: any) => typeof val === 'function',\r\n  boolean: (val: any) => typeof val === 'boolean',\r\n  string: (val: any) => typeof val === 'string',\r\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\r\n  array: (val: any) => Array.isArray(val),\r\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\r\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\r\n} as const;\r\ntype Validator = keyof typeof validatorFns;\r\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\r\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\r\n\r\nexport function validateObject<T extends Record<string, any>>(\r\n  object: T,\r\n  validators: ValMap<T>,\r\n  optValidators: ValMap<T> = {}\r\n) {\r\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\r\n    const checkVal = validatorFns[type];\r\n    if (typeof checkVal !== 'function')\r\n      throw new Error(`Invalid validator \"${type}\", expected function`);\r\n\r\n    const val = object[fieldName as keyof typeof object];\r\n    if (isOptional && val === undefined) return;\r\n    if (!checkVal(val, object)) {\r\n      throw new Error(\r\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\r\n      );\r\n    }\r\n  };\r\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\r\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\r\n  return object;\r\n}\r\n// validate type tests\r\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\r\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\r\n// // Should fail type-check\r\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\r\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\r\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\r\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
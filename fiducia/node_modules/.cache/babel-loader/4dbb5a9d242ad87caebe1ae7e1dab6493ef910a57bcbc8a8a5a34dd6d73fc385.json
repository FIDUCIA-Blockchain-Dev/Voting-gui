{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { utf8ToBytes } from 'ethereum-cryptography/utils.js';\nimport { InvalidAddressError, InvalidBooleanError, InvalidBytesError, InvalidLargeValueError, InvalidSizeError, InvalidStringError, InvalidUnsignedIntegerError } from 'web3-errors';\nimport { isAddress, isNullish, isHexStrict } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, hexToBytes, toBigInt, toHex, toNumber, utf8ToHex } from './converters.js';\nimport { leftPad, rightPad, toTwosComplement } from './string_manipulation.js';\nconst SHA3_EMPTY_BYTES = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\r\n * computes the Keccak-256 hash of the input and returns a hexstring\r\n * @param data - the input to hash\r\n * @returns - the Keccak-256 hash of the input\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.sha3('web3.js'));\r\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\r\n *\r\n * console.log(web3.utils.sha3(''));\r\n * > undefined\r\n * ```\r\n */\nexport const sha3 = data => {\n  let updatedData;\n  if (typeof data === 'string') {\n    if (data.startsWith('0x') && isHexStrict(data)) {\n      updatedData = hexToBytes(data);\n    } else {\n      updatedData = utf8ToBytes(data);\n    }\n  } else {\n    updatedData = data;\n  }\n  const hash = bytesToHex(keccak256(updatedData));\n  // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n  return hash === SHA3_EMPTY_BYTES ? undefined : hash;\n};\n/**\r\n * Will calculate the sha3 of the input but does return the hash value instead of null if for example a empty string is passed.\r\n * @param data - the input to hash\r\n * @returns - the Keccak-256 hash of the input\r\n *\r\n * @example\r\n * ```ts\r\n * conosle.log(web3.utils.sha3Raw('web3.js'));\r\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\r\n *\r\n * console.log(web3.utils.sha3Raw(''));\r\n * > 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\r\n * ```\r\n */\nexport const sha3Raw = data => {\n  const hash = sha3(data);\n  if (isNullish(hash)) {\n    return SHA3_EMPTY_BYTES;\n  }\n  return hash;\n};\n/**\r\n * A wrapper for ethereum-cryptography/keccak256 to allow hashing a `string` and a `bigint` in addition to `UInt8Array`\r\n * @param data - the input to hash\r\n * @returns - the Keccak-256 hash of the input\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.keccak256Wrapper('web3.js'));\r\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\r\n *\r\n * console.log(web3.utils.keccak256Wrapper(1));\r\n * > 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6\r\n *\r\n * console.log(web3.utils.keccak256Wrapper(0xaf12fd));\r\n * > 0x358640fd4719fa923525d74ab5ae80a594301aba5543e3492b052bf4598b794c\r\n * ```\r\n */\nexport const keccak256Wrapper = data => {\n  let processedData;\n  if (typeof data === 'bigint' || typeof data === 'number') {\n    processedData = utf8ToBytes(data.toString());\n  } else if (Array.isArray(data)) {\n    processedData = new Uint8Array(data);\n  } else if (typeof data === 'string' && !isHexStrict(data)) {\n    processedData = utf8ToBytes(data);\n  } else {\n    processedData = bytesToUint8Array(data);\n  }\n  return bytesToHex(keccak256(processedData));\n};\nexport { keccak256Wrapper as keccak256 };\n/**\r\n * returns type and value\r\n * @param arg - the input to return the type and value\r\n * @returns - the type and value of the input\r\n */\nconst getType = arg => {\n  if (Array.isArray(arg)) {\n    throw new Error('Autodetection of array types is not supported.');\n  }\n  let type;\n  let value;\n  // if type is given\n  if (typeof arg === 'object' && ('t' in arg || 'type' in arg) && ('v' in arg || 'value' in arg)) {\n    type = 't' in arg ? arg.t : arg.type;\n    value = 'v' in arg ? arg.v : arg.value;\n    // otherwise try to guess the type\n  } else {\n    type = toHex(arg, true);\n    value = toHex(arg);\n    if (!type.startsWith('int') && !type.startsWith('uint')) {\n      type = 'bytes';\n    }\n  }\n  if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n    value = toBigInt(value);\n  }\n  return [type, value];\n};\n/**\r\n * returns the type with size if uint or int\r\n * @param name - the input to return the type with size\r\n * @returns - the type with size of the input\r\n */\nconst elementaryName = name => {\n  if (name.startsWith('int[')) {\n    return `int256${name.slice(3)}`;\n  }\n  if (name === 'int') {\n    return 'int256';\n  }\n  if (name.startsWith('uint[')) {\n    return `uint256'${name.slice(4)}`;\n  }\n  if (name === 'uint') {\n    return 'uint256';\n  }\n  return name;\n};\n/**\r\n * returns the size of the value of type 'byte'\r\n */\nconst parseTypeN = (value, typeLength) => {\n  const typesize = /^(\\d+).*$/.exec(value.slice(typeLength));\n  return typesize ? parseInt(typesize[1], 10) : 0;\n};\n/**\r\n * returns the bit length of the value\r\n * @param value - the input to return the bit length\r\n * @returns - the bit length of the input\r\n */\nconst bitLength = value => {\n  const updatedVal = value.toString(2);\n  return updatedVal.length;\n};\n/**\r\n * Pads the value based on size and type\r\n * returns a string of the padded value\r\n * @param type - the input to pad\r\n * @returns = the padded value\r\n */\nconst solidityPack = (type, val) => {\n  const value = val.toString();\n  if (type === 'string') {\n    if (typeof val === 'string') return utf8ToHex(val);\n    throw new InvalidStringError(val);\n  }\n  if (type === 'bool' || type === 'boolean') {\n    if (typeof val === 'boolean') return val ? '01' : '00';\n    throw new InvalidBooleanError(val);\n  }\n  if (type === 'address') {\n    if (!isAddress(value)) {\n      throw new InvalidAddressError(value);\n    }\n    return value;\n  }\n  const name = elementaryName(type);\n  if (type.startsWith('uint')) {\n    const size = parseTypeN(name, 'uint'.length);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new InvalidSizeError(value);\n    }\n    const num = toNumber(value);\n    if (bitLength(num) > size) {\n      throw new InvalidLargeValueError(value);\n    }\n    if (num < BigInt(0)) {\n      throw new InvalidUnsignedIntegerError(value);\n    }\n    return size ? leftPad(num.toString(16), size / 8 * 2) : num.toString(16);\n  }\n  if (type.startsWith('int')) {\n    const size = parseTypeN(name, 'int'.length);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new InvalidSizeError(type);\n    }\n    const num = toNumber(value);\n    if (bitLength(num) > size) {\n      throw new InvalidLargeValueError(value);\n    }\n    if (num < BigInt(0)) {\n      return toTwosComplement(num.toString(), size / 8 * 2);\n    }\n    return size ? leftPad(num.toString(16), size / 4) : num.toString(16);\n  }\n  if (name === 'bytes') {\n    if (value.replace(/^0x/i, '').length % 2 !== 0) {\n      throw new InvalidBytesError(value);\n    }\n    return value;\n  }\n  if (type.startsWith('bytes')) {\n    if (value.replace(/^0x/i, '').length % 2 !== 0) {\n      throw new InvalidBytesError(value);\n    }\n    const size = parseTypeN(type, 'bytes'.length);\n    if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, '').length / 2) {\n      throw new InvalidBytesError(value);\n    }\n    return rightPad(value, size * 2);\n  }\n  return '';\n};\n/**\r\n * returns a string of the tightly packed value given based on the type\r\n * @param arg - the input to return the tightly packed value\r\n * @returns - the tightly packed value\r\n */\nexport const processSolidityEncodePackedArgs = arg => {\n  const [type, val] = getType(arg);\n  // array case\n  if (Array.isArray(val)) {\n    // go through each element of the array and use map function to create new hexarg list\n    const hexArg = val.map(v => solidityPack(type, v).replace('0x', ''));\n    return hexArg.join('');\n  }\n  const hexArg = solidityPack(type, val);\n  return hexArg.replace('0x', '');\n};\n/**\r\n * Encode packed arguments to a hexstring\r\n */\nexport const encodePacked = function () {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  const args = Array.prototype.slice.call(values);\n  const hexArgs = args.map(processSolidityEncodePackedArgs);\n  return `0x${hexArgs.join('').toLowerCase()}`;\n};\n/**\r\n * Will tightly pack values given in the same way solidity would then hash.\r\n * returns a hash string, or null if input is empty\r\n * @param values - the input to return the tightly packed values\r\n * @returns - the keccack246 of the tightly packed values\r\n *\r\n * @example\r\n * ```ts\r\n *  console.log([{ type: 'string', value: '31323334' }]);\r\n * console.log(web3.utils.soliditySha3({ type: \"string\", value: \"31323334\" }));\r\n * > 0xf15f8da2ad27e486d632dc37d24912f634398918d6f9913a0a0ff84e388be62b\r\n * ```\r\n */\nexport const soliditySha3 = function () {\n  return sha3(encodePacked(...arguments));\n};\n/**\r\n * Will tightly pack values given in the same way solidity would then hash.\r\n * returns a hash string, if input is empty will return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`\r\n * @param values - the input to return the tightly packed values\r\n * @returns - the keccack246 of the tightly packed values\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.soliditySha3Raw({ type: \"string\", value: \"helloworld\" }))\r\n * > 0xfa26db7ca85ead399216e7c6316bc50ed24393c3122b582735e7f3b0f91b93f0\r\n * ```\r\n */\nexport const soliditySha3Raw = function () {\n  return sha3Raw(encodePacked(...arguments));\n};\n/**\r\n * Get slot number for storage long string in contract. Basically for getStorage method\r\n * returns slotNumber where will data placed\r\n * @param mainSlotNumber - the slot number where will be stored hash of long string\r\n * @returns - the slot number where will be stored long string\r\n */\nexport const getStorageSlotNumForLongString = mainSlotNumber => sha3(`0x${(typeof mainSlotNumber === 'number' ? mainSlotNumber.toString() : mainSlotNumber).padStart(64, '0')}`);","map":{"version":3,"names":["keccak256","utf8ToBytes","InvalidAddressError","InvalidBooleanError","InvalidBytesError","InvalidLargeValueError","InvalidSizeError","InvalidStringError","InvalidUnsignedIntegerError","isAddress","isNullish","isHexStrict","bytesToUint8Array","bytesToHex","hexToBytes","toBigInt","toHex","toNumber","utf8ToHex","leftPad","rightPad","toTwosComplement","SHA3_EMPTY_BYTES","sha3","data","updatedData","startsWith","hash","undefined","sha3Raw","keccak256Wrapper","processedData","toString","Array","isArray","Uint8Array","getType","arg","Error","type","value","t","v","test","elementaryName","name","slice","parseTypeN","typeLength","typesize","exec","parseInt","bitLength","updatedVal","length","solidityPack","val","size","num","BigInt","replace","processSolidityEncodePackedArgs","hexArg","map","join","encodePacked","_len","arguments","values","_key","args","prototype","call","hexArgs","toLowerCase","soliditySha3","soliditySha3Raw","getStorageSlotNumForLongString","mainSlotNumber","padStart"],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-utils\\src\\hash.ts"],"sourcesContent":["﻿/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\r\nimport { utf8ToBytes } from 'ethereum-cryptography/utils.js';\r\nimport {\r\n\tInvalidAddressError,\r\n\tInvalidBooleanError,\r\n\tInvalidBytesError,\r\n\tInvalidLargeValueError,\r\n\tInvalidSizeError,\r\n\tInvalidStringError,\r\n\tInvalidUnsignedIntegerError,\r\n} from 'web3-errors';\r\nimport {\r\n\tBytes,\r\n\tEncodingTypes,\r\n\tNumbers,\r\n\tSha3Input,\r\n\tTypedObject,\r\n\tTypedObjectAbbreviated,\r\n} from 'web3-types';\r\nimport { isAddress, isNullish, isHexStrict } from 'web3-validator';\r\nimport {\r\n\tbytesToUint8Array,\r\n\tbytesToHex,\r\n\thexToBytes,\r\n\ttoBigInt,\r\n\ttoHex,\r\n\ttoNumber,\r\n\tutf8ToHex,\r\n} from './converters.js';\r\nimport { leftPad, rightPad, toTwosComplement } from './string_manipulation.js';\r\n\r\nconst SHA3_EMPTY_BYTES = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\r\n\r\n/**\r\n * computes the Keccak-256 hash of the input and returns a hexstring\r\n * @param data - the input to hash\r\n * @returns - the Keccak-256 hash of the input\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.sha3('web3.js'));\r\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\r\n *\r\n * console.log(web3.utils.sha3(''));\r\n * > undefined\r\n * ```\r\n */\r\nexport const sha3 = (data: Bytes): string | undefined => {\r\n\tlet updatedData: Uint8Array;\r\n\r\n\tif (typeof data === 'string') {\r\n\t\tif (data.startsWith('0x') && isHexStrict(data)) {\r\n\t\t\tupdatedData = hexToBytes(data);\r\n\t\t} else {\r\n\t\t\tupdatedData = utf8ToBytes(data);\r\n\t\t}\r\n\t} else {\r\n\t\tupdatedData = data;\r\n\t}\r\n\tconst hash = bytesToHex(keccak256(updatedData));\r\n\r\n\t// EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\r\n\treturn hash === SHA3_EMPTY_BYTES ? undefined : hash;\r\n};\r\n\r\n/**\r\n * Will calculate the sha3 of the input but does return the hash value instead of null if for example a empty string is passed.\r\n * @param data - the input to hash\r\n * @returns - the Keccak-256 hash of the input\r\n *\r\n * @example\r\n * ```ts\r\n * conosle.log(web3.utils.sha3Raw('web3.js'));\r\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\r\n *\r\n * console.log(web3.utils.sha3Raw(''));\r\n * > 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\r\n * ```\r\n */\r\nexport const sha3Raw = (data: Bytes): string => {\r\n\tconst hash = sha3(data);\r\n\tif (isNullish(hash)) {\r\n\t\treturn SHA3_EMPTY_BYTES;\r\n\t}\r\n\r\n\treturn hash;\r\n};\r\n\r\n/**\r\n * A wrapper for ethereum-cryptography/keccak256 to allow hashing a `string` and a `bigint` in addition to `UInt8Array`\r\n * @param data - the input to hash\r\n * @returns - the Keccak-256 hash of the input\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.keccak256Wrapper('web3.js'));\r\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\r\n *\r\n * console.log(web3.utils.keccak256Wrapper(1));\r\n * > 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6\r\n *\r\n * console.log(web3.utils.keccak256Wrapper(0xaf12fd));\r\n * > 0x358640fd4719fa923525d74ab5ae80a594301aba5543e3492b052bf4598b794c\r\n * ```\r\n */\r\nexport const keccak256Wrapper = (\r\n\tdata: Bytes | Numbers | string | ReadonlyArray<number>,\r\n): string => {\r\n\tlet processedData;\r\n\tif (typeof data === 'bigint' || typeof data === 'number') {\r\n\t\tprocessedData = utf8ToBytes(data.toString());\r\n\t} else if (Array.isArray(data)) {\r\n\t\tprocessedData = new Uint8Array(data);\r\n\t} else if (typeof data === 'string' && !isHexStrict(data)) {\r\n\t\tprocessedData = utf8ToBytes(data);\r\n\t} else {\r\n\t\tprocessedData = bytesToUint8Array(data as Bytes);\r\n\t}\r\n\treturn bytesToHex(keccak256(processedData));\r\n};\r\n\r\nexport { keccak256Wrapper as keccak256 };\r\n\r\n/**\r\n * returns type and value\r\n * @param arg - the input to return the type and value\r\n * @returns - the type and value of the input\r\n */\r\nconst getType = (arg: Sha3Input): [string, EncodingTypes] => {\r\n\tif (Array.isArray(arg)) {\r\n\t\tthrow new Error('Autodetection of array types is not supported.');\r\n\t}\r\n\r\n\tlet type;\r\n\tlet value;\r\n\t// if type is given\r\n\tif (\r\n\t\ttypeof arg === 'object' &&\r\n\t\t('t' in arg || 'type' in arg) &&\r\n\t\t('v' in arg || 'value' in arg)\r\n\t) {\r\n\t\ttype = 't' in arg ? arg.t : arg.type;\r\n\t\tvalue = 'v' in arg ? arg.v : arg.value;\r\n\r\n\t\t// otherwise try to guess the type\r\n\t} else {\r\n\t\ttype = toHex(arg, true);\r\n\t\tvalue = toHex(arg);\r\n\r\n\t\tif (!type.startsWith('int') && !type.startsWith('uint')) {\r\n\t\t\ttype = 'bytes';\r\n\t\t}\r\n\t}\r\n\r\n\tif (\r\n\t\t(type.startsWith('int') || type.startsWith('uint')) &&\r\n\t\ttypeof value === 'string' &&\r\n\t\t!/^(-)?0x/i.test(value)\r\n\t) {\r\n\t\tvalue = toBigInt(value);\r\n\t}\r\n\treturn [type, value];\r\n};\r\n\r\n/**\r\n * returns the type with size if uint or int\r\n * @param name - the input to return the type with size\r\n * @returns - the type with size of the input\r\n */\r\nconst elementaryName = (name: string): string => {\r\n\tif (name.startsWith('int[')) {\r\n\t\treturn `int256${name.slice(3)}`;\r\n\t}\r\n\tif (name === 'int') {\r\n\t\treturn 'int256';\r\n\t}\r\n\tif (name.startsWith('uint[')) {\r\n\t\treturn `uint256'${name.slice(4)}`;\r\n\t}\r\n\tif (name === 'uint') {\r\n\t\treturn 'uint256';\r\n\t}\r\n\treturn name;\r\n};\r\n\r\n/**\r\n * returns the size of the value of type 'byte'\r\n */\r\nconst parseTypeN = (value: string, typeLength: number): number => {\r\n\tconst typesize = /^(\\d+).*$/.exec(value.slice(typeLength));\r\n\treturn typesize ? parseInt(typesize[1], 10) : 0;\r\n};\r\n\r\n/**\r\n * returns the bit length of the value\r\n * @param value - the input to return the bit length\r\n * @returns - the bit length of the input\r\n */\r\nconst bitLength = (value: bigint | number): number => {\r\n\tconst updatedVal = value.toString(2);\r\n\treturn updatedVal.length;\r\n};\r\n\r\n/**\r\n * Pads the value based on size and type\r\n * returns a string of the padded value\r\n * @param type - the input to pad\r\n * @returns = the padded value\r\n */\r\nconst solidityPack = (type: string, val: EncodingTypes): string => {\r\n\tconst value = val.toString();\r\n\tif (type === 'string') {\r\n\t\tif (typeof val === 'string') return utf8ToHex(val);\r\n\t\tthrow new InvalidStringError(val);\r\n\t}\r\n\tif (type === 'bool' || type === 'boolean') {\r\n\t\tif (typeof val === 'boolean') return val ? '01' : '00';\r\n\t\tthrow new InvalidBooleanError(val);\r\n\t}\r\n\r\n\tif (type === 'address') {\r\n\t\tif (!isAddress(value)) {\r\n\t\t\tthrow new InvalidAddressError(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\tconst name = elementaryName(type);\r\n\tif (type.startsWith('uint')) {\r\n\t\tconst size = parseTypeN(name, 'uint'.length);\r\n\r\n\t\tif (size % 8 || size < 8 || size > 256) {\r\n\t\t\tthrow new InvalidSizeError(value);\r\n\t\t}\r\n\t\tconst num = toNumber(value);\r\n\t\tif (bitLength(num) > size) {\r\n\t\t\tthrow new InvalidLargeValueError(value);\r\n\t\t}\r\n\t\tif (num < BigInt(0)) {\r\n\t\t\tthrow new InvalidUnsignedIntegerError(value);\r\n\t\t}\r\n\r\n\t\treturn size ? leftPad(num.toString(16), (size / 8) * 2) : num.toString(16);\r\n\t}\r\n\r\n\tif (type.startsWith('int')) {\r\n\t\tconst size = parseTypeN(name, 'int'.length);\r\n\t\tif (size % 8 || size < 8 || size > 256) {\r\n\t\t\tthrow new InvalidSizeError(type);\r\n\t\t}\r\n\r\n\t\tconst num = toNumber(value);\r\n\t\tif (bitLength(num) > size) {\r\n\t\t\tthrow new InvalidLargeValueError(value);\r\n\t\t}\r\n\t\tif (num < BigInt(0)) {\r\n\t\t\treturn toTwosComplement(num.toString(), (size / 8) * 2);\r\n\t\t}\r\n\t\treturn size ? leftPad(num.toString(16), size / 4) : num.toString(16);\r\n\t}\r\n\r\n\tif (name === 'bytes') {\r\n\t\tif (value.replace(/^0x/i, '').length % 2 !== 0) {\r\n\t\t\tthrow new InvalidBytesError(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\tif (type.startsWith('bytes')) {\r\n\t\tif (value.replace(/^0x/i, '').length % 2 !== 0) {\r\n\t\t\tthrow new InvalidBytesError(value);\r\n\t\t}\r\n\r\n\t\tconst size = parseTypeN(type, 'bytes'.length);\r\n\r\n\t\tif (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, '').length / 2) {\r\n\t\t\tthrow new InvalidBytesError(value);\r\n\t\t}\r\n\r\n\t\treturn rightPad(value, size * 2);\r\n\t}\r\n\treturn '';\r\n};\r\n\r\n/**\r\n * returns a string of the tightly packed value given based on the type\r\n * @param arg - the input to return the tightly packed value\r\n * @returns - the tightly packed value\r\n */\r\nexport const processSolidityEncodePackedArgs = (arg: Sha3Input): string => {\r\n\tconst [type, val] = getType(arg);\r\n\r\n\t// array case\r\n\tif (Array.isArray(val)) {\r\n\t\t// go through each element of the array and use map function to create new hexarg list\r\n\t\tconst hexArg = val.map((v: Numbers | boolean) => solidityPack(type, v).replace('0x', ''));\r\n\t\treturn hexArg.join('');\r\n\t}\r\n\r\n\tconst hexArg = solidityPack(type, val);\r\n\treturn hexArg.replace('0x', '');\r\n};\r\n\r\n/**\r\n * Encode packed arguments to a hexstring\r\n */\r\nexport const encodePacked = (...values: Sha3Input[]): string => {\r\n\tconst args = Array.prototype.slice.call(values);\r\n\tconst hexArgs = args.map(processSolidityEncodePackedArgs);\r\n\treturn `0x${hexArgs.join('').toLowerCase()}`;\r\n};\r\n\r\n/**\r\n * Will tightly pack values given in the same way solidity would then hash.\r\n * returns a hash string, or null if input is empty\r\n * @param values - the input to return the tightly packed values\r\n * @returns - the keccack246 of the tightly packed values\r\n *\r\n * @example\r\n * ```ts\r\n *  console.log([{ type: 'string', value: '31323334' }]);\r\n * console.log(web3.utils.soliditySha3({ type: \"string\", value: \"31323334\" }));\r\n * > 0xf15f8da2ad27e486d632dc37d24912f634398918d6f9913a0a0ff84e388be62b\r\n * ```\r\n */\r\nexport const soliditySha3 = (...values: Sha3Input[]): string | undefined =>\r\n\tsha3(encodePacked(...values));\r\n\r\n/**\r\n * Will tightly pack values given in the same way solidity would then hash.\r\n * returns a hash string, if input is empty will return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`\r\n * @param values - the input to return the tightly packed values\r\n * @returns - the keccack246 of the tightly packed values\r\n *\r\n * @example\r\n * ```ts\r\n * console.log(web3.utils.soliditySha3Raw({ type: \"string\", value: \"helloworld\" }))\r\n * > 0xfa26db7ca85ead399216e7c6316bc50ed24393c3122b582735e7f3b0f91b93f0\r\n * ```\r\n */\r\nexport const soliditySha3Raw = (...values: TypedObject[] | TypedObjectAbbreviated[]): string =>\r\n\tsha3Raw(encodePacked(...values));\r\n\r\n/**\r\n * Get slot number for storage long string in contract. Basically for getStorage method\r\n * returns slotNumber where will data placed\r\n * @param mainSlotNumber - the slot number where will be stored hash of long string\r\n * @returns - the slot number where will be stored long string\r\n */\r\nexport const getStorageSlotNumForLongString = (mainSlotNumber: number | string) =>\r\n\tsha3(\r\n\t\t`0x${(typeof mainSlotNumber === 'number'\r\n\t\t\t? mainSlotNumber.toString()\r\n\t\t\t: mainSlotNumber\r\n\t\t).padStart(64, '0')}`,\r\n\t);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
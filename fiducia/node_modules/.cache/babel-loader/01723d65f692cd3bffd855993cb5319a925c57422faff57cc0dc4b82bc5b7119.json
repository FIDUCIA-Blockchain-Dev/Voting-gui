{"ast":null,"code":"/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\nexport {};","map":{"version":3,"names":[],"sources":["C:\\Users\\lakka\\OneDrive - Manipal Academy of Higher Education\\FIDUCIA\\voting-gui\\fiducia\\node_modules\\web3-types\\src\\eth_abi_types.ts"],"sourcesContent":["/*\r\nThis file is part of web3.js.\r\n\r\nweb3.js is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nweb3.js is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport { Address } from './eth_types.js';\r\nimport { Bytes, Numbers } from './primitives_types.js';\r\nimport { FixedSizeArray } from './utility_types.js';\r\n\r\ntype _SolidityIndexRange =\r\n\t| 1\r\n\t| 2\r\n\t| 3\r\n\t| 4\r\n\t| 5\r\n\t| 6\r\n\t| 7\r\n\t| 8\r\n\t| 9\r\n\t| 10\r\n\t| 11\r\n\t| 12\r\n\t| 13\r\n\t| 14\r\n\t| 15\r\n\t| 16\r\n\t| 17\r\n\t| 18\r\n\t| 19\r\n\t| 20\r\n\t| 21\r\n\t| 22\r\n\t| 25\r\n\t| 26\r\n\t| 27\r\n\t| 28\r\n\t| 29\r\n\t| 30;\r\n\r\nexport type ConvertToNumber<\r\n\tT extends string,\r\n\tRange extends number = _SolidityIndexRange,\r\n> = Range extends unknown ? (`${Range}` extends T ? Range : never) : never;\r\n\r\nexport type Components = {\r\n\tname: string;\r\n\ttype: string;\r\n\tindexed?: boolean;\r\n\tcomponents?: Components[];\r\n};\r\n\r\nexport interface AbiStruct {\r\n\t[key: string]: unknown;\r\n\tname?: string;\r\n\ttype: string;\r\n}\r\n\r\nexport interface AbiCoderStruct extends AbiStruct {\r\n\t[key: string]: unknown;\r\n\tcomponents?: Array<AbiStruct>;\r\n}\r\n\r\n// https://docs.soliditylang.org/en/latest/abi-spec.html#json\r\nexport type AbiParameter = {\r\n\treadonly name: string;\r\n\treadonly type: string;\r\n\treadonly baseType?: string;\r\n\treadonly indexed?: boolean;\r\n\treadonly components?: ReadonlyArray<AbiParameter>;\r\n\treadonly arrayLength?: number;\r\n\treadonly arrayChildren?: ReadonlyArray<AbiParameter>;\r\n\treadonly internalType?: string;\r\n};\r\n\r\ntype FragmentTypes = 'constructor' | 'event' | 'function' | 'fallback' | 'receive';\r\n\r\nexport type AbiBaseFragment = {\r\n\t// type will default to string if passed ABI is declared without \"as const\"\r\n\treadonly type: string | FragmentTypes;\r\n};\r\n\r\n// To assign an ABI which is not declared `as const` need to specify a generic string\r\n\r\n// https://docs.soliditylang.org/en/latest/abi-spec.html#json\r\nexport type AbiConstructorFragment = AbiBaseFragment & {\r\n\treadonly type: string | 'constructor';\r\n\treadonly stateMutability: string | 'nonpayable' | 'payable';\r\n\treadonly inputs?: ReadonlyArray<AbiParameter>;\r\n};\r\n\r\n// https://docs.soliditylang.org/en/latest/abi-spec.html#json\r\nexport type AbiFunctionFragment = AbiBaseFragment & {\r\n\treadonly name: string;\r\n\treadonly type: string | 'function';\r\n\treadonly stateMutability?: string | 'nonpayable' | 'payable' | 'pure' | 'view';\r\n\treadonly inputs?: ReadonlyArray<AbiParameter>;\r\n\treadonly outputs?: ReadonlyArray<AbiParameter>;\r\n\r\n\treadonly constant?: boolean; // stateMutability == 'pure' or stateMutability == 'view'\r\n\treadonly payable?: boolean; // stateMutability == 'payable'\r\n};\r\n\r\nexport type AbiFallbackFragment = AbiBaseFragment & {\r\n\treadonly name: never;\r\n\treadonly type: string | 'fallback';\r\n\treadonly stateMutability: string | 'nonpayable' | 'payable' | 'pure' | 'view';\r\n\treadonly inputs: never;\r\n\treadonly outputs: never;\r\n\r\n\t// legacy properties\r\n\treadonly constant?: boolean; // stateMutability == 'pure' or stateMutability == 'view'\r\n\treadonly payable?: boolean; // stateMutability == 'payable'\r\n};\r\n\r\n// https://docs.soliditylang.org/en/latest/abi-spec.html#json\r\nexport type AbiEventFragment = AbiBaseFragment & {\r\n\treadonly name: string;\r\n\treadonly type: string | 'event';\r\n\treadonly inputs?: ReadonlyArray<AbiParameter>;\r\n\treadonly anonymous?: boolean;\r\n};\r\n\r\n// https://docs.soliditylang.org/en/latest/abi-spec.html#errors\r\nexport type AbiErrorFragment = AbiBaseFragment & {\r\n\treadonly name: string;\r\n\treadonly type: string | 'error';\r\n\treadonly inputs?: ReadonlyArray<AbiParameter>;\r\n};\r\n\r\n// https://docs.soliditylang.org/en/latest/abi-spec.html#json\r\nexport type AbiFragment =\r\n\t| AbiConstructorFragment\r\n\t| AbiFunctionFragment\r\n\t| AbiEventFragment\r\n\t| AbiErrorFragment\r\n\t| AbiFallbackFragment;\r\n\r\nexport type ContractAbi = ReadonlyArray<AbiFragment>;\r\n\r\nexport type AbiInput =\r\n\t| string\r\n\t| AbiParameter\r\n\t| {\r\n\t\t\tname: string;\r\n\t\t\ttype: string;\r\n\t\t\tcomponents?: Components;\r\n\t\t\tindex?: boolean;\r\n\t\t\tinternalType?: string;\r\n\t  }\r\n\t| { readonly [key: string]: unknown };\r\n\r\n// https://docs.soliditylang.org/en/develop/abi-spec.html#json\r\nexport type JsonFunctionInterface = {\r\n\ttype: 'function';\r\n\tname: string;\r\n\tinputs: Components[];\r\n\toutputs?: AbiInput[];\r\n\tstateMutability?: string;\r\n};\r\n\r\nexport type JsonEventInterface = {\r\n\ttype: 'event';\r\n\tname: string;\r\n\tinputs: Components[];\r\n\tindexed: boolean;\r\n\tanonymous: boolean;\r\n};\r\n\r\nexport type FilterAbis<Abis extends ContractAbi, Filter, Abi = Abis[number]> = Abi extends Filter\r\n\t? Abi\r\n\t: never;\r\n\r\ntype _TypedArray<Type, Size extends string> = Size extends ''\r\n\t? Type[]\r\n\t: FixedSizeArray<Type, ConvertToNumber<Size>>;\r\n\r\nexport type PrimitiveAddressType<Type extends string> = Type extends `address[${infer Size}]`\r\n\t? _TypedArray<Address, Size>\r\n\t: Type extends 'address'\r\n\t? Address\r\n\t: never;\r\n\r\nexport type PrimitiveStringType<Type extends string> = Type extends `string${string}[${infer Size}]`\r\n\t? _TypedArray<string, Size>\r\n\t: Type extends 'string' | `string${string}`\r\n\t? string\r\n\t: never;\r\n\r\nexport type PrimitiveBooleanType<Type extends string> = Type extends `bool[${infer Size}]`\r\n\t? _TypedArray<boolean, Size>\r\n\t: Type extends 'bool'\r\n\t? boolean\r\n\t: never;\r\n\r\nexport type PrimitiveIntegerType<Type extends string> = Type extends\r\n\t| `uint${string}[${infer Size}]`\r\n\t| `int${string}[${infer Size}]`\r\n\t? _TypedArray<Numbers, Size>\r\n\t: Type extends 'uint' | 'int' | `int${string}` | `uint${string}`\r\n\t? Numbers\r\n\t: never;\r\n\r\nexport type PrimitiveBytesType<Type extends string> = Type extends `bytes${string}[${infer Size}]`\r\n\t? _TypedArray<Bytes, Size>\r\n\t: Type extends 'bytes' | `bytes${string}`\r\n\t? Bytes\r\n\t: never;\r\n\r\nexport type PrimitiveTupleType<\r\n\tType extends string,\r\n\tTypeComponents extends ReadonlyArray<AbiParameter> | undefined | unknown = [],\r\n> = TypeComponents extends ReadonlyArray<AbiParameter>\r\n\t? Type extends 'tuple'\r\n\t\t? {\r\n\t\t\t\t// eslint-disable-next-line no-use-before-define\r\n\t\t\t\t[Param in TypeComponents[number] as Param['name']]: MatchPrimitiveType<\r\n\t\t\t\t\tParam['type'],\r\n\t\t\t\t\tParam['components']\r\n\t\t\t\t>;\r\n\t\t  }\r\n\t\t: Type extends `tuple[${infer Size}]`\r\n\t\t? _TypedArray<\r\n\t\t\t\t{\r\n\t\t\t\t\t// eslint-disable-next-line no-use-before-define\r\n\t\t\t\t\t[Param in TypeComponents[number] as Param['name']]: MatchPrimitiveType<\r\n\t\t\t\t\t\tParam['type'],\r\n\t\t\t\t\t\tParam['components']\r\n\t\t\t\t\t>;\r\n\t\t\t\t},\r\n\t\t\t\tSize\r\n\t\t  >\r\n\t\t: never\r\n\t: never;\r\n\r\ntype ObjectToArray<T extends unknown[]> = T extends [...infer R, infer A]\r\n\t? Record<R['length'], A> & ObjectToArray<R>\r\n\t: T;\r\ntype ArrToObjectWithFunctions<T extends unknown[]> = Array<unknown> & ObjectToArray<T>;\r\n\r\nexport type MatchPrimitiveType<\r\n\tType extends string,\r\n\tTypeComponents extends ReadonlyArray<AbiParameter> | undefined | unknown,\r\n> =\r\n\t| PrimitiveAddressType<Type>\r\n\t| PrimitiveStringType<Type>\r\n\t| PrimitiveBooleanType<Type>\r\n\t| PrimitiveIntegerType<Type>\r\n\t| PrimitiveBytesType<Type>\r\n\t| PrimitiveTupleType<Type, TypeComponents>\r\n\t| never;\r\n\r\ntype ContractMethodOutputParametersRecursiveArray<\r\n\tParams extends ReadonlyArray<unknown> | undefined,\r\n> =\r\n\t// check if params are empty array\r\n\tParams extends readonly []\r\n\t\t? []\r\n\t\t: Params extends readonly [infer H, ...infer R] // check if Params is an array\r\n\t\t? H extends AbiParameter\r\n\t\t\t? [\r\n\t\t\t\t\tMatchPrimitiveType<H['type'], H['components']>,\r\n\t\t\t\t\t...ContractMethodOutputParametersRecursiveArray<R>,\r\n\t\t\t  ]\r\n\t\t\t: []\r\n\t\t: [];\r\n\r\ntype ContractMethodOutputParametersRecursiveRecord<\r\n\tParams extends ReadonlyArray<unknown> | undefined,\r\n> =\r\n\t// check if params are empty array\r\n\tParams extends readonly []\r\n\t\t? []\r\n\t\t: Params extends readonly [infer H, ...infer R] // check if Params is an array\r\n\t\t? H extends AbiParameter\r\n\t\t\t? H['name'] extends '' // check if output param name is empty string\r\n\t\t\t\t? ContractMethodOutputParametersRecursiveRecord<R>\r\n\t\t\t\t: Record<H['name'], MatchPrimitiveType<H['type'], H['components']>> & // sets key-value pair of output param name and type\r\n\t\t\t\t\t\tContractMethodOutputParametersRecursiveRecord<R>\r\n\t\t\t: ContractMethodOutputParametersRecursiveRecord<R>\r\n\t\t: Params extends undefined | unknown // param is not array, check if undefined\r\n\t\t? []\r\n\t\t: Params;\r\n\r\nexport type ContractMethodOutputParameters<Params extends ReadonlyArray<unknown> | undefined> =\r\n\t// check if params are empty array\r\n\tParams extends readonly []\r\n\t\t? void\r\n\t\t: Params extends readonly [infer H, ...infer R] // check if Params is an array\r\n\t\t? R extends readonly [] // if only one output in array\r\n\t\t\t? H extends AbiParameter\r\n\t\t\t\t? MatchPrimitiveType<H['type'], H['components']>\r\n\t\t\t\t: []\r\n\t\t\t: // if more than one output\r\n\t\t\t  ArrToObjectWithFunctions<[...ContractMethodOutputParametersRecursiveArray<Params>]> &\r\n\t\t\t\t\tContractMethodOutputParametersRecursiveRecord<Params>\r\n\t\t: [];\r\n\r\nexport type ContractMethodInputParameters<Params extends ReadonlyArray<unknown> | undefined> =\r\n\tParams extends readonly []\r\n\t\t? []\r\n\t\t: Params extends readonly [infer H, ...infer R]\r\n\t\t? H extends AbiParameter\r\n\t\t\t? // TODO: Find a way to set name for tuple item\r\n\t\t\t  [MatchPrimitiveType<H['type'], H['components']>, ...ContractMethodInputParameters<R>]\r\n\t\t\t: ContractMethodInputParameters<R>\r\n\t\t: Params extends undefined | unknown\r\n\t\t? []\r\n\t\t: Params;\r\n\r\nexport type ContractConstructor<Abis extends ContractAbi> = {\r\n\t[Abi in FilterAbis<Abis, AbiConstructorFragment & { type: 'constructor' }> as 'constructor']: {\r\n\t\treadonly Abi: Abi;\r\n\t\treadonly Inputs: ContractMethodInputParameters<Abi['inputs']>;\r\n\t};\r\n}['constructor'];\r\n\r\nexport type ContractConstructorArgs<Abis extends ContractAbi> = {\r\n\t[Abi in FilterAbis<\r\n\t\tAbis,\r\n\t\tAbiConstructorFragment & { type: 'constructor' }\r\n\t> as 'constructor']: ContractMethodInputParameters<Abi['inputs']>;\r\n}['constructor'];\r\n\r\nexport type ContractMethod<Abi extends AbiFunctionFragment> = {\r\n\treadonly Abi: Abi;\r\n\r\n\treadonly Inputs: ContractMethodInputParameters<Abi['inputs']>;\r\n\treadonly Outputs: ContractMethodOutputParameters<Abi['outputs']>;\r\n};\r\n\r\nexport type ContractMethods<Abis extends ContractAbi> = {\r\n\t[Abi in FilterAbis<\r\n\t\tAbis,\r\n\t\tAbiFunctionFragment & { type: 'function' }\r\n\t> as Abi['name']]: ContractMethod<Abi>;\r\n};\r\n\r\nexport type ContractEvent<Abi extends AbiEventFragment> = {\r\n\treadonly Abi: Abi;\r\n\treadonly Inputs: ContractMethodInputParameters<Abi['inputs']>;\r\n};\r\n\r\nexport type ContractEvents<Abis extends ContractAbi> = {\r\n\t[Abi in FilterAbis<\r\n\t\tAbis,\r\n\t\tAbiEventFragment & { type: 'event' }\r\n\t> as Abi['name']]: ContractEvent<Abi>;\r\n};\r\n\r\nexport interface DecodedParams extends Record<string, unknown> {\r\n\t__length__: number;\r\n}\r\n"],"mappings":"AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}